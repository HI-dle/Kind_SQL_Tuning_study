# SQL 트레이스
---
## 1. SQL 트레이스 수집 및 파일 찾기

SQL을 튜닝할 때 가장 많이 사용하는 강력한 도구는 바로 `SQL 트레이스`다.

앞서 살펴 본 `사진 실행계획`과 `AutoTrace` 결과만으로 문제점을 찾을 수 없을 때 SQL 트레이스를 이요하면 문제점을 쉽게 찾아낼 수 있다.

### 현재 접속해 있는 세션에 트레이스를 설정하는 방법
```sql
SQL> alter session set sql_trace = true; -- 현재 세션의 SQL 트레이스 시작
SQL> select * from emp where empno = 7900; -- 트레이스 파일에 기록될 예정
SQL> select * from dual; -- 트레이스 파일에 기록될 예정
SQL> alter session set sql_trace = false; -- 현재 세션의 SQL 트레이스 종료
```

위와 같이 설정하고 SQL을 실행하면 아래 서버 디렉토리에 트레이스 파일이 생성된다.

```sql
-- 트레이스 파일이 생성되는 디렉토리 조회
SQL> select value
  2  from   v$diag_info
  3  where  name = 'Diag Trace' ;

VALUE -- 결과
------------------------------------------
/oracle/diag/rdbms/ora11g/trace
```

아래 쿼리를 이용하면 `파일명`까지 쉽게 확인할 수 있다.
```sql
select value
from v$diag_info
where name = 'Default Trace File' ;

VALUE -- 결과
------------------------------------------
/oracle/diag/rdbms/ora11g/trace/ora11g_ora_22827.trc
```

(참고) 오라클 10g 이하 버전은 복잡한 쿼리문을 통해 찾을 수 있다.
```sql
select r.value || '/' || lower(t.instance_name) || '_ora_'
        || trim(to_char(p.spid)) || '.trc' trace_file
from v$process p, v$session s, v$parameeter r, v$instance t
where p.addr = s.paddr
and r.name = 'user_dump_dest'
and s.sid = (select sid from v$mystat where rownum <= 1) ;

TRACE_FILE
--------------------------------------
/usr/local/oracle/admin/ORA10g/udump/ora10g_ora_22827.trc
```
---
## 2. 리포트 생성

트레이스 파일 내용은 사람이 그대로 분석하기가 쉽지 않다.

따라서 일반적으로 `TKProf 유틸리티`를 사용한다. ( 트레이스 커널 프로파일 )

- TKProf는 트레이스 파일을 보기 쉽게 포멧팅한 `리포트를 생성`해준다.

### TKProf 유틸리티 사용법
아래처럼 유닉스 쉘이나 도스 프롬프트에서 `tkprof`를 치면 사용법을 확인할 수 있다.

```shell
$ tkprof
Usage: tkprof tracefile outputfile [explain= ] [table= ]
              [print= ] [insert= ] [sys= ] [sort= ]
......
```

### 일반적인 tkprof 사용법
```shell
- report.trc 라는 이름으로 리포트를 생성하겠다.
$ tkprof ora11g_ora_22827.trc report.prf sys=no

* sys=no 옵션은 SQL을 파싱하는 과정에서 내부적으로 수행되는 SQL문을 제외해준다.
```

### 결과 확인하기
TKProf를 통해 생성된 리포트 파일을 vi 에디터나 윈도우 노트패드로 열어서 결과를 확인하면 된다.
```shell
$ vi report.prf

*****************************************************************************
select *
from emp where empno = 7900

call    count        cpu   elapsed     disk      query     current     rows
-----------------------------------------------------------------------------
Parse       1        0.00     0.00        0           0          0        0
Execute     1        0.00     0.00        0           0          0        0
Fetch       2        0.00     0.00        0           2          0        1
-----------------------------------------------------------------------------
total       4        0.00     0.00        0           2          0        1

Misses in library cache during parse: 1
Optimizer mode: ALL_ROWS
Parsing user id: 61

Rows  Rows Source Operation
------------------------------------------------------
   1  TABLE ACCESS BY INDEX ROWID EMP (cr=2 pr=0 pw=0 time=80 us)
   1    INDEX UNIQUE SCAN PK_EMP (cr=1 pr=0 pw=0 time=44 us)(object id 5278)
*****************************************************************************

```
---
## 3. 트레이스 결과 분석

> 트레이스 내용을 분석하는 작업은 어렵다. 아마 제대로 분석하려면 오라클 성능 고도화 원리와 해법을 모두 독파한 후에나 가능할지 모른다.

### 각 항목별 의미
- `call`: 커서의 진행 상태에 따라 Parse, Execute, Fetch 세 개의 Call로 나누어 각각에 대한 통계정보를 보여준다.
  - `Parse`: SQL을 파싱하고 실행계획을 생성하는 단계
  - `Execute`: SQL 커서를 실행하는 단계
  - `Fetch`: 레코드를 실제로 Fetch 하는 단계
- `count`: Parse, Execute, Fetch 각 단계가 수행된 횟수
- `cpu`: 현재 커서가 각 단계에서 사용한 cpu time
- `elapsed`: 현재 커서가 각 단계를 수행하는 데 소요된 시간
- `disk`: 디스크에서 읽은 블록 수
- `query`: Consistent 모드로 읽은 블록 수
- `current`: Current 모드로 읽은 블록 수
- `rows`: 각 단계에서 읽거나 갱신한 건수

논리적 I/O는 `query`와 `current` 항목을 더해서 구한다. 이는 DB 버퍼캐시를 경유해서 읽은 블록과 Direct Path I/O 방식으로 읽은 블록 모두 포함한다.

2절에서 살펴본 `AutoTrace`와 일치하는 항목을 매핑하면 아래와 같다.

| SQL 트레이스    | AutoTrace                              | 설명                                     |
|-------------|----------------------------------------|----------------------------------------|
| current     | db block gets                          | Current 모드로 읽은 블록 수                    |
| query       | consistent gets                        | Consistent 모드로 읽은 블록 수                 |
| disk        | physical reads                         | 디스크에서 읽은 블록 수                          |
| fetch count | SQL *Net roundtrips<br/>to/from client | 조회 결과를 전송을 위해 클라이언트가 발행한 Fetch Call 횟수 |
| fetch rows  | rows processed                         | 조회 건수                                  |

### Call 통계 아래쪽 실행계획 통계(Plan Statistics)에 나타나는 각 항목의 의미

```sql
Rows  Rows Source Operation
------------------------------------------------------
   1  TABLE ACCESS BY INDEX ROWID EMP (cr=2 pr=0 pw=0 time=80 us)
   1    INDEX UNIQUE SCAN PK_EMP (cr=1 pr=0 pw=0 time=44 us)(object id 5278)
```

`Rows`: 각 수행 단계에서 출력된 로우 수
  - (오라클 버전 7까지는 각 단계에서의 `처리 건수`를 보여주다가 8i부터 `출력 건수`로 바뀌기 시작했다.)

> ❓ 처리 건수와 출력 건수란?
> 
> 처리 건수는 말그대로 해당 실행 단계가 내부적으로 다룬 로우 수
> 
> 출력 건수는 다음 실행 단계로 실제 전달된 로우 수. 즉, 결과 건수라고 볼 수 있다.
> 
> ```sql
> -- EMP 테이블에 10000건, 조건 만족 100건 이라면?
> SELECT * FROM emp WHERE sal > 3000;
> 
> -- 처리건수 = 10000
> -- 출력건수 = 100
> ```

`(cr, pr, pw, time)`: 오라클은 출력(Flow-Out) 방식으로 바뀌면서 생긴 `단점을 보완하려고 이를 표현`하기 시작
  - 각각 `Consistent 모드 블록 읽기`, `디스크 블록 읽기`, `디스크 블록 쓰기`, `소요 시간`을 의미
  - 단점이란, 출력 방식(결과 건수만 보여주는)으로 바뀌었으므로 실제 작업량이 보이지 않음. 이를 지표로 보여주기 위함.

> 꼭 기억해야할 것!
> 
> 부모든 자식노드의 값을 포함한다는 사실.
> 
> ```sql
> -- 테이블 엑세스 단계의 cr=2다.
> 1  TABLE ACCESS BY INDEX ROWID EMP (cr=2 pr=0 pw=0 time=80 us)
> ```
> 
> ```sql
> -- PK_EMP 인덱스 단계는 cr=1이다.
> 1    INDEX UNIQUE SCAN PK_EMP (cr=1 pr=0 pw=0 time=44 us)(object id 5278)
> 
> -- 즉, 인덱스를 읽고 난 후 테이블을 액세스하는 단계의 순수 cr 개수(Consistent 모드 블록 읽기 개수)는 1이다.
> ```