## 7.1 통계정보와 비용 계산 원리

### 7.1.1 선택도와 카디널리티

선택도란, 전체 레코드 중에서 조건절에 의해 선택되는 레코드 비율을 말한다.
가장 단순한 '=' 조건으로 검색할 때의 선택도만 살펴보면, 컬럼 값 종류 개수(NDV -> Number of Distinct Values)를 이용해 아래와 같이 구한다.

`선택도` = 1 / NDV

카디널리티란, 전체 레코드 중에서 조건절에 의해 선택되는 레코드 개수이며, 아래 공식으로 구한다.

`카디널리티` = 총 로우 수 X 선택도 = 총 로우 수 / NDV

상품분류 컬럼에 '가전','의류','식음료','생활용품' 4개의 값이 있을때

`where 상품분류 ='가전'` 에 대한 선택도는 25%이다

옵티마이저는 이렇게 카디널리티를 구하고 데이터 액세스 비용을 계산해서 테이블 액세스 방, 조인 순서, 조인 방식등을 결정한다.

비용을 계산하는 출발점은 선택도다. 선택도를 잘못 계산하면, 카디널리티와 ㅂ비용도 잘못 계산되고, 결과적으로 비효율적인 액세스 방식과, 조인 방식을 선택하게 된다. 

### 7.1.2 통계정보

통계정보에는 오브젝트 통계와 시스템 통계가 있다. 오브젝트 통계는 다시 테이블 통계, 인덱스 통계, 컬럼 통계로 나뉜다.

**(1) 테이블 통계**

테이블 통계를 수집하는 명령어는 다음과 같다.

```sql
begin
  dbms_stats.gather_table_stats('scott', 'emp');
end;
```

수집된 테이블 통계정보는 아래와 같이 조회할수 있다.
all_tab_statistics 뷰에서도 같은 정보를 확인할 수 있다.

```sql
select num_rows, blocks, avg_row_len, sample_size, last_analyzed
from all_tables
where owner = 'SCOTT'
and table_name = 'EMP';
```

| 통계항목       | 설명 |
|---------------|------|
| NUM_ROWS      | 테이블에 저장된 총 레코드 개수 |
| BLOCKS        | 테이블 블록 수<br/>: ‘사용된’ 익스텐트(데이터가 한 건이라도 입력된 익스텐트)에 속한 총 블록 수<br/>※ 테이블에 할당된 총 블록 수는 DBA_SEGMENTS 또는 USER_SEGMENTS 뷰에서 확인 가능 |
| AVG_ROW_LEN   | 레코드당 평균 길이 (Bytes) |
| SAMPLE_SIZE   | 통계정보 수집 시 샘플링한 레코드 수 |
| LAST_ANALYZED | 통계정보 수집 일시 |


**(2) 인덱스 통계**

인덱스 통계를 수집하는 명령어는 다음과 같다.
```sql
---인덱스 통계만 수집

begin 
 dbms_stats.gather_index_stats(ownname => 'scott', indname => 'emp_x01');
end;

--테이블 통계를 수집하면서 인덱스 통계도 같이 수집
begin
dbms_stats.gather_table_stats('scott', 'emp', cascade=>true);
end;
```


수집된 인덱스 통계정보 확인법
```sql
  select blevel,
        leaf_blocks,
        num_rows,
        distinct_keys,
        avg_leaf_blocks_per_key,
        avg_data_blocks_per_key,
        clustering_factor,
        sample_size,
        last_analyzed
  from   all_indexes
  where  owner      = 'SCOTT'
  and    table_name = 'EMP'
  and    index_name = 'EMP_X01';
```


| 통계항목 | 설명 | 용도 |
|---------|------|------|
| BLEVEL | 브랜치 레벨의 약자.<br/>인덱스 루트에서 리프 블록에 도달하기 직전까지 읽게 되는 블록 수 | 인덱스 수직적 탐색 비용 계산<br/>(2장 1절(2.1), 3장 3절(3.3) 참조) |
| LEAF_BLOCKS | 인덱스 리프 블록 총 개수 | 인덱스 수평적 탐색 비용 계산 |
| NUM_ROWS | 인덱스에 저장된 레코드 개수 | 인덱스 수평적 탐색 비용 계산 |
| DISTINCT_KEYS | 인덱스 키값 조합으로 만들어지는 값의 종류 개수.<br/>실제 입력된 데이터 기준의 값 종류 수이며, 인덱스 키값을 모두 ‘=’ 조건으로 조회할 때의 선택도(Selectivity) 계산에 사용 | 인덱스 수평적 탐색 비용 계산<br/>(2장 1절(2.1), 3장 3절(3.3) 참조) |
| AVG_LEAF_BLOCKS_PER_KEY | 인덱스 키값을 모두 ‘=’ 조건으로 조회할 때 읽게 될 리프 블록 개수 | 테이블 액세스 비용 계산 |
| AVG_DATA_BLOCKS_PER_KEY | 인덱스 키값을 모두 ‘=’ 조건으로 조회할 때 읽게 될 테이블 블록 개수 | 테이블 액세스 비용 계산 |
| CLUSTERING_FACTOR | 인덱스 키값 기준으로 테이블 데이터가 모여 있는 정도.<br/>인덱스를 스캔하며 테이블 레코드를 찾을 때 읽게 될 테이블 블록 개수를 미리 계산해 놓은 수치 | 테이블 액세스 비용 계산<br/>(3장 1절(3.1), 2항(3.1.2) 참조) |

**(3) 컬럼통계**

수집된 컬럼 통계정보는 아래와 같이 조회할 수 있으며,
ALL_TAB_COL_STATISTICS 뷰에서도 같은 정보를 확인할 수 있다.

```sql
  select num_distinct,
        density,
        avg_col_len,
        low_value,
        high_value,
        num_nulls,
        sample_size,
        last_analyzed
  from   all_tab_columns
  where  owner       = 'SCOTT'
  and    table_name  = 'EMP'
  and    column_name = 'DEPTNO';
```

| 통계항목 | 설명 |
|---------|------|
| NUM_DISTINCT | 컬럼 값의 종류 개수 (NDV, Number of Distinct Values)<br/>예: 성별 컬럼이면 2 |
| DENSITY | ‘=’ 조건으로 검색할 때의 선택도를 미리 구해 놓은 값<br/>히스토그램이 없거나, 있더라도 100% 균일 분포라면 1 / NUM_DISTINCT 값과 동일 |
| AVG_COL_LEN | 컬럼 평균 길이 (Bytes) |
| LOW_VALUE | 최소 값 |
| HIGH_VALUE | 최대 값 |
| NUM_NULLS | 값이 NULL인 레코드 수 |
