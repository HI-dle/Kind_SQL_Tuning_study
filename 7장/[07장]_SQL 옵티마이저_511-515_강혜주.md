## 7.2 옵티마이저에 대한 이해

> SQL 옵티마이저와 실생활에서 흔히 사용하는 자동차 내비게이션과 비교하면서 SQL 옵티마이저에 대한 이해를 넓혀본다.

### 7.2.1 옵티마이저 종류

#### CBO: 비용기반(Cost-Based) 옵티마이저

사용자 쿼리를 위해 후보군이 될만한 실행계획들을 도출하고, 데이터 딕셔너리에 미리 수집해 둔 통계정보를 이용해 각 실행계획의 예상비용을 산정하고, 그중 가장 낮은 비용의 실행계획 하나를 선택하는 옵티마이저다.
CBO가 사용하는 통계정보로는 데이터량, 컬럼 값의 수, 컬럼 값 분포, 인덱스 높이, 클러스터링 팩터 등이 있다.
> - 데이터 량: 테이블 row수
> - 컬럼 값의 수: 적을수록 필터링 효과가 적다. (선택도가 낮다)
> - 컬럼 값 분포: 특정 컬럼에 값이 몰려있는지
> - 인덱스 높이: 높을수록 I/O 증가
> - 클러스터링 팩터: 인덱스 순서와 테이블 저장순서가 비슷한 정도(인덱스를 타고가면 테이블 블록도 연속적인지)

#### RBO: 규칙기반(Rule-Based) 옵티마이저

각 액세스 경로에 대한 우선순위 규칙에 따라 실행계획을 만드는 옵티마이저.
RBO는 데이터 특성을 나타내는 통계정보를 전혀 활용하지 않고 단순한 규칙에만 의존하기 때문에 대량 데이터를 처리하는 데 부적합하다.

자동차 내비게이션도 내부적으로 규칙을 사용할 것이다.
>- 목적지까지 고속도로로 최대한 가까이 이동한 후,
>- 자동차 전용도로, 시내 주요간선도로(왕복 6~10차선), 일반도로(왕복 2~4차선), 골목도로 순으로 찾아간다.

이런 단순한 방식도 어느 정도 보편타당하며, 가장 짧은 경로로 목적지까지 정확히 안내해 주는 기능으로는 손색이 없다. 하지만, 가장 빠른 길로 안내하려면 실시간 교통상황, 사고 및 공사 구간 등 더 다양한 정보를 활용해야 한다.

##### RBO가 사용하는 규칙
>인덱스 구조, 연산자, 조건절 형태가 순위를 결정하는 주요소, 데이터 분포, 건수, 실제 I/O를 고려하지 않는다.
>- 인덱스 → 풀스캔보다 우선
>- BETWEEN → 부등호보다 우선
>- ORDER BY 인덱스 → 풀스캔보다 우선

| 순위  | 액세스 경로                                                    |
| --- | --------------------------------------------------------- |
| 1   | Single Row by Rowid                                       |
| 2   | Single Row by Cluster Join                                |
| 3   | Single Row by Hash Cluster Key with Unique or Primary Key |
| 4   | Single Row by Unique or Primary Key                       |
| 5   | Clustered Join                                            |
| 6   | Hash Cluster Key                                          |
| 7   | Indexed Cluster Key                                       |
| 8   | Composite Index                                           |
| 9   | Single-Column Indexes                                     |
| 10  | Bounded Range Search on Indexed Columns (닫힌범위)            |
| 11  | Unbounded Range Search on Indexed Columns (열린범위)          |
| 12  | Sort Merge Join                                           |
| 13  | MAX or MIN of Indexed Column                              |
| 14  | ORDER BY on Indexed Column                                |
| 15  | Full Table Scan                                           |

RBO 규칙도 사용에 큰 무리가 없던 시절이 있었다. 하지만 지금과 같은 대용량 데이터베이스 환경에서는 전혀 대안이 될 수 없다.

#### 예시 1

```sql
select *
from 고객
where 고객유형코드 = 'C0123';
```

위의 고객유형코드에 인덱스가 있으면 RBO는 무조건 인덱스를 사용한다. Full Table Scan 순위가 15위로 가장 낮기 때문이다. 고객유형코드 조건을 만족하는 고객이 전체에서 90%를 차지한다면 RBO가 결코 좋은 선택을 했다고 보기 어렵다.

>- Table full scan은 시퀀셜 액세스, multiblock I/O
>- 인덱스 ROWID를 이용한 테이블 액세스는 랜덤액세스, Single block I/O

#### 예시 2

```sql
select *
from 고객
order by 고객명;
```

예시 2의 SQL에서도 고객명 컬럼에 인덱스가 있으면 RBO는 무조건 인덱스를 사용한다. 인덱스 컬럼에 대한 ORDER BY 순위(14위)가 Full Table Scan 순위(15위)보다 한 단계 높기 때문이다.

부분범위 처리가 가능한 상황에서 인덱스를 이용한 소트 연산을 생략하면 성능을 높이는 좋은 선택이 되겠지만, 그렇지 못한 상황에서 인덱스를 그대로 사용하면 전체 레코드를 액세스하는 것과 결국 동일한 효과를 낸다. 그래서 CBO는 ALL ROWS와 FIRST ROWS 두 가지 유형의 옵티마이저 모드를 두고 있다.

#### 예시 3
```sql
select *
from 사원
where 연령 >= 60
and 연봉 between 3000 and 6000;
```

RBO 규칙에 의하면, 인덱스 컬럼에 대한 BETWEEN 조건(10위)이 부등호 조건(11위)보다 우선순위가 높다. 따라서 연령과 연봉 컬럼에 각각 인덱스가 있다면 RBO는 위 SQL에 대해 무조건 연령 컬럼 인덱스를 사용한다.

BETWEEN은 닫힌 범위검색 조건이고, 부등호는 열린 범위검색 조건이므로 BETWEEN이 더 유리하다는 규칙은 어느 정도 타당하다. 하지만 모두가 말하듯 60세 이상 사원보다는 3000~6000 수준의 연봉을 받는 사원이 훨씬 많다. 그런데 RBO는 그 사실을 모른다.

> RBO의 이런 한계점 때문에 CBO가 탄생했다. <br> 따라서 대용량, 초대용량 업무 시스템에서 CBO 선택은 필수이다.<br> 다른 RDBMS와 마찬가지로 오라클도 CBO만 지원하고 있으며, 지금도 CBO에 대한 깊이 있는 이해와 경험이 중요하다.
>
> 옵티마이저는 스스로 최적의 결정을 하도록 돕는 데 역량을 집중해야 한다. 즉, 옵티마이저가 항상 최선의 선택을 하도록 하려면 `데이터와 시스템 특성을 고려해 정확한 통계정보 수집 및 유지`가 필요하다.

### 7.2.2 옵티마이저 모드

내비게이션에서 목적지를 검색하면, 이동 경로를 보여 주기에 앞서 검색 모드를 선택하게 된다. 보통 아래와 같은 검색 모드를 제공한다.

- 고속도로 우선 : 이동시간 단축
- 일반도로 우선 : 통행료 절감
- 최단거리 : 유류비 절감

비용기반 옵티마이저에도 비슷한 기능이 있다. `최적화 목표를 설정`하는 기능으로서 아래 세 가지 옵티마이저 모드 중 하나를 선택하면 된다.

- ALL_ROWS : 전체 처리속도 최적화 (배치, 리포트, 통계)
    - 쿼리 결과집합 `전체를 읽는 것`을 전제로 시스템 리소스(I/O, CPU, 메모리 등)를 가장 적게 사용하는 실행계획을 선택
- FIRST_ROWS : 최초 응답속도 최적화 `(deprecated)`
    - 옵티마이저는 전체 결과집합 중 `앞쪽 일부만 읽다가 멈추는 것`을 전제로 응답 속도가 가장 빠른 실행계획을 선택한다.
    -  ALL_ROWS와 비교하면, Table Full Scan 보다 인덱스를 더 많이 선택하고, 해시 조인, 소트 머지 조인보다 NL 조인을 더 많이 선택하는 경향을 보인다. (통으로 다읽어서 합치는거보다 부분적으로 읽어나가는걸 선호)
  >예를 들어, 100만 건의 결과집합 전체를 파일로 저장하려는데, 옵티마이저 모드가 FIRST_ROWS로 설정돼 있으면 인덱스를 이용해 소트 연산을 생략하는 실행계획이 선택된다. <br> 앞서 설명한, Order By 컬럼에 인덱스가 있으면 무조건 인덱스를 이용하는 RBO 규칙과 비슷하다. 그런데 사용자가 중간에 멈추지 않고 결과집합을 끝까지 읽는다면 테이블 스캔에 비해 전체 수행 속도가 더 느려지는 결과를 초래한다.

- FIRST_ROWS_N : 최초 N건 응답속도 최적화(화면 페이징, 목록 조회)
    - FIRST_ROWS_N으로 설정하면 옵티마이저는 사용자가 ‘앞쪽 N개 로우만 읽고 멈추는 것’을 전제로 응답 속도가 가장 빠른 실행계획을 선택한다. alter system 또는 alter session 명령어로 옵티마이저 모드를 설정할 때 N으로 지정할 수 있는 값은 아래와 같이 1, 10, 100, 1000 네 가지다.

```sql
alter session set optimizer_mode = first_rows_1;
alter session set optimizer_mode = first_rows_10;
alter session set optimizer_mode = first_rows_100;
alter session set optimizer_mode = first_rows_1000;
```

아래와 같이 FIRST_ROWS(n) 힌트로 설정할 때는 괄호 안에 0보다 큰 어떤 정수값이라도 입력할 수 있다.
```sql
select /*+ first_rows(30) */ col1, col2, col3
from t
where ...
```

FIRST_ROWS는 사용자가 데이터를 어느 정도 읽다가 멈출지를 지정하지 않았으므로 정확한 비용 산정이 어렵다. 반면, FIRST_ROWS_N은 읽을 데이터 건수를 지정했으므로 더 정확한 비용 산정이 가능하다. FIRST_ROWS_N이 FIRST_ROWS보다 더 완벽한 CBO 모드로 작동하는 이유다.