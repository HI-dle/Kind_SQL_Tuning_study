# SQL 옵티마이저

--- 

## 7.2.3 옵티마이저에 영향을 미치는 요소
- SQL과 연산자 형태
- 인덱스, IOT, 클러스터, 파티션, MV 등 옵티마이징 팩터
- 제약 설정
- 통계정보
- 옵티마이저 힌트
- 옵티마이저 관련 파라미터

### SQL과 연산자 형태
`SQL을 어떤 형태로 작성`했는지 또는 어떤 연산자(`=, IN, LIKE, BETWEEN, 부등호 등`)를 사용했는지에 따라 옵티마이저가 다른 선택을 할 수 있고, `궁극적으로 쿼리 성능에 영향`을 미친다.

### 인덱스, IOT, 클러스터, 파티션, MV 등 옵티마이징 팩터
똑같은 쿼리라도 `인덱스, IOT, 클러스터, 파티션, MV` 등을 구성 유무와 어떻게 구성했는지에 따라 `실행계획과 성능이 크게 달라진다.`

### 제약 설정
DBMS에 설정한 `PK, FK, Check, Not Null`과 같은 제약들은 `옵티마이저가 쿼리 성능을 최적화하는데 매우 중요한 메타 정보`로 활용된다.

### 통계정보
자동차 내비게이션이 사용하는 주소정보, 도로정보가 부정확할 떄 운전자가 곤란하고 위험한 상황에 처할 수 있는 것처럼, `옵티마이저가 사용하는 통계정보에 문제가 생기면 애플리케이션 성능이 느려지거나 심각한 장애를 초래할 수 있다.`

#### 시스템 장애가 발생하는 다양한 원인 예시
- 특정 테이블 통계정보를 갑자기 삭제 시
- 대량 데이터를 지웠다가 다시 입력할 때(테이블이 비어있는 타이밍에 통계 수집 스케줄링이 끼어들 때)
- 몇년간 갱신하지 않던 특정 테이블 통계정보를 갑자기 재수집
- 통계정보 없이 관리하던 테이블에 인덱스를 재생성
  - (오라클 10g부터 인덱스를 생성하면 인덱스 통계가 자동 수집됨)
- 테이블이나 인덱스를 재생성하면서 파티션 단위로만 통계정보를 수집한다.
  - (바인드 변수를 사용하면 파티션 통계가 아닌 글로벌 통계가 사용된다.)

```sql
🤔 바인드 변수를 사용하면 파티션 통계가 아닌 글로벌 통계가 사용된다.

SELECT *
FROM orders
WHERE order_month = '202403'; -- 어느 파티션인지 옵티마이저가 알 수 있어서 해당 파티션 통계 사용

-- 바인드 변수 사용
SELECT *
FROM orders
WHERE order_month = :month; -- 어느 파티션을 타야할 지 몰라서 글로벌 통계가 사용됨
```

### 옵티마이저 힌트
가장 절대적인 영향을 미치는 요소이다. 옵티마이저는 힌트를 명령어로 인식하고 그대로 따른다.

힌트가 잘 작동하지 않는다면, 아래 경우에 해당할 가능성이 높다.
- 문법적으로 맞지 않게 힌트를 기술
- 잘못된 참조 사용
- 의미적으로 맞지 않게 힌트를 기술
- 논리적으로 불가능한 액세스 경로
- 버그

### 옵티마이저 관련 파라미터
SQL, 데이터, 통계정보, 하드웨어 등 모든 환경이 같음에도 오라클 버전을 업그레이드하면 옵티마이저가 다르게 작동할 수 있다.

옵티마이저의 이런 행동 변화는 대게 `파라미터 추가` 또는 `기본값 변경`에 기인한다.

옵티마이저 모드 외에 옵티마이저 행동에 영향을 미치는 파라미터 목록은 아래 쿼리를 통해 얻을 수 있다.
```sql
select name, value, isdefault, default_value
from   v$sys_optimizer_env
```

- 이 뷰를 통해 확인 가능한 목록은 극히 일부다. 
- 종종 변경이 필요한 공식 파라미터 위주로 보여주며, 공개되지 않은 Hidden 파라미터 중에서는 관리자가 기본값을 변경한 것만 보여준다.

```
🤔 무슨 말인가

- 오라클에는 Hidden 파라미터가 존재한다. 이 파라미터의 기본값은 오라클 개발자가 코드로 정의했다.

- 오라클을 사용하는 사용자는 [일반사용자, DBA ..]가 있다.

- DBA는 DB 설정 업무를 하는데, Hidden 파라미터의 값을 변경할 수도 있다.(일반적으로는 건들지 않는 것 같다. 공식 파라미터가 아닌 히든 파라미터니까)

- 즉, 위의 저 말은 Hidden 파라미터 중에서는 DBA가 값을 임의로 변경한 파라미터만 보여준다는 것으로 이해가 가능하다.
```

---
## 7.2.4 옵티마이저의 한계
내비게이션이 주소정보, 도로정보를 아무리 잘 업데이트해도 항상 최선의 선택을 하는 것은 아니다.(내비게이션 두 개를 동시에 사용했을 때, 서로 다른 길로 안내하는 것처럼)

SQL 옵티마이저도 마찬가지다.

- 아무리 통계정보를 잘 수집하고, SQL을 잘 작성해도 실수가 있기 마련이다.
- DBMS에 따라, 버전에 따라 다른 실행계획을 생성한다.
- 옵티마이저도 사람이 만든 소프트웨어이니 어쩔 수 없다.
- 통계정보를 '필요한 만큼 충분히' 확보하는 것부터 불가능하다.(어마어마한 시간과 비용이 든다.)
- 바인드 변수에 컬럼 히스토그램을 활용할 수 없다.(해당 컬럼에 값이 확정되지 않았으므로)
- 기본적으로 비용기반으로 작동하지만, 내부적으로 여러 가정과 정해진 규칙을 이용해 선택한다는 사실 또한 한계
  - 비교 시에 사용하는 가정과 규칙들이 현실에 맞지 않을 수 있음
- 최적화에 허용되는 시간이 매우 짧다.

---
## 7.2.5 개발자의 역할
"안내사항이 실제 도로상황과 다를 수 있으니 이 시스템은 참고용으로 사용하십시오."

내비게이션이 스스로 경고하듯, 운전자는 스스로의 판단과 선택에 따라 운전해야 한다.

개발자또한 옵티마이저에만 의존할 것이 아니라 개발자 스스로 옵티마이저가 되어야 한다.

> 바쁘니 일단 옵티마이저에게 맡기지만, 그 결과물이 올바른지 실행계획을 통해 늘 점검하고, 더 개선할 여지는 없는지 찾으려고 노력해야 한다.
> 
> DBMS를 사용하기 전에는 데이터 추출 프로그램을 일일히 개발하고 성능을 개선하려고 많은 노력을 했고, 본인의 역할로 인식했다.
> 
> 하지만 요즘은 SQL 자체 성능은 DBA 또는 튜닝팀 역할이랄고 생각하는 듯하다. 실행계획을 확인하는 방법조차 모른다.
> 
> 마치 내비게이션에만 의존한채 달리는 운전자와 같다.
> 
> 고성능, 고효율 DB 애플리케이션을 구축하려면 소수 DBA나 튜너보다 다수 개발자의 역할이 더 중요하다.
> 
> 따라서 SQL 수행원리와 튜닝방법을 익히는 데도 노력과 시간을 투자하며, SQL 성능도 내가 지킨다는 장인 정신이 필요하다.

기본적으로 옵티마이저에게 많은 일을 맡기는 RDBMS 환경에서 SQL 성능을 높이기 위해 개발자가 할 일은 다음과 같다.
- 필요한 최소 블록만 읽도록 쿼리를 작성한다.
- 최적의 옵티마이징 팩터를 제공한다.
- 필요하다면, 옵티마이저 힌트를 사용해 최적의 액세스 경로로 유도한다.
