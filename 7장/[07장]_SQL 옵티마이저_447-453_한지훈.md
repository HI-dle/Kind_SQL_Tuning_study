# SQL 옵티마이저

--- 
 
## 해시 파티션

- 해시 파티션은 Range 파티션에 이어 오라클 8i 버전부터 제공하기 시작했다.
- 파티션 키 값을 해시 함수에 입력해서 반환받은 값이 같은 데이터를 같은 세그먼트에 저장하는 방식이다.
- 파티션 개수만 사용자가 결정하고 데이터를 분산하는 알고리즘은 오라클 내부 해시함수가 결정한다. 해시 파티션은 고객ID처럼 변별력이 좋고 데이터 분포가 고른 컬럼을 파티션 기준으로 선정해야 효과적이다.

```oracle-sql
create table 고객 (고객ID varchar2(5), 고객명 varchar2(10), ...)
partition by hash(고객ID) prtitions 4;
```

- 위는 고객ID 기준 고객 테이블을 해시 파티셔닝하는 방법의 예시이고 이를 통해 생성된 파티션을 그림으로 표현하면 다음과 같다.
![그림_6_13.png](image%2F%EA%B7%B8%EB%A6%BC_6_13.png)


- 검색할 때는 조건절 비교 값인 상수나 변수에 똑같은 해시 함수를 적용함으로써 읽을 파티션을 결정한다.
- 해시 알고리즘 특성상 등치 조건 또는 IN-List 조건으로 검색할 때만 파티션 Prunning이 작동한다.


## 리스트 파티션

- 오라클 9i 버전부터 제공하기 시작한 라스트 파티션은 사용자가 정의한 그룹핑 기준에 따라 데이터를 분할 저장하는 방식이다.

```oracle-sql
create table 인터넷매물 (물건코드 varchar2(5), 지역분류 varchar2(4), ...)
partition by list(지역분류) (
    partition P_지역1 values ('서울')
,    partition P_지역2 values ('경기', '인천')
,    partition P_지역3 values ('부산', '대구', '대전', '광주')
,    partition P_기타 values (DEFAULT) -> 기타지역
) ;
```

- Range 파티션에선 값의 순서에 따라 저장할 파티션이 결정되지만 리스트 파티션에서는 순서와 상관없이 불연속적인 값의 목록에 의해 결정된다.
- 해시 파티션과 비교하면 해시 파티션은 오라클이 정한 해시 알고리즘에 따라 임의로 분할하는 반면 리스트 파티션은 사용자가 정의한 논리적인 그룹에 따라 분할한다. 업무적인 친화도에 따라 그룹핑 기준을 정하되, 될 수 있으면 각 파티션에 값이 고르게 분산되도록 해야한다.


## 6.3.2 인덱스 파티션

- 테이블 파티션과 인덱스 파티션은 구분돼야 한다. 인덱스 파티션은 테이블 파티션과 맞물려 다양한 구성이 존재한다.
- 다양한 인덱스 파티션 구성을 설명하기 위해우선 테이블 파티션을 구분하자.
  - 비파티션 테이블
  - 파티션 테이블

- 인덱스도 테이블처럼 파티션 여부에 따라 파티션 인덱스와 비파티션 인덱스로 나뉘고 파티션 인덱스는 각 파티션이 커버하는 테이블 파티션 범위에 따라 로컬과 글로벌로 나뉜다.
  - 로컬 파티션 인덱스
  - 글로벌 파티션 인덱스
  - 비파티션 인덱스
- 로컬 파티션 인덱스는 각 테이블 파티션과 인덱스 파티션이 서로 1대1 대응 관계가 되도록 오라클이 자동으로 관리하는 파티션 인덱스를 말한다. 로컬이 아닌 파티션 인덱스는 모두 글로벌 파티션 인덱스이며 테이블 파티션과 독립적인 구성인 파티션 키, 파티션 기준 값의 정의를 갖는다.
- 테이블과 인덱스 파티션을 조합하면 여러 구성이 가능하다.

### 로컬 파티션 인덱스
- 로컬 파티션 인덱스는 각각 별도 색인을 만드는 것이다.
- Range 파티션을 설명하면서 에시로 만든 주문 테이블에 로컬 파티션 인덱스를 만들어 보자. CREATE INDEX 뒤 LOCAL 옵션을 주면 된다.

```oracle-sql
create index 주문_x01 on 주문 (주문일자, 주문금액) local;
create index 주문_x02 on 주문 (고객ID, 주문일자) local;
```

- 각 인덱스 파티션은 테이블 파티션 속성을 그대로 상속 받는다. 따라서 테이블 파티션 키가 주문일자면 인덱스 파티션 키도 주문일자가 된다. 로컬 파티션 인덱스를 로컬 인덱스라 줄여 부르기도 한다.
- 로컬 파티션 인덱스는 테이블과 정확히 1대1 대응을 갖도록 오라클 파티션을 자동으로 관리한다. 테이블 파티션 구성을 변경하더라도 인덱스를 재생성할 필요가 없다.
- 변경작업이 순식간에 끝나므로 피크 시간대만 피하면 서비스를 중단하지 않고도 작업할 수 있다. 로컬 파티션 인덱스의 장점은 관리 편의성에 있다.

### 글로벌 파티션 인덱스

- 글로벌 파티션 인덱스는 파티션을 테이블과 다르게 구성한 인덱스다. 구체적으로 파티션 유형이 다르거나 파티션 키가 다르거나 파티션 기준값 정의가 다른 경우다. 비파티션 테이블이어도 인덱스는 파티셔닝할 수 있다.
- Range 파티션을 설명하며 만든 주문 테이블에 주문금액 + 주문일자 순으로 글로벌 파티션 인덱스를 만들어보자. 로컬과 비슷하게 뒤에 GLOBAL 키워드를 주면 된다.

```oracle-sql
create index 주문_x03 on 주문 (주문금액, 주문일자) global 
partition by range(주문금액) (
    partition P_01 values less than (100000)
, partition P_MX values less than (MAXVALUE) -> 주문금액 >= 100000
);
```

- 글로벌 파티션 인덱스는 테이블 파티션 구성을 변경하는 순간 Unusable 상태로 바뀌므로 곧바로 인덱스를 재생성해 줘야 한다. 그동안 해당 테이블을 사용하는 서비스를 중단해야 한다.
- 인덱스가 정확히 1대1 관계가 되도록 DB 관리자가 파티션을 직접 구성할 수도 있지만 그렇다고 그것이 로컬 파티션은 아니다. 오라클이 인덱스 파티션을 자동으로 관리해 주지 않기 때문이다.

### 비파티션 인덱스

- 비파티션 인덱스는 말 그대로 파티셔닝 하지 않는 인덱스이다. 만드는 방법은 일단 create index와 같다.
```oracle-sql
create index 주문_x04 on 주문 ( 고객ID, 배송일자 );
```

- 비파티션 인덱스는 여러 테이블 파티션을 가리킨다. 그런 의미에서 비파티션 인덱스를 글로벌 비파티션 인덱스라 부르기도 한다.
- 비파티션 인덱스는 테이블 파티션 구성을 변경하는 순간 Unusable 상태로 바뀌므로 곧바로 인덱스를 재생성해 줘야 한다. 그동안 해당 테이블을 사용하는 서비스를 중단해야 한다.


