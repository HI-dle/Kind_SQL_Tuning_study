# SQL 옵티마이저

--- 

## 컬럼 히스토그램
 - =족나에 대한 선택도는 1/NUM_DISTINCT 공식으로 구하거나 미리 구해 놓은 DENSITY 값을 이용하면 된다.
 - 일반적인 컬럼에는 이 공식이 비교적 잘 들어맞지만 데이터 분포가 균일하지 않은 컬럼에는 그렇지 못하다.
 - 선택도를 잘못 구하면 데이터 액세스 비용을 잘못 산정하게 되고 결국 최적이 아닌 실행계획으로 이어진다. 그래서 옵티마이저는 일반적인 컬럼 통계 외 히스토그램을 추가로 활용한다.
 - 히스토그램은 컬럼 값별로 데이터 비중 또는 빈도를 미리 계산해 놓은 통계 정보이고 실제 데이터를 읽어 계싼해 둔 값이므로 게이터 분포가 많이 변하지 않는 한 거의 정확하다.

 - 오라클 12c에서 사용하는 히스토그램 유형에는 4가지가 있다.
   - 도수분포
     - 값 별로 빈도수 저장
   - 높이균형
     - 각 버킷의 높이가 동일하도록 데이터 분포 관리
   - 상위도수분포
     - 많은 레코드를 가진 상위 n개 값에 대한 빈도수 저장 (12c 이상)
   - 하이브리드
     - 도수분포와 높이군형 히스토그램의 특성 결합 (12c 이상)



- 히스토그램을 수집하려면 테이블 통계 수집할 때 method_opt 파라미터를 지정하면 된다.

```oracle-sql
begin
    dbms_stats.gather_table_stats ('scott', 'emp', cascade=>false, method_opt=>'for columns ename size 10, deptno size 4');
end;
/**
ename : 버킷 10개 히스토그램

deptno : 버킷 4개 히스토그램

나머지 컬럼은 히스토그램 생성 안 함

선택도가 중요한 컬럼만 의도적으로 히스토그램 관리

불필요한 히스토그램 남발 방지
**/
/

begin
    dbms_stats.gather_table_stats ('scott', 'emp', cascade=>false, method_opt=>'for all columns size 75');
end;
/**
모든 컬럼에 버킷 75개 히스토그램 생성

데이터 분포와 상관없이 강제
**/
/

begin
    dbms_stats.gather_table_stats ('scott', 'emp', cascade=>false, method_opt=>'for all columns size auto');
end;
/**
옵티마이저가 필요한 컬럼만 필요한 경우에만 히스토그램 생성

Oracle 권장 기본값으로 안정적인 실행 계획 유지
**/
```

- 수집된 컬럼 히스토그램은 조회할 수 있으며 all_tab_histogram 뷰에서도 같은 정보를 확인할 수 있다.
- 출려되는 결과 값은 히스토그램 유형에 따라 해석이 다르다.


### (4) 시스템 통계

- 시스템 통계는 애플리케이션 및 하드웨어 성능 특성을 측정한 것다.
  - CPU 속도
  - 평균적인 Single Block I/O 속도
  - 평균적인 Multiblock I/O 속도
  - 평균적인 Multiblock I/O 개수
  - I/O 서브시스템의 최대 처리량
  - 병렬 Slave의 평균적인 처리량
- 위 항목을 포함한 측정이다.

- 과거에는 옵티 마이저가 이들 항목을 고려하지 않았다. 옵티마이저 개발팀이 사용한 하드웨어 사양에 맞춰진 고정 상수값으로 처리한 셈이다. 그러다보니 실제 오라클이 설치된 운영 시스템 사양이 그보다 좋거나 나쁠 떄 옵티마이저가 최적이 아닌 실행 계획을 수립할 가능성이 생긴다.
- 시스템 사양 뿐만 아닌 애플리케이션 특성 및 동시 트랜잭션 발생량에 따라서도 이들 성능 특성이 달라진다. 이에 오라클은 제품이 설치된 하드웨어 및 애플리케이션 특성을 반영함으로써 옵티마이저가 보다 합리적으로 작동할 수 있게 하려고 9i부터 시스템 통계 수집 기능을 도입했다. 시스템 통계는 sys.aux_stats$ 뷰에서 조회할 수 있다.

## 7.1.3 비용 계산 원리
 
 - 지면 관계상 조인까지 포함한 모든 비용 계산 원리를 다 설명하지는 않는다.
 - 옵티마이저가 통계정보를 어떤 식으로 활용하는지는 이해할 필요가 있기에 단일 테이블을 인덱스로 액세스할 때 비용 계산 원리를 간단히 살펴보자.
 - 인덱스 키값을 모두 = 조건으로 검색할 때는 아래와 같이 인덱스 통계만으로 쉽게 비용을 계산할 수 있다.

```oracle-sql
비용 = BLEVEL --인덱스 수직적 탐색 비용
    + AVG_LEAF_BLOCKS_PER_KEY   --인덱스 수평적 탐색 비용 
    + AVG_DATA_BLOCKS_PER_KEY   --테이블 랜덤 액세스 비용
```

 - 인덱스 키값이 모두 = 조건이 아닐 때는 아래와 같이 컬럼 통계까지 활용한다.

```oracle-sql
비용 = BLEVEL --인덱스 수직적 탐색 비용
    + LEAF_BLOCKS X 유효 인덱스 선택도 --인덱스 수평적 탐색 비용 
    + CLUSTERING_FACTOR X 유효 테이블 선택도   --테이블 랜덤 액세스 비용
```
- BLEVEL, LEAF_BLOCKS, CLUSTERING_FACTOR는 인덱스 통계에서 얻을 수 있고 유효 인덱스 선택도와 유효 테이블 선택도는 컬럼 통계 및 히스토그램을 이용해 계산한다.
- 유효 인덱스 선택도란 전체 인덱스 레코드 중 액세스 조건에 의해 선택될 것으로 예상되는 레코드 비중을 의미한다.
- 유효 테이블 선택도란 전체 인덱스 레코드 중 인덱스 컬럼에 대한 모든 조건절에 의해 선택될 것으로 예상되는 레코드 비중을 의미한다.

> 비용(COST)의 정확한 의미
>
>방금 설명한 비용 계산식은 I/O 비용 모델 기준이다. I/O 비용 모델을 사용할 때 실행 계획에 나타나는 Cost는 예상 I/O Call 횟수이다.
> 반면 최신 CPU 비용 모델에서 Cost는 Single Block I/O를 기준으로 한 상대적 시간을 표현한다. 예시로 Cost가 100으로 표시되면 우리 시스템에서 Single Block I/O를 100번 하는 정도의 시간으로 해석하면 된다. 상대적 시간 개념이다.
> 
> 
> CPU비용 모델을 개발한 이유는 같은 실행계획으로 같은 양의 데이터를 읽어도 애플리케이션 및 하드웨어 성능 특성에 따라 절대 소요시간이 다를 수 있어서다. 똑같이 I/O Call을 100번 해도 그것이 Single Block I/O냐 MultiBlock I/O냐에 따라 속도가 다르고 시스템마다 Single Block I/O와 MultiBlock I/O 속도도 모두 다르다.







