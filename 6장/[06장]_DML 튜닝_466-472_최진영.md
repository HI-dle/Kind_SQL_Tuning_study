# 6.4 Lock과 트랜잭션 동시성 제어
## 목차
- `오라클 Lock`을 간단히 소개
- 개발자가 알아야 할 `기본적인 동시성 제어 기법` 설명
- 여러 채번 방식의 성능 비교를 통한 `테이블 식별자 설계 및 채번 방식 선택 기준 제시`

> `채번`: 중복되지 않는 식별자를 생성해서 저장하는 과정

## 6.4.1 오라클 Lock

오라클은 공유 리소스와 사용자 데이터를 보호할 목적으로 다양한 종류의 Lock을 사용한다.
- DML Lock, DDL Lock, 래치, 버퍼 Lock, 라이브러리 캐시 Lock/Pin 등
> `래치`는 SGA에 공유된 각종 자료구조를 보호하기 위해 사용
> 
> `버퍼 Lock`은 버퍼 블록에 대한 액세스를 직렬화하기 위해 사용
> 
> `라이브러리 캐시 Lock과 Pin`은 라이브러리 캐시에 공유된 SQL 커서와 PL/SQL 프로그램을 보호하기 위해 사용

이 중 애플리케이션 개발 측면에서 가장 중요하게 다루어야 할 Lock은 `DML Lock` 이다.

- DML 락은 다중 트랜잭션이 동시에 액세스하는 사용자 `데이터의 무결성을 보호`해 준다.
- DML 락에는 `테이블 락`과 `로우 락`이 있다.

## DML 로우 락
- DML 로우 락은 두 개의 동시 트랜잭션이 같은 로우를 변경하는 것을 방지한다. 하나의 로우를 변경하려면 로우 락을 먼저 설정해야 한다.

- 어떤 DBMS이든지 `DML 로우 락에는 배타적 모드`(X Lock)를 사용하므로 UPDATE, DELETE를 진행 중인 로우를 `다른 트랜잭션이 UPDATE 하거나 DELETE 할 수 없다.`

- `INSERT에 대한 로우 락 경합`은 Unique 인덱스가 있을 때만 발생한다.
  - 즉, Unique 인덱스가 있는 상황에서 두 트랜잭션이 같은 값을 입력하려고 할 떄, 블로킹이 발생한다.
    - (두 트랜잭션이 다른 값을 입력하거나, Unique 인덱스가 아예 없으면 Insert에 대한 로우 락 경합은 발생하지 않는다.)
  - 선행 트랜잭션이 커밋하면 후행 트랜잭션은 실패한다.
  - 선행 트랜잭션이 롤백하면 후행 트랜잭션은 성공한다.

### 오라클에서는 DML과 SELECT는 서로 진행을 방해하지 않는다.
MVCC 모델을 사용하는 오라클은 SELECT 문에 로우 락을 사용하지 않는다.

> 참고로, MVCC 모델을 사용하지 않는 DBMS는 `SELECT 문에 공유 락(S Lock)을 사용`한다.
> 
> 따라서, 같은 로우에 `두 트랜잭션이 SELECT를 하는 것이 호환된다.`
> 
> `반면, 공유 락(S Lock)과 배타 락(X Lock)은 호환되지 않기` 때문에, `DML과 SELECT가 서로 진행을 방해`할 수 있다.
> 
> 즉, 다른 트랜잭션이 읽고 있는 로우를 변경하려면 다음 레코드로 이동할 때까지 기다려야 하고,
> 
> 다른 트랜잭션이 변경 중인 로우를 읽으려면 커밋할 대까지 기다려야 한다.

### 결론
DML 로우 락에 의한 성능 저하를 방지하려면, 락을 필요 이상으로 오래 유지하지 않도록 커밋 시점을 조절해야 한다.

그에 앞서, 트랜잭션이 빨리 일을 마치도록, 즉 락이 오래 지속되지 않도록 관련 SQL을 모두 튜닝해야 한다.

즉, SQL 튜닝이 곧 락 튜닝이다.

---

## DML 테이블 락
- 오라클은 DML 로우 락을 설정하기에 앞서 `테이블 락`을 먼저 설정한다.
  - 현재 트랜잭션이 갱신 중인 테이블 구조를 다른 트랜잭션이 변경하지 못하게 막기 위함이다.
- 테이블 락을 `TM Lock`이라고 부르기도 한다.

> 테이블 락이라고 하면, 테이블 전체에 락이 걸린다고 생각하기 쉽다. 그래서 다른 트랜잭션이 더는 레코드를 추가하거나 갱신하지 못하게 막는다고 생각할 수 있다.
> 
> 그게 아니고, 오라클에서 말하는 테이블 락은, `자신(테이블 락을 설정한 트랜잭션)이 해당 테이블에서 현재 어떤 작업을 수행 중인지를 알리는 푯말이다.`

### 테이블 락의 여러가지 모드
오라클은 로우 락에는 항상 배타적 모드를 사용하지만, 테이블 락에는 여러가지 모드를 사용한다.
- `RS`: row share(또는 SS: sub share)
  - 로우 단위로 락을 걸 수 있는 작업을 하고 있다.
- `RX`: row exclusive(or SX: sub exclusive)
  - 나는 이 테이블의 로우를 변경 중이다.(insert/update/delete)
- `S`: share
  - 테이블 전체를 안정적으로 읽겠다.
- `SRX`: share row exclusive(or SSX: share/sub exclusive)
  - 읽기도 하고, 로우 변경도 하면서 다른 DML은 막겠다.(읽기 + 단독 수정)
- `X`: exclusive
  - 나 혼자 쓴다.

아래는 락 모드간 호환성을 나타낸 표다.

![표_6-2.png](image%2F%ED%91%9C_6-2.png)
- 선행 트랜잭션과 호환되지 않는 모드로 테이블 락을 설정하려는 후행 트랜잭션은 진행할 수 없다.

> 위에서 언급했듯, INSERT, UPDATE, DELETE, MERGE 문을 위해 로우 락을 설정하려면, 먼저 RX 모드 테이블 락을 설정해야 한다.
> 
> SELECT FOR UPDATE는 10gR1 이하는 RS 모드, 10gR2 이상은 RX 모드 테이블 락을 먼저 설정해야 한다.
> 
> `RS, RX 간`에는 같은 로우를 갱신하려고 할 때만 `로우 락 경합`이 발생하고, `테이블 락에 의한 경합은 절대 발생하지 않는다.`

### 락을 얻고자 하는 리소스가 사용 중일 때, 진로 선택
락을 얻고자 하는 리소스가 사용 중일 떄, `프로세스는 아래 세 가지 방법 중 하나를 택`한다.

1. 락이 해제될 때까지 `대기`
2. 일정 시간만 `기다리다 포기`
3. 기다리지 않고 `작업 포기`

여기서 보통은 내부적으로 진로가 결정되어 있지만, 사용자가 선택할 수 있는 경우도 있다.

사용자가 위 세 가지 옵션을 모두 선택할 수 있는 문장이 바로 `SELECT FOR UPDATE` 문이다.
```sql
select * from t for update -- 락이 해제될 때까지 대기

select * from t for update wait 3 -- 일정 시간만 기다리다 포기

select * from t for update nowait -- 기다리지 않고 작업 포기
```

> 💡 참고
> 
> `DML을 수행`하거나 `Lock Table 명령`을 이용해 테이블 락을 설정할 때는 기본적으로 기다리는 방법을 택하지만,
> 
> `NOWAIT` 옵션을 이용해 곧바로 작업을 포기하도록 사용자가 지정할 수 있다.
> 
> ```sql
> lock table emp in exclusive mode NOWAIT;
> ```
> 
> DDL을 수행할 때도 내부적으로 테이블 락을 설정하는데, 기본적으로 NOWAIT 옵션이 자동으로 지정된다.
> 
> 오라클 11g부터 `ddl_lock-timeout` 파라미터를 0보다 크게 설정하면, 설정한 시간만큼 기다리다 작업을 포기하게 할 수 있다.

---
 ## Lock을 푸는 열쇠, 커밋
- `블로킹`: 선행 트랙잭션이 설정한 락 때문에 후행 트랜잭션이 작업을 진행하지 못하고 멈춰 있는 상태
- `데드락`: 두 트랜잭션이 각각 특정 리소스에 락을 설정한 상태에서 맞은편 트랜잭션이 락을 설정한 리소스에 또 락을 설정하려고 진행하는 상황

오라클에서 데드락이 발생하면, 이를 먼저 인지한 트랜잭션이 문장 수준 롤백을 진행한 후에 아래 에러 메시지를 던진다.
```sql
ORA-00060: deadlock detected while waiting for resource
-- 데드락을 발생시킨 문장 하나만 롤백시키는 것
```

이렇게 되면, 데드락은 해소됐지만 `블로킹 상태`에 놓이게 된다. 따라서 이 메시지를 받은 트랜잭션은 `커밋 또는 롤백을 결정`해야만 한다.

결정하지 않는다면 대기 상태를 지속하게 되므로 주의가 필요하다.

### 불필요하게 트랜잭션을 길게 정의하지 않도록 주의하자.
오라클은 `데이터를 읽을 때 락을 사용하지 않으므로` 다른 DBMS에 비해 상대적으로 락 경합이 적게 발생한다.

읽는 트랜잭션의 진행을 막는 부담이 없으므로 `필요한 만큼 트랜잭션을 충분히 가져갈 수 있다.`

하지만 `불필요하게 트랜잭션을 길게 정의하지 않도록 주의해야한다.` 

#### 이유
- 트랜잭션을 롤백해야 할 때 너무 많은 시간이 걸릴 수 있다.
- Undo 세그먼트가 고갈되거나, Undo 세그먼트 경합을 유발할 수 있다.
  - Undo는 트랜잭션이 끝날 때까지 유지되기 때문

#### 해결책
- `같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록` 애플리케이션을 설계
- DML 락 때문에 동시성이 저하되지 않도록 `적절한 시점에 커밋하기`

#### 반대로 커밋을 너무 자주하면
- `커밋`: Redo 로그를 디스크에 기록 완료
- `LGWR`: Log Writer로 Redo 로그를 디스크에 기록하는 프로세스

불필요하게 커밋을 너무 자주 수행하면 서버 프로세스가 `LGWR`에게 로그 버퍼를 비우도록 요청하고 동기 방식으로 기다리는 횟수가 늘어난다.

> 서버 프로세스가 생성한 변경 기록들이 `로그 버퍼`에 쌓인다.
> 
> 쌓인 로그는 `커밋 시에 디스크에 옮겨진다.(디스크 I/O 발생)`
> 
> 따라서 `커밋을 너무 자주 수행하면, I/O가 많아진다.`
> 
> 또한, 서버 프로세스는 `LGWR이 로그버퍼를 파일에 기록했다는 보증을 기다리기 때문에(동기), 성능이 저하된다.`

#### 잦은 커밋으로 인한 성능 이슈 해결 방안
오라클 10gR2부터 제공하는 배치 커밋과 비동기식 커밋을 활용하는 방안을 검토할 수 있다.

옵션1: 커밋 요청을 모아서 할 것인지
- `IMMEDIATE(default)`: 커밋 명령을 받을 때마다 LGWR가 로그 버퍼를 파일에 기록
- `BATCH`: 세션 내부에 트랜잭션 데이터를 일정량 버퍼링했다가 일괄 처리

옵션2: 파일 기록 완료 메시지를 기다릴 것인지
- `WAIT(default)`: LGWR가 로그버퍼를 파일에 기록했다는 완료 메시지를 받을 때까지 대기(동기식 커밋)
- `NOWAIT`: LGWR의 완료 메시지를 기다리지 않고 바로 다음 트랜잭션 진행(비동기식 커밋)

#### 옵션 조합 예시(네가지 조합 가능)
```sql
commit write immediate wait;
commit write immediate nowait;
commit write batch wait;
commit write immediate nowait;
```