### Prefixed vs. Nonprefixed

파티션 인덱스를 Prefixed와 Nonprefixed로 나눌 수도 있다. 이는 인덱스 파티션 키 컬럼이 인덱스 구성상 왼쪽 선두 컬럼에 위치하는지에 따른 구분이다.

- Prefixed : 인덱스 파티션 키 컬럼이 인덱스 키 컬럼 왼쪽 선두에 위치한다. (파티션 키 = 인덱스의 첫 번째 컬럼)
- Nonprefixed : 인덱스 파티션 키 컬럼이 인덱스 키 컬럼 왼쪽 선두에 위치하지 않는다. 파티션 키가 인덱스 컬럼에 아예 속하지 않을 때도 여기에 속한다.

로컬과 글로벌, Prefixed와 Nonprefixed를 조합하면 아래 네 가지 구성이 나온다.

| 구분 | Prefixed | Nonprefixed |
|------|----------|-------------|
| 로컬 파티션 | 1 | 2 |
| 글로벌 파티션 | 3 | 4 (Not Support) |

글로벌 파티션 인덱스는 Prefixed 파티션만 지원되므로 결과적으로 세 개의 파티션 인덱스가 있고, 비파티션 인덱스를 포함해 아래 네 가지 유형으로 최종 정리할 수 있다.

1. 로컬 Prefixed 파티션 인덱스
2. 로컬 Nonprefixed 파티션 인덱스
3. 글로벌 Prefixed 파티션 인덱스
4. 비파티션 인덱스

조금 전 주문 테이블에 만든 네 개 인덱스를 조회해 보자.

```sql

SQL> select i.index_name, i.partitioned, p.partitioning_type
  2       , p.locality, p.alignment
  3  from   user_indexes i, user_part_indexes p
  4  where  i.table_name = '주문'
  5  and    p.index_name(+) = i.index_name
  6  order by i.index_name;
  
		(인덱스가 파티션인지 여부)
INDEX_NAME   PAR PARTITION LOCALITY ALIGNMENT
------------ --- ---------- -------- ----------
주문_X01     YES RANGE      LOCAL    PREFIXED        → 로컬 Prefixed 파티션 인덱스
주문_X02     YES RANGE      LOCAL    NON_PREFIXED    → 로컬 Nonprefixed 파티션 인덱스
주문_X03     YES RANGE      GLOBAL   PREFIXED        → 글로벌 Prefixed 파티션 인덱스
주문_X04     NO                              → 비파티션 인덱스

```

### 중요한 인덱스 파티션 제약

인덱스 파티션과 관련해 기억해야 할 중요한 제약이 한가지 있다.

"Unique 인덱스를 파티셔닝하려면, 파티션 키가 모두 인덱스 구성 컬럼이어야 한다."

그림 처럼 ‘주문일자’로 파티셔닝한 테이블이 있다. PK는 `주문일자 + 주문번호`이고, 인덱스는 로컬 파티션이다. 결국, `PK 인덱스도 주문일자로 파티셔닝한 셈`이므로 **파티션 키가 인덱스 구성 컬럼**이다.

[](image/6-19.png)

이 상태에서 2017년 12월 25일에 주문번호가 `123456`인 주문 레코드를 입력하면, 중복 값 확인을 위해 P2017_Q4 파티션 인덱스만 탐색하면 된다. 2017년 12월 주문은 P2017_Q4(2017년 4분기) 파티션에만 입력될 수 있기 때문이다.

이번에는 PK 인덱스가 그림 6-20처럼 ‘주문번호’ 단일컬럼인 경우를 보자. 테이블 파티션 키인 주문일자가 인덱스 구성 컬럼이 아니다. 실제로는 인덱스를 파티셔닝할 수 없지만, 파티셔닝을 허용했다고 가정하자.

[](image/6-20.png)

이 상태에서 주문번호가 123456인 주문 레코드를 입력하려면, 중복 값이 있는지 확인하려고 인덱스 파티션을 모두 탐색해야 한다. 주문번호가 123456인 레코드는 어떤 파티션에도 입력될 수 있기 때문이다. 게다가, 그 레코드를 입력하고 커밋하기 전까지, 다른 트랜잭션이 같은 주문번호를 다른 파티션에 입력하는 현상까지 막으려면 추가적인 Lock 메커니즘이 필요하다.

Unique 인덱스를 파티셔닝할 때 파티션 키가 인덱스 컬럼에 포함돼야 한다는 조건은 `DML 성능 보장`을 위해 당연히 있어야 할 제약조건이다. 그리고 파티션 키 조건 없이 PK 인덱스로 액세스하는 수많은 쿼리 성능을 위해서도 필요하다. 만약 그림 6-20과 같은 PK 인덱스 파티셔닝을 허용하면, 파티션 키(주문일자) 조건 없이 PK 컬럼(주문번호)만으로 조회할 때 모든 파티션 인덱스를 탐색해야 하기 때문이다.

문제는, 이 제약으로 인해 PK 인덱스를 로컬 파티셔닝하지 못하면 파티션 Drop, Truncate, Exchange, Split, Merge 같은 파티션 구조 변경 작업도 쉽지 않다는 데 있다.
이들 작업을 하는 순간, PK 인덱스가 `Unusable 상태로 바뀌기 때문`이다. 곧바로 인덱스를 Rebuild 하면 되지만, 그동안 해당 테이블을 사용하는 서비스를 중단해야 한다. 서비스 중단 없이 파티션 구조를 빠르게 변경하려면, PK를 포함한 모든 인덱스가 로컬 파티션 인덱스이어야 한다.


‘파티션을 활용한 대량 UPDATE/DELETE/INSERT’는 파티션 구조 변경 작업을 수반하며, ILM을 지원하는 매우 중요한 기능이다. 이 기능을 활용해 ILM 관리체계를 효과적으로 운영하려면 가급적 인덱스를 로컬 파티션으로 구성해야 하며, 그러기 위해 테이블을 설계할 때부터 PK를 잘 구성해 줘야 한다. 구체적으로, 대량으로 데이터를 추가/변경/삭제하는 기준 컬럼을 PK에 포함하려고 노력해야 한다.

> ILM 은 **데이터 생명주기 관리 체계**를 말한다.
> 과거데이터를 주기적으로 비용이 더 낮은 저장소로 옮기고, 일정기간이 지나면 폐기하는 프로세스와 정책등을 포함한다.

## 6.3.3 파티션을 활용한 대량 UPDATE 튜닝

인덱스가 DML 성능에 큰 영향을 미치므로 대량 데이터를 입력/수정/삭제할 떄는 6.1.4에서 얘기한 것 처럼 인덱스를 Drop / Unusable 상태로 변경하고서 작업하는 방법을 많이 활용한다. 손익분기점은 5% 정도 로 본다. 즉, 입력/수정/삭제하는 데이터 비중이 5%를 넘는다면, 인덱스를 그대로 둔 상태에서 작업하기보다 인덱스 없이 작업한 후에 재생성하는 게 더 빠르다는 뜻이다.

> 5%라고 얘기했지만 실제로는 그 이하 지점에서 결정될 때가 많다고 한다. 테이블이 클 수록 손익분기점이 더 낮아진다.

거래 테이블에 10억 건이 저장돼 있다.

아래 UPDATE 문을 이용해 2015년 1월 1일 전에 발생한 거래 데이터를 수정하려는데, 거래일자 조건을 만족하면서 상태코드 <> 'ZZZ'인 데이터가 5,000만 건(5%)이다. 테이블 레코드 5,000만 건을 변경하면서 거래 X2 인덱스(상태코드 컬럼 포함)까지 실시간으로 관리하려면 어마어마한 시간이 소요된다.

```sql
update 거래 set 상태코드 = 'ZZZ'
where 상태코드 <> 'ZZZ'
and 거래일자 < '20150101';
```

그렇다면 과연 5,000만 건 데이터를 수정하기 위해 10억 건짜리 인덱스를 Drop 했다가 재생성할 것인가? 10억 건 인덱스를 재생성하는 데 걸리는 시간도 만만치 않다. 이 지점에서 고민이 생긴다.

어느 쪽이 더 빠를지는 상황에 따라 다르므로 테스트해 봐야 알 수 있지만, 어느 쪽이 더 빠르건 간에, 실무적으로 이 정도 대용량 테이블이라면 인덱스를 그대로 둔 상태에서 작업하는 경우가 많다. 인덱스 전체를 재생성해야 하는 부담이 그만큼 크기 때문이다.

### 파티션 Exchange를 이용한 대량 데이터 변경

테이블이 파티셔닝돼 있고 인덱스도 다행히 로컬 파티션이라면, 좋은 해법이 있다. 수정된 값을 갖는 임시 세그먼트를 만들어 원본 파티션과 바꿔치기하는 방식이다. 작업 순서는 다음과 같다. (스크립트를 단순화하기 위해 2015년 1월 1일 전에 발생한 거래 데이터는 모두 ‘201412’ 파티션에 저장돼 있다고 가정하자. 즉, ‘201412’ 파티션이 첫 번째 파티션이다.)

1. 임시 테이블(거래_t)을 생성한다. 할 수 있다면 nologging 모드로 생성한다.

```sql
create table 거래_t
nologging
as
select * from 거래 where 1 = 2;
```

2. 거래 데이터를 읽어 임시 테이블에 입력하면서 상태코드 값을 수정한다.

```sql
insert /*+ append */ into 거래_t
select 고객번호, 거래일자, 거래순번, ...
     , (case when 상태코드 <> 'ZZZ' then 'ZZZ' else 상태코드 end) 상태코드
from   거래
where  거래일자 < '20150101';
```

3. 임시 테이블에 원본 테이블과 같은 구조로 인덱스를 생성한다. 할 수 있다면 nologging 모드로 생성한다.

```sql
create unique index 거래_t_pk on 거래_t (고객번호, 거래일자, 거래순번) nologging;
create index 거래_t_x1 on 거래_t (거래일자, 고객번호) nologging;
create index 거래_t_x2 on 거래_t (상태코드, 거래일자) nologging;
```

4. 2014년 12월 파티션과 임시 테이블을 Exchange 한다.

```sql
alter table 거래
exchange partition p201412 with table 거래_t
including indexes without validation;
```

5. 임시 테이블을 Drop 한다.

```sql
drop table 거래_t;
```

6. (nologging 모드로 작업했다면) 파티션을 logging 모드로 전환한다.

```sql
alter table 거래 modify partition p201412 logging;
alter index 거래_pk modify partition p201412 logging;
alter index 거래_x1 modify partition p201412 logging;
alter index 거래_x2 modify partition p201412 logging;
```

