# DML 튜닝

---

- 인덱스와 조인 튜닝을 DML 문에도 그대로 적용할 수 있지만 이번 절에서는 DML 성능에 영향을 주는 다른 요소와 튜닝 방법들을 모아 따로 설명하고자 한다. DML 성능에 영향을 미치는 요소에 어떤 것들이 있는지부터 살펴보자.

### 6.1.1 DML 성능에 영향을 미치는 요소
 
 - 인덱스
 - 무결성 제약
 - 조건절
 - 서브쿼리
 - Redo 로깅
 - Undo 로깅
 - Lock
 - 커밋


### 인덱스와 DML 성능

 - 테이블에 레코드를 입력하면 인덱스에도 입력해야 한다. 테이블은 Freelist를 통해 입력할 블록을 할당받지만 인덱스는 정렬된 자료구조이므로 수직적 탐색을 통해 입력할 블록을 찾아야 한다. 인덱스에 입력하는 과정이 더 복잡함으로 DML 성능에 미치는 영향도 더 크다.

![그림_6_1.png](image%2F%EA%B7%B8%EB%A6%BC_6_1.png)

> 테이블마다 데이터 입력이 가능한 블록 목록을 관리하는데 이것을 Freelist라 한다.


- DELETE 할 때도 마찬가지다. 테이블에서 레코드 하나를 삭제하면 인덱스 레코드를 모두 찾아서 삭제해야 한다. UPDATE 할 떄는 변경된 컬럼을 참조하는 인덱스만 찾아서 변경해 주면 된다. 대신, 테이블에서 한 건 변경할 때마다 인덱스에 두 개 오퍼레이션이 발생한다. 인덱스는 정려된 자료구조이기 때문이고 예시로 A를 K로 변경하면 저장 위치도 달라지므로 삭제 후 삽입하는 방식으로 처리한다.

![그림_6_2.png](image%2F%EA%B7%B8%EB%A6%BC_6_2.png)


 - 인덱스 개수가 DML 성능에 미치는 영향이 매우 큰 만큼, 인덱스 설계에 심혈을 기울여야 한다. 핵심 트랜잭션 테이블에서 인덱스 하나라도 줄이면 TPS(Transaction Per Second)는 그만큼 향상된다.

- 아래는 인덱스 개수가 DML 성능에 미치는 영향을 직접 테스트 한 것이다.

```oracle-sql
SQL > create table source
        as
        select b.no, a.*
        from    (select * from emp where rownum <= 10) a
                (select rownum as no from dual connect by level <= 10000) b;

SQL > create table target
        as
        select * from source where 1 = 2;
        
        
SQL > alter table target add
        constraint target_pk primary key(no, empno);
```


- 방금 생성한 SOURCE 테이블에는 레코드가 100만 개가 입력돼 있다. TARGET 테이블은 현재 비어 있고 TARGET 테이블에 PK 인덱스 하나만 생성한 상태에서 SOURCE 테이블을 읽어 레코드 100만 개를 입력해보자.

```oracle-sql
SQL> set timing on;
SQL> insert into target
        select *from source;


1000000 개의 행이 만들어졌습니다.

경   과: 00:00:04.95
```

- 4.95초만에 수행을 마쳤다. 인덱스를 두 개 더 생성하고 다시 100만 건을 입력해 보자.

```oracle-sql
SQL> truncate table target;

SQL> create index target_x1 on target(ename);

SQL> create index target_x2 on target(deptno, mgr);

SQL> insert into target
        select * from source;

1000000 개의 행이 만들어졌습니다.

경   과: 00:00:38.98
```

- 38.98초로 무려 8배나 느려졌다. 인덱스 두 개의 영향력이 이 정도로 크다.

### 무결성 제챡과 DML 성능

 - 데이터베이스에 논리적으로 의미 있는 자료만 저장되게 하는 데이터 무결성 규칙으로는 아래 4개가 있다.
   - 개체 무결성
   - 참조 무결성
   - 도메인 무결성
   - 사용자 정의 무결성
 
 - 이들 규칙을 애플리케이션으로 구현할 수 있지만 DBMS에서 PK, FK, Check, NotNull 같은 제약을 설정하면 더 완벽하게 데이터 무결성을 지켜낼 수 있다.
 - PK, FK 제약은 Check, NotNull 제약보다 성능에 더 큰 영향을 미친다. Check, NotNull은 정의한 제약 조건을 준수하는지만 확인하면 되지만, PK, FK 제약은 실제 데이터를 조회해 봐야 하기 때문이다.
 - 앞서 진행한 테스트에 이어 이번에는 일반 인덱스와 PK 제약을 모두 제거한 상태에서 100만건 입력하는 데 걸리는 시간을 확인해보자.

```oracle-sql
SQL> drop index target_x1;

SQL> drop index target_x2;

SQL> alter table target drop primary key;

SQL> truncate table target;

SQL> insert into target
        select * from source;

1000000 개의 행이 만들어졌습니다.

경   과: 00:00:01.32
```

![표_6_1.png](image%2F%ED%91%9C_6_1.png)


### 조건절과 DML 성능

- 조건절만 포맣나는 가장 기본적인 DML 문과 실행계획이다.

```oracle-sql
SQL> UPDATE emp SET sal = sal * 1.1 WHERE deptno = 40;

--------------------------------------------------------------------------------------------------
| Id  | Operation                      | Name            | Rows | Bytes | Cost (%CPU)|    Time   |
--------------------------------------------------------------------------------------------------
|   0 | UPDATE STATEMENT               |                 |      |       |     3   (0) |          |
|   1 |  UPDATE                        | EMP             |      |       |             |          |
|   2 |   TABLE ACCESS BY INDEX ROWID  | EMP             |    1 |    13 |     3   (0) | 00:00:01 |
|   3 |    INDEX RANGE SCAN            | EMP_X01         |    1 |       |     2   (0) | 00:00:01 |
--------------------------------------------------------------------------------------------------



SQL> DELETE FROM emp WHERE deptno = 40;

--------------------------------------------------------------------------------------------------
| Id  | Operation                      | Name            | Rows | Bytes | Cost (%CPU)|    Time   |
--------------------------------------------------------------------------------------------------
|   0 | DELETE STATEMENT               |                 |      |       |     3   (0) |          |
|   1 |  DELETE                        | EMP             |      |       |             |          |
|   2 |   TABLE ACCESS BY INDEX ROWID  | EMP             |    1 |    13 |     3   (0) | 00:00:01 |
|   3 |    INDEX RANGE SCAN            | EMP_X01         |    1 |       |     2   (0) | 00:00:01 |
--------------------------------------------------------------------------------------------------

```

- SELECT 문과 실행꼐획이 다르지 않으므로 이들 DML 문에는 2장과 3장에서 학습한 인덱스 튜닝 원리를 그대로 적용할 수 있다.

### 서브쿼리와 DML 성능

- 서브쿼리를 포함하는 DML과 실행계획에는 조인을 위한 NESTED LOOPS, 서브쿼리 결과의 중복 제거를 위해 SORT UNIQUE 발생, 두 테이블의 인덱스를 각각 RANGE SCAN을 통해 진행된다. 
- 단순 조건절은 인덱스 스캔 후 바로 UPDATE/DELETE 
- 서브쿼리는 EMP + DEPT 조인 후 NESTED LOOPS + SORT UNIQUE + 양쪽 테이블 인덱스 스캔 발생한다.
- SELECT 문과 실행 계획이 다르지 않다는 말은 DML 실행시 Oracle 옵티마이저는 데이터를 먼저 찾는 SELECT 실행 계획을 만든 뒤 그 결과를 기반으로 UPDATE 또는 DELETE 작업을 수행하기 때문이다. 그러므로 서브쿼리나 조인시 조인 튜닝의 원리를 적용할 수 있다.

### Redo 로깅과 DML 성능

 - 오라클은 데이터파일과 컨트롤 파일에 가해지는 모든 변경사항을 Redo 로그에 기록한다. Redo 로그는 트랜잭션 데이터가 어떤 이유에서건 유실됐을 때, 트랜잭션을 재현함으로써 유실 이전 상태로 복구하는 데 사용된다.
 - DML을 수행할 때마다 redo 로그를 생성해야 하므로 Redo 로깅은 DML 성능에 영향을 미친다. INSERT 작업에 대해 Redo 로깅 생략 기능을 제공하는 이유가 여기에 있다. 이 기능은 2절 2항에서 설명한다.

### Redo 로그의 용도

 - Redo 로그는 3가지 목적에 사용된다.
   - Database Recovery
   - Cache Recovery
   - Fast Commit
 - 첫째, Redo 로그는 물리적으로 디스크가 깨지는 등의 media Fail 발생 시 데이터베이스를 복구하기 위해 사용한다.
 - 이때는 온라인 Redo 로그를 백업해 둔 Archived Redo 로그를 이용하게 된다. Media Recovery라고도 한다.
 - 둘째, Redo 로그는 Cache Recovery를 위해 사용하며 다른 말로는 Instance Recovery라고도 한다. 모든 DBMS가 버퍼캐시를 도입하는 이유가 I/O 성능을 높이기 위해서인데, 버퍼캐시는 휘발성이다. 캐시에 저장된 변경사항이 디스크 상의 데이터 블록에 아직 기록되지 않은 상태에서 정전 등이 발생해 인스턴스가 비정상적으로 종료되면, 그때까지의 작업내용을 모두 잃게 된다는 뜻이다. 이러한 트랜잭션 데이터 유실에 대비하기 위해 Redo 로그를 남긴다.
 - 마지막으로 Redo 로그는  Fast Commit을 위해 사용한다. 변경된 메모리 버퍼블록을 디스크상의 데이터 블록에 반영하는 작업은 랜덤 액세스 방식으로 이루어지므로 매우 느리다 반면 로그는 Append 방식으로 기록하므로 상대적으로 빠르다. 따라서 트랜잭션에 의한 변경 사항을 우선 Append 방식으로 빠르게 로그 파일에 기록하고, 변경된 메모리 버퍼블록과 데이터 파일 블록 간 동기화는 적절한 수단을 이용헤 나중에 배치 방식으로 일괄 수행한다.
 - 사용자의 갱신내용이 메모리상의 버퍼블록에만 기록된 채 아직 디스크에 기록되지 않았지만 Redo 로그를 믿고 빠르게 커밋을 완료한다는 의미에서 이를 Fast Commit이라 부른다.
 - 커밋 정보까지 Redo 로그 파일에 안전하게 기록했다면 인스턴스 Crash가 발생해도 언제든 복구할 수 있으므로 오라클은 안심하고 커밋을 완료할 수 있다.










