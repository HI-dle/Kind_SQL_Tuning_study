### 절차적 루프 처리

#### 데이터베이스 Call이 성능에 미치는 영향

```sql
create table source /*기준테이블*/
as
    select b.no, a.*
    from (select * from emp where rownum <= 10) a
       , (select rownum as no from dual connect by level <= 100000) b;

create table target /*스키마만 동일한 타겟 테이블*/
as
    select * from source where 1 = 2;

```

> source 테이블 레코드 수 : 100만 건

- SOURCE 테이블을 읽어 100만 번 루프를 돌면서 건건이 TARGET 테이블에 입력

```sql
set timing on; /*SQL 실행 시간을 화면에 표시하도록 설정*/

begin
    for s in (select * from source) /*전채 레코드를 하나씩 선택하며 insert*/
    loop
        insert into target values ( s.no, s.empno, s.ename, s.job, s.mgr
                                   , s.hiredate, s.sal, s.comm, s.deptno );
    end loop;

    commit; /*모든 루프 처리 완료 후 한번에 커밋*/
end;
/

/* 결과: 00:00:29.31 */
```

- 루프를 돌면서 건건이 Call이 발생했지만, 네트워크를 경유하지 않는 Recursive Call이므로 그나마 29초 만에 수행을 마쳤다. (네트워크 왕복비용x)

---

> ### 커밋과 성능
>
> - 커밋을 루프 안쪽으로 옮겨서 실행한 경우
> ```sql
> begin
>     for s in (select * from source)
>     loop
>         insert into target values ( s.no, s.empno, s.ename, s.job, s.mgr
>                                    , s.hiredate, s.sal, s.comm, s.deptno );
> 
>         commit; /*한 건 insert 후 커밋*/
>     end loop;
> end;
> /
> 
> /*결과: 00:01:00.50*/
> ```
>
> 커밋을 루프 안쪽으로 옮긴 후 29초 걸리던 프로그램 수행 시간이 1분으로 늘어났다.
> 커밋을 자주하게 되면 성능에도 문제가 생기지만 원자성에도 문제가 생긴다. (커밋된 결과는 롤백할 수 없으므로)
>
> 반대로 매우 오래걸리는 트랜잭션을 한 번도 커밋하지 않고 진행하면 Undo 공간 부족으로 시스템에 여러 부작용을 야기할 수 있다.
> 트랜잭션의 원자성이 중요해 반드시 그렇게 처리해야한다면 Undo 공간을 늘려야하지만, 그렇지 않다면 적당한 주기로 커밋하는 방안을 고려할 수 있다.
>
> ```sql
> if mod(i, 100000) = 0 then -- 10만 번에 한 번씩 커밋
>     commit;
> end if;
> ```
>
> 이렇게 처리하면 Undo 공간은 절약되지만 성능은 맨 마지막에 한 번 커밋하는 것과 차이가 크지 않다.

Java 프로그램으로 수행하면 이는 네트워크를 경유하는 User Call 이므로 성능이 급격히 나빠진다.

```java

public class JavaLoopQuery {
    public void execute() throws Exception {
        String SQLstmt = "select no, empno, ename, job, mgr"
                       + "     , to_char(hiredate, 'yyyymmdd hh24miss'), sal, comm, deptno "
                       + "from source";
		//전체 데이터 한번에 읽고
        PreparedStatement stmt = con.prepareStatement(SQLstmt);
        ResultSet rs = stmt.executeQuery();
        while(rs.next()) { //하나씩 돌면서
            long    no       = rs.getLong(1);
            long    empno    = rs.getLong(2);
            String  ename    = rs.getString(3);
            String  job      = rs.getString(4);
            int     mgr      = rs.getInt(5);
            String  hiredate = rs.getString(6);
            long    sal      = rs.getLong(7);
            long    comm     = rs.getLong(8);
            int     deptno   = rs.getInt(9);
			//insert 수행
            insertTarget(con, no, empno, ename, job, mgr, hiredate, sal, comm, deptno);
        }
        rs.close();
        stmt.close();
    }

    public void insertTarget( long   p_no,
                              long   p_empno,
                              String p_ename,
                              String p_job,
                              int    p_mgr,
                              String p_hiredate,
                              long   p_sal,
                              long   p_comm,
                              int    p_deptno) throws Exception {

        String SQLstmt = "insert into target "
                       + "(no, empno, ename, job, mgr, hiredate, sal, comm, deptno) "
                       + "values (?, ?, ?, ?, ?, to_date(?, 'yyyymmdd hh24miss'), ?, ?, ?)";

        PreparedStatement st = con.prepareStatement(SQLstmt);
        st.setLong  (1, p_no);
        st.setLong  (2, p_empno);
        st.setString(3, p_ename);
        st.setString(4, p_job);
        st.setInt   (5, p_mgr);
        st.setString(6, p_hiredate);
        st.setLong  (7, p_sal);
        st.setLong  (8, p_comm);
        st.setInt   (9, p_deptno);
        st.execute();
        st.close();
    }
}

```

29초 -> JAVA로 구현했더니 **218초**나 걸렸다. (건마다 네트워크 왕복)

### One SQL의 중요성

- Insert Into Select 구문으로 수행
```sql
insert into target
    select * from source;
    
/*1000000개의 행이 만들어졌습니다.*/
/*결과: 00:00:01.46*/
```

한번의 Call 로 처리하여 1.46초만에 수행을 마쳤다.
이는 Java 비교 150배 빨라졌으며, 네트워크왕복비용이 없고 절차적으로 수행되는 여러번의 커밋이 아니기 때문이다.
One SQL의 중요성이 바로 여기에 있다. 업무 로직이 복잡하면 절차적으로 처리할 수밖에 없지만, 그렇지 않다면 가급적 One SQL로 구현하려고 노력해야 한다.

>절차적으로 구현된 프로그램을 One SQL로 구현하는 데 매우 유용한 구문 활용법
>- Insert Into Select
>- 수정가능 조인 뷰 - 5항(6.1.5)
>- Merge 문 - 6항(6.1.6)

---

## 6.1.3 Array Processing 활용

> 복잡한 업무 로직을 포함하는 절차적 프로그램을 OneSQL 로 구현하지 않고도 Call 부하를 줄일 수 있는 방법

- 절차적 프로그램을 PL/SQL 에서 Array Processing으로 처리
```sql
declare
    cursor c is select * from source; -- select 결과를 순차적으로 fetch
    type typ_source is table of c%rowtype; -- 커서에서 가져오는 행 구조를 갖는 배열타입 선언
    l_source typ_source; -- 배열타입의 변수 

    l_array_size number default 10000; --한 번에 fetch할 row 개수 (만건씩 bulk fetch)

	-- 인서트 수행하는 서브프로시저
    procedure insert_target( p_source in typ_source ) is 
    begin
        forall i in p_source.first..p_source.last -- 배열을 넘기는 forall
            insert into target values p_source(i); -- bulk insert 수행
    end insert_target;
begin
    open c; -- 커서 Open (source 데이터 읽기위한 준비)
    loop -- bulk fetch (l_source에 만건씩 결과행 넣음)
        fetch c bulk collect into l_source limit l_array_size;

        insert_target( l_source );

        exit when c%notfound;
    end loop;

    close c;

    commit;
end;
/

/*결과: 00:00:03.99*/
```

절차적으로 수행할 때 29.31초 걸리던 PL/SQL 프로그램이 3.99초 만에 수행을 마쳤다.

- JAVA 프로그램에서 Array Processing으로 처리
```java
public class JavaArrayProcessing {
    public void execute() throws Exception {
        int arraySize = 100000;
        long   no[]       = new long[arraySize];
        long   empno[]    = new long[arraySize];
        String ename[]    = new String[arraySize];
        String job[]      = new String[arraySize];
        int    mgr[]      = new int[arraySize];
        String hiredate[] = new String[arraySize];
        long   sal[]      = new long[arraySize];
        long   comm[]     = new long[arraySize];
        int    deptno[]   = new int[arraySize];

        String SQLstmt = "select no, empno, ename, job, mgr"
                       + "     , to_char(hiredate, 'yyyymmdd hh24miss'), sal, comm, deptno"
                       + " from source";
                         
	 PreparedStatement st = con.prepareStatement(SQLstmt);
	st.setFetchSize(arraySize);
	
	ResultSet rs = st.executeQuery();
	
	int i = 0;
	while(rs.next()) {
	    no      [i] = rs.getLong(1);
	    empno   [i] = rs.getLong(2);
	    ename   [i] = rs.getString(3);
	    job     [i] = rs.getString(4);
	    mgr     [i] = rs.getInt(5);
	    hiredate[i] = rs.getString(6);
	    sal     [i] = rs.getLong(7);
	    comm    [i] = rs.getLong(8);
	    deptno  [i] = rs.getInt(9);
	
	    if(++i == arraySize) {   // 10,000번에 한 번씩 insertTarget 실행
	        insertTarget(i, no, empno, ename, job, mgr, hiredate, sal, comm, deptno);
	        i = 0;
	    }
	}
	
	if(i > 0)
	    insertTarget(i, no, empno, ename, job, mgr, hiredate, sal, comm, deptno);
	
	rs.close();
	st.close();
	}
	
	public void insertTarget( int     length,
	                          long    p_no[],
	                          long    p_empno[],
	                          String  p_ename[],
	                          String  p_job[],
	                          int     p_mgr[],
	                          String  p_hiredate[],
	                          long    p_sal[],
	                          long    p_comm[],
	                          int     p_deptno[] ) throws Exception {
	
	    String SQLstmt = "insert into target "
	                   + "(no, empno, ename, job, mgr, hiredate, sal, comm, deptno) "
	                   + "values (?, ?, ?, ?, ?, to_date(?, 'yyyymmdd hh24miss'), ?, ?, ?)";
	
	    PreparedStatement st = con.prepareStatement(SQLstmt);
	
	    for(int i = 0; i < length; i++) {
	        st.setLong  (1, p_no[i]);
	        st.setLong  (2, p_empno[i]);
	        st.setString(3, p_ename[i]);
	        st.setString(4, p_job[i]);
	        st.setInt   (5, p_mgr[i]);
	        st.setString(6, p_hiredate[i]);
	        st.setLong  (7, p_sal[i]);
	        st.setLong  (8, p_comm[i]);
	        st.setInt   (9, p_deptno[i]);
	
	        st.addBatch();   // insert 할 값들을 배열에 저장
	    }
	
	    st.executeBatch();   // 배열에 저장된 값을 한 번에 insert
	    st.close();
	}

//결과 : 11.813초
```

절차적으로 수행할 때 218초 걸리던 JAVA 프로그램이 **11.8초** 만에 수행을 마쳤다.  
만 번에 한 번씩 INSERT 하도록 구현함으로써 백만 번 발생할 User Call을 백 번으로 줄였기 때문에 나타난 성능 향상이다.

한 번과 백 만번의 차이는 크지만, 한 번과 백 번의 차이는 크지 않다.  
단, 방금 확인한 것처럼 Call을 단 하나로 줄이지 못하더라도 Array Processing을 활용해 10~100번 수준으로 줄일 수 있다면 One SQL에 준하는 성능효과를 얻을 수 있다.