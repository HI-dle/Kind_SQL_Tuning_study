## 6.1.4 인덱스 및 제약 해제를 통한 대량 DML 튜닝
앞서 설명했듯 인덱스와 무결성 제약 조건은 DML 성능에 큰 영향을 끼친다.

그렇다고 `온라인 트랜잭션 처리 시스템`에서 이들 기능(`인덱스, 무결성 제약 조건`)을 해제할 순 없다.

`반면, 배치 프로그램에서는 제약을 해제함으로써 큰 성능개선 효과를 얻을 수 있다.`

### SOURCE 테이블에 데이터 1000만건 입력하기
```sql
-- SQL (emp의 10개 행 × 숫자 100만 개 = 1천만 개의 테스트 데이터 생성)
create table source
as
select b.no, a.*
from (select * from emp where rownum <= 10) a,
     (select rownum as no from dual connect by level <= 1000000) b;

-- SQL (target 이라는 데이터가 없는 빈 테이블 생성)
create table target
as
select * from source where 1 = 2;

-- SQL (target 테이블에 (no, empno) 복합 Primary Key 설정 = Unique 인덱스 자동 생성)
alter table target add
constraint target_pk primary key(no, empno);

--SQL (ename 컬럼에 인덱스 생성)
create index target_x1 on target(ename);
```

- source 테이블에 1000만개의 데이터 생성
- target 테이블에 primary key 포함 인덱스 2개 생성

### PK 제약과 인덱스가 있는 상태에서 target 테이블에 데이터 1000만건 입력하기
```sql

SQL> set timing on;
    
SQL> insert /*+ append */ into target
  2 select * from souce;

10000000 개의 행이 만들어졌습니다.

경   과: 00:01:19.10 -- 1분 19초 경과!
SQL> commit;
```

### PK 제약과 인덱스 해제 1 - PK 제약에 Unique 인덱스를 사용한 경우
```sql
--- PK 제약 해제
SQL> truncate table target;

SQL> alter table target modify constraint target_pk disavle drop index;
```

```sql
-- 인덱스 Drop
SQL> alter index target_x1 unusable;
```

- 인덱스가 `Unusable` 상태에서 데이터를 입력하려면 아래와 같이 `skip_unusable_indexes`를 `true`로 설정해야 한다.(기본값이 true라 변경한 적이 없다면 굳이 변경하지 않아도 된다.)
```sql
SQL> alter session set skip_unusable_indexes = true;
```

```sql
SQL> insert /*+ append */ into target
  2  select * from source;

10000000 개의 행이 만들어졌습니다.

경   과: 00:00:05.84 -- 이번에는 5.84초만에 수행 완료
SQL> commit;
```

### (다시 되돌리기) PK 제약 활성화 및 인덱스 재생성
```sql
SQL> alter table target modify constraint target_pk enable NOVALIDATE; 
-- PK를 활성화했으므로 PK 인덱스를 자동으로 생성된다.

경   과: 00:00:06.77
SQL> alter index target_x1 rebuild;

경   과: 00:00:08.26
```

- `NOVALIDATE` 옵션: 기입력된 데이터에 무결성 체크를 생략하도록 하는 옵션
- 데이터 무결성에 확신이 없다면, 데이터를 입력하기 전에 아래 쿼리로 확인해야 한다.

```sql
SQL> -- (no, empno)는 중복 없이 1번씩만 존재해야 정상 = 무결성
select no, empno, count(*)
from source
group by no, empno
having count(*) > 1;
```

### PK 제약과 인덱스 해제 2 - PK 제약에 Non-Unique 인덱스를 사용한 경우
위 테스트를 진행할 때는 일반 인덱스는 unusable 상태로 변경했었고, PK 인덱스는 아예 Drop 해버렸다.

PK 인덱스는 unusable 상태에서 데이터를 입력할 수 없기 때문이다.

```sql
SQL> 
alter index target_pk unusable;

SQL>
insert into target
select * from source;

-- PK 인덱스는 Unusable 상태에서 위 실행결과에 대해 오류를 발생시킨다.
1행에 오류:

ORA-01502: index 'TARGET_PK' or partition of such index is in unusable state

SQL> 
insert /*+ append */ into target
select * from source;

1행에 오류:
ORA-26026 : unique index TARGET_PK initially in unusable state
```
- PK 제약 = UNIQUE 보장
- INSERT 시 Oracle은 PK 중복 검사를 반드시 해야 함
- 그런데 그 검사를 담당하는 PK 인덱스가 unusable이라서 검증이 불가하기 때문에 Insert를 거부한다.

### PK 인덱스를 Drop 하지 않고 Unusable 상태에서 데이터를 입력하고 싶다면, 아래와 같이 PK 제약에 Non-Unique 인덱스를 사용하면 된다.
```sql
SQL> set timing off;
SQL> truncate table terget;

SQL> alter table target drop primary key drop index;
-- 여기까지는 단순히 table이랑 pk를 깨끗이 해주는 작업

SQL> create index target_pk on target(no, empno); -- Non-Unique 인덱스 생성

SQL> alter table target add
    constraint target_pk primary key (no, empno);
    using index target_pk; -- PK 제약에 Non-Unique 인덱스를 사용하도록 지정
```

### PK 제약 비활성화하고, 인덱스를 Unusable 상태로 변경하기
```sql
SQL> alter table target modify constraint target_pk disable keep index;
-- pk 제약은 끄되, 인덱스는 그대로 두겠다.

SQL> alter index target_pk unusable;
           
SQL> alter index target_x1 unusable;
```

이제 아래와 같이 대량 INSERT 작업을 진행해도 아무런 문제가 없다.
```sql
SQL> set timing on;
SQL> insert /*+ append */ into target
    select * from source;

10000000 개의 행이 만들어졌습니다.

경   과: 00:00:05.53
SQL> commit;

경   과: 00:00:00.00
```
아래는 작업을 마친 후, 인덱스를 재생성하고 PK 제약을 다시 활성화
```sql
SQL> alter index target_x1 rebuild;
           
경   과: 00:00:07.24
SQL> alter index target_pk rebuild;
           
경   과: 00:00:05.27
SQL> alter table target modify constraint target_pk enable novalidate;

경   과: 00:00:00.06
```

데이터 입력 시간(약 6초) + 제약 활성화 및 인덱스 재생성 시간(약 12초)를 합쳐도 기존(1분 19초)보다 훨씬 더 빨리 마쳤다.

## 6.15 수정가능 조인 뷰

### 전통적인 방식의 UPDATE
튜닝을 하다보면 아래와 같은 UPDATE 문을 종종 볼 수 있다.
```sql
update 고객 c
set 최종거래일시 = (select max(거래일시) from 거래
                 where 고객번호 = c.고객번호
                 and 거래일시 >= trunc(add_months(sysdate, -1)))
  , 최근거래횟수 = (select count(*) from 거래
                 where 고객번호 = c.고객번호
                 and 거래일시 >= trunc(add_months(sysdate, -1)))
  , 최근거래금액 = (select sum(거래금액) from 거래
                 where 고객번호 <= c.고객번호
                 and 거래일시 >= trunc(add_mouths(sysdate, -1)))
where exists (select 'x' from 거래
              where 고객번호 = c.고객번호
              and 거래일시 >= trunc(add_months(sysdate, -1)))

-- select 문이 총 4개로 '거래' 데이터를 4번 조회하는 것을 확인할 수 있다.
```
위 UPDATE 문은 아래와 같이 고칠 수 있다.
```sql
update 고객 c
set (최종거래일시, 최근거래횟수, 최근거래금액) = 
    (select max(거래일시), count(*), sum(거래금액)
    from 거래
    where 고객번호 = c.고객번호
    and 거래일시 >= trunc(add_months(sysdate, -1)))
where exists (select 'x' from 거래
              where 고객번호 = c.고객번호
              and 거래일시 >= trunc(add_months(sysdate, -1)))
```

위 방식에도 아직 비효율이 사라진 것은 아니다. 아직도 `한 달 이내 고객별 거래 데이터를 두 번 조회`하기 때문이다.

두가지 경우로 성능을 더 개선할 수 있다.
- 총 고객 수가 많은 경우
- 한 달 이내 거래 고객 수가 많은 경우(= update 발생량이 많은 경우)

```sql
-- 1. 총 고객 수가 많은 경우(exists 문에 해시 세미 조인으로 유도)
update 고객 c
set (최종거래일시, 최근거래횟수, 최근거래금액) =
    (select max(거래일시), count(*), sum(거래금액)
     from 거래
     where 고객번호 = c.고객번호
     and 거래일시 >= trunc(add_months(sysdate, -1)))
where exists (select /*+ unnest hash_sj */ 'x' from 거래
              where 고객번호 = c.고객번호
              and 거래일시 >= trunc(add_months(sysdate, -1)))

-- 2, 한 달 이내 거래를 발생시킨 고객이 많은 경우
update 고객 c
set (최종거래일시, 최근거래횟수, 최근거래금액) =
    (select nvl(max(거래일시), c.최종거래일시)
          , decode(count(*), 0, c.최근거래횟수, count(*))
          , nvl(sum(거래금액), c.최근거래금액)
     from 거래
     where 고객번호 = c.고객번호
     and 거래일시 >= trunc(add_months(sysdate, -1)))
---- 하지만 모든 고객 레코드에 Lock이 걸리는 것은 물론, 
---- 이전과 같은 값으로 갱신되는 비중이 높을수록 Redo 로그 발생량이 증가해 오히려 비효율적일 수 있다.
```
이처럼 다른 테이블과 조인이 필요할 때 전통적인 UPDATE 문을 사용하면 비효율을 완전히 해소할 수 없다.

### 수정가능 조인 뷰
아래와 같이 `수정가능 조인 뷰`를 활용하면 참조 테이블과 두 번 조인하는 비효율을 없앨 수 있다.
```sql
update
( select /*+ ordered use_hash(c) no_merge(t) */
        c.최종거래일시, c.최근거래횟수, c.최근거래금액
        t.거래일시, t.거래일수, t.거래금액
from (select 고객번호
           , max(거래일시) 거래일시, count(*) 거래횟수, sum(거래금액) 거래금액
      from 거래
      where 거래일시 >= trunc(add_months(sysdate, -1))
      group by 고객번호) t
      , 고객 c
where c.고객번호 = t.고객번호
)
set 최종거래일시 = 거래일시
  , 최근거래횟수 = 거래횟수
  , 최근거래금액 = 거래금액
```
- `조인 뷰`: FROM 절에 두 개 이상 테이블을 가진 뷰
- `수정가능 조인 뷰`: 말 그대로 입력, 수정, 삭제가 허용되는 조인 뷰
  - 단, 1쪽 집합과 조인하는 M쪽 집합에만 입력, 수정, 삭제가 허용된다.(1:N 관계에서 N쪽 집합만 허용된다.)

#### 아래와 같이 생성한 조인 뷰를 통해 job = 'CLERK'인 레코드의 loc를 모두 'SEOUL'로 변경하는 것을 '허용한다면'?
```sql
CREATE TABLE EMP AS SELECT * FROM SCOTT.EMP;
CREATE TABLE DEPT AS SELECT * FROM SCOTT.DEPT;
-- 예제 테이블을 생성하기 위한 기존 테이블 복사

CREATE OR REPLACE VIEW EMP_DEPT_VIEW AS
SELECT E.ROWID EMP_RID, E.*, D.ROWID DEPT_RID, D.DNAME, D.LOC
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO;
-- 조인 뷰 생성: EMP(M) + DEPT(1) 조인

UPDATE EMP_DEPT_VIEW set LOC = 'SEOUL' WHERE JOB = 'CLERK';
-- 위 update 문(DEPT(1)의 Location)을 수행한다면?
```

- 만약 직업이 CLERK인 사원이 10, 20, 30 부서 모두에 속해있다면, 세 개의 부서 모두 location이 서울로 바뀌게 된다.
- 이는 원하던 결과가 아닐 것이다.
- 따라서, `ORA-01779: cannot modify a column which maps to a non key-preserved table` 와 같은 오류가 발생한다.

#### 그렇다면 아래 update 문은 어떨까?
```sql
UPDATE EMP_DEPT_VIEW SET COMM = NVL(COMM, 0) + (SAL * 0.1) WHERE SAL <= 1500;
-- M쪽 집합의 컬럼을 수정하므로 문제가 없어보인다.
```

하지만, 실제 수행해보면 동일한 에러가 발생한다.
- 옵티마이저가 지금 어느 테이블이 1쪽 집합인지 알 수 없기 때문에 발생하는 에러다.
- 지금 상태에서는 `DELETE, INSERT`도 허용하지 않는다.
- `1쪽 집합에 PK 제약을 설정`하거나 `UNIQUE 인덱스를 생성`해야 수정가능 조인 뷰를 통한 입력, 수정, 삭제가 가능하다.
  - PK 제약을 설정하면, EMP 테이블은 `키-보존 테이블(key-preserved Table)`이 되고, DEPT 테이블은 `비 키-보존 테이블(Non-key ~)`로 남는다.

> non key-preserved 란?
> 
> 조인 때문에 한 베이스 테이블 행이 뷰에서 여러 번 나타날 수 있는 상태