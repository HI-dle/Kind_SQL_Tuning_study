# DML 튜닝

--- 

### 순환 옵션을 가진 시퀀스 활용

- PK가 복합컬럼인데 동시에 트랜잭션이 높아 시퀀스가 꼭 필요하다면 순환 옵션을 가진 시퀀스 활용을 고려할 수 있다. 하루에 도저히 도달할 수 없는 값으로 최대 값을 설정하고 그 값에 도달하면 1부터 다시 시작하도록 순환옵션을 설정하는 것이다. 순환옵션을 사용하는 이유는 값이 무한정 커지지 않게 함으로써 순번 컬럼 길이를 최소화하기 위해서다. 일반적으로 권장한 솔루션은 아니지만 채번 성능이 문제가 될 때 고려해 볼 수 있다.

- 시퀀스의 다른 단점은 신규 데이터를 입력하는 과정에 결번이 생길 수 있다는 점이다. 원인은 크게 2가지다.
  - 첫째, 시퀀스 채번 이후 트랜잭션을 롤백하는 경우
  - 둘째, CACHE 옵션을 설정한 시퀀스가 캐시에서 밀려나는 경우다.
    - 자주 사용하지 않아 캐시에서 밀려나거나 인스턴스를 재기동하는 순간 캐시돼 있던 번호는 모두 사라지고 디스크에서 다시 읽을때 그다음 번호부터 읽는다.
  - 인스턴스 재기동에 의한 결번은 피할 방법이 없지만 사용 빈도가 낮아 생기는 결번은 방법이 있다. 시퀀스를 Shared Pool에 KEEP 하도록 명령어를 실행해주면 된다.

```oracle-sql
SQL> EXEC SYS.DBMS_SHARED_POOL.KEEP('SCOTT.MY_SEQ', 'Q');
```

- 일련번호에 결번이 생기는 현상을 막을 필요가 있지는 않다. 해당 경우도 많지 않고 그리고 채번 테이블이나 MAX + 1 방식을 사용하더라도 결번을 원천적으로 막을 수는 없다. 데이터를 삭제하며 생기는 결번은 막을 수 없기 때문이다.

```oracle-sql
insert into 상품거래(거래일련번호, 계좌번호, 거래일시, 상품코드, 거래가격, 거래수량)
values ( (select max(거래일련번호) + 1 from 상품거래)
        , :acnt_no, sysdate, :prod_cd, :trd_price, :trd_qty );
```

- 해당 쿼리로 테이블의 최종 일련 번호를 조회하고 거기에 1을 더해 INSERT 하는 방식이다.
- 이 방식의 정점은 시원스 또는 별도의 채번 테이블을 관리하는 부담이 없다.
- 동시 트랜잭션에 의한 충돌이 많지 않으면 성능이 빠르다.
- PK가 복잡한 컬럼인 경우 구분 속성별 순번을 채번할 떄도 사용할 수 있다.
- 채번 테이블은 구분 속성 값의 수가 적을 때만 사용할 수 있지만 이 방식은 값의 수가 아무리 많아도 상관없다. 오히려 값의 수가 많을수록 성능이 좋다. 입력 값 중복에 의한 로우 LOCK 경합이 줄고 재실행 횟수도 줄기 때문이다.


- 단점으로는 레코드 중복에 대비한 세밀한 예외처리가 필요하다.
- 다중 트랜잭션에 의한 동시 채번이 심하면 시퀀스보다 성능이 나빠질 수 있다. 레코드 중복에 의한 로우 LOCK 경합 때문이다. 로우 LOCK은 선행 트랜잭션이 커밋 또는 롤백할 떄까지 지속된다. 선행 트랜잭션이 롤백하지 않는 한 INSERT는 결국실패하게 되므로 채번과 INSERT를 다시 실행해야 한다. 이런 현상이 자주 발생하면 성능이 느릴수 밖에 없다.
- 다행히 OK가 복합 컬럼이고 구분 속성별 값의 수가 많으면 구분 속성 값별로 채번이 분산된다. 따라서 동시 채번이 많아도 로우 LOCK 경합 및 재실행 가능성은 현저히 줄어든다. 로우 LOCK 경합 이외의 성능 이슈는 MAX 값 조회에 최적화된 인덱스를 구성해 주지 않을 떄 생긴다.

## Oracle 채번 방식별 LOCK 경합 요소

| 채번 방식 | LOCK 발생 지점 | LOCK 유형 | 경합 발생 원인 | 동시 트랜잭션 증가 시 영향 | Oracle 관점 평가 |
|----------|---------------|-----------|---------------|--------------------------|------------------|
| SEQUENCE (CACHE) | Sequence 객체 | Latch / Mutex | 캐시된 번호 소진 시 메모리 접근 | 경합 거의 없음 | 가장 권장 |
| SEQUENCE (NOCACHE) | Sequence 객체 | Latch | 매 호출마다 디스크 접근 | 고TPS 환경에서 성능 저하 | 비권장 |
| SEQUENCE (ORDER) | Sequence 객체 | Global Serialization | RAC 환경 순서 보장 | RAC에서 심각한 병목 | 단일 인스턴스만 권장 |
| 채번 전용 테이블 | 채번 테이블 ROW | Row Lock | UPDATE + COMMIT 경쟁 | 단일 ROW 병목 | 고트래픽 비권장 |
| MAX + 1 방식 | 대상 테이블 ROW | Row Lock | 중복 PK INSERT 충돌 | 재시도 증가 | 조건부 허용 |
| MAX + 1 + 인덱스 | 대상 테이블 인덱스 | Index + Row Lock | 동일 MAX 범위 경쟁 | 인덱스 설계에 따라 완화 | PK 분산 시 유리 |
| 트리거 + 시퀀스 | 시퀀스 객체 | Latch | 내부적으로 sequence 호출 | 직접 호출과 동일 | 구조 복잡 |
| 복합 PK + 그룹별 MAX + 1 | 일부 ROW | Row Lock | 그룹 단위 충돌 | 값 분산 시 경합 감소 | 실무에서 자주 사용 |



- LOCK 경합 요소를 고려한 채번 방식 선택 기준을 정리하면 다음과 같다.

    1. 다중 트랜잭션에 의한 동시 채번이 많지 않으면 세 가지 방식 중 어느 것을 사용해도 크게 상관은 없다. 하지만 채번 테이블이나 시퀀스 오브젝트 관리 부담을 고려한다면 가급적 MAX + 1 방식을 선택하는 것이 좋다.
    2. 다중 트랜잭션에 의한 동시 채번이 많고 PK가 단일컬럼 일련번호라면 기퀀스 방식이 가장 좋다.
    3. 다중 트랜잭션에 의한 동시 채번이 많고 PK 구분 속성에 값 종류 개수가 많으면 중복에 의한 로우 LOCK 경합 및 재실행 가능성이 낮다. 그렇다면 시퀀스보다 MAX + 1 방식이 구조적으로 좋다.
    4. 다중 트랜잭션에 의한 동시 채번이 많고 PK 구분 속성에 값 종류 개수가 적으면 MAX + 1 방식은 성능에 문제가 생길 수 있다. 그럴 때 순환 옵션을 가진 시퀀스 오브젝트 활용을 고려할 수 있다.

![그림_6_32.png](image%2F%EA%B7%B8%EB%A6%BC_6_32.png)


### 12c 시퀀스 신기능


- 오라클 12.1 버전에서 시퀀스 관련 신기능이 많이 도입되었다.

- (1) 컬럼 기본값으로 시퀀스 지정
  - 우선 아래와 같이 컬럼 기본 값으로 시퀀스를 지정할 수 있게 되었다.

```oracle-sql
create sequence my_seq;

create table t (
 c1 number default my_seq.nextval not null
 , c2 varchar2(5));
```

 - 기본값을 지정한 C1 컬럼에 값을 직접 입력할 수 있지만, 입려갛지 않을 수도 있다. 값을 입력하지 않으면 오라클이 대신 시퀀스 nextval을 호출해서 값을 입력한다.

```oracle-sql
insert into t (c1,c2) values (my_seq.nextval, 'X');
insert into t (c2) values ('X');

```

- (2) IDENTITY 컬럼
- 12.1 버전부터 특정 컬럼을 IDENTITY 컬럼으로 지정할 수 있다.

```oracle-sql
create table t (c1 number generated always as identity, c2 varchar2(5));

insert into t (c2) values ('X');
insert into t (c1,c2) values (default, 'X');
```

 - GENERATED ALWAYS 옵션을 지정한 컬럼에 아래와 같이 값을 직접 입력하려고 하면 ORA-32792 에러가 발생한다.

```oracle-sql
insert into t (c1, c2) values (3,'X');
```

- 기본적으로 시스템이 값을 입력하지만 사용자가 직업 값을 입력할 수도 있으려면 아래와 같이 GENERATED BY DEFAULT 옵션을 지정하면 된다.

```oracle-sql
create table t (c1 number generated always as identity, c2 varchar2(5));
```


- (3) 세션 시퀀스
- 글로벌 시퀀스는 여러 세션이 공유할 수 있는 시스템 레벨 시퀀스로 아래와 같이 생성한다. GLOBAL 키워드는 생략이 가능하다.

```oracle-sql
create sequence g_seq GLOBAL;
```

- 세션 시퀀스는 여러 세션이 공유할 수 없는 세션 레벨 시퀀스로 아래와 같이 생성한다.

```oracle-sql
create sequence s_seq SESSION;
```


- 세션 시퀀스는 세션이 종료되면 초기화된다. 즉, 세션 내에서만 유효하다. LOCK 메커니즘이 불필요하므로 당연히 글로벌 시퀀스보다 성능이 좋다. 그렇다고 세션 시퀀스가 기대존에 사용하던 시퀀스를 모두 대체할 수는 없다. 기능이 다르므로 용도에 맞게 선택하면 된다.
- 예시로 스테이징 테이블에 데이터를 적재하는 경우를 생각해 보자. 이떄는 시퀀스를 여러 세션이 호출하지 않기 때문에 굳이 글로벌 시퀀스를 사용할 이유가 없다. 게다가 스테이징 테이블은 데이터를 새로 적재하기 전에 Truncate 한다. 기존 마지막 값에 이어서 값을 채번할 필요가 없으므로 성능이 더 빠른 세션 시퀀스가 유용하다.


