## 6.2.3 병렬 DML
- `병렬 쿼리`와 `병렬 DDL`은 기본적으로 활성화되어있다.
- 반면에, `병렬 DML`은 기본적으로 비활성화되어있다.

따라서 DML을 병렬로 처리하려면, 아래와 같이 `병렬 DML`을 활성화해야한다.
```sql
alter session enable parallel dml;
```

그 후 힌트를 사용한다.

- 힌트를 사용하면 대상 레코드를 찾는 작업(`INSERT는 SELECT 쿼리` / `UPDATE, DELETE는 조건절 검색`)은 물론 데이터 추가/변경/삭제도 병렬로 진행한다.
```sql
insert /*+ parallel(c 4) */ into 고객 c 
select /*+ full(o) parallel(o 4) */ * from 외부가입고객 o; -- insert 할 대량 데이터 집합을 만들어내는 작업

update /*+ full(c) parallel(c 4) */ 고객 c set 고객상태코드 = 'WD'
where 최종거래일시 < '20100101';

delete /*+ full(c) parallel(c 4) */ from 고객 c
where 탈퇴일시 < '20100101';
```

### 힌트를 제대로 기술했으나, 실수로 병렬 DML을 활성화하지 않으면 어떻게 될까?
- 대상 레코드를 찾는 직업은 병렬로 진행하지만, 추가/변경/삭제는 QC가 혼자 담당하므로 병목이 생긴다.
- `QC`: Query Coordinator의 줄임말로 `SQL을 시작한 사용자 세션`.
- `PX서버`: QC가 띄운 병렬 워커들

```sql
-- 병렬 DML을 활성화한 경우
[PX1] row 찾기 + insert/update/delete
[PX2] row 찾기 + insert/update/delete
[PX3] row 찾기 + insert/update/delete
[PX4] row 찾기 + insert/update/delete

-- 병렬 DML을 활성화하지 않은 경우
[PX1] 대상 row 검색
[PX2] 대상 row 검색
[PX3] 대상 row 검색
[PX4] 대상 row 검색

위 결과를 QC에게 전달하면 [QC] 혼자 DML 수행 -- 따라서 병목 발생!
```

### 오라클은 DML 문에 두 단계 전략을 사용한다.
- `Consistent 모드`로 대상 레코드를 찾는다.
- `Current 모드`로 추가/변경/삭제한다.

> 🤔 부연 설명(최진영 + gpt 피셜)
> 
> 위에서 대상 데이터를 찾을 때, insert는 select 쿼리, update/delete에서는 조건절 쿼리가 동반된다고 했다.
> 
> DML의 두 단계 중, 레코드를 찾을 떄의 Consistent 모드는 우리가 배운 트랜잭션 격리 레벨의 Read committed 정도로 생각하면 될 듯 하다.
> 
> 추가/변경/삭제 시의 Current 모드는 말 그대로 실제 변경 시점에는 최신 블록을 읽고 수행한다는 의미인듯 하다.

### 병렬 INSERT는 append 힌트를 지정하지 않아도 Direct Path Insert 방식을 사용한다.
- 하지만 `병렬 DML이 작동하지 않을 경우를 대비해 아래와 같이 append 힌트를 같이 사용하는게 좋다.`
- 혹시라도 `병렬 DML`이 작동하지 않더라도 `QC가 Direct Path Insert를 사용`하면 어느 정도 만족할 만한 성능을 낼 수 있기 때문이다.
```sql
insert /*+ append parallel(c 4) */ into 고객 c
select /*+ full(o) parallel(o 4) */ * from 외부가입고객 o;
```

12c 부터는 아래와 같이 `enable_parallel_dml` 힌트도 지원한다.
```sql
insert /*+ enable_parallel_dml parallel(c 4) */ into 고객 c
select /*+ full(o) parallel(o 4) */ * from 외부가입고객 o;

update /*+ enable_parallel_dml full(c) parallel(c 4) */ 고객 c
set 고객상태코드 = 'WD'
where 최종거래일시 < '20100101';

delete /*+ enable_parallel_dml full(c) parallel(c 4) */ from 고객 c
where 탈퇴일시 < '20100101';
```

> 병렬 DML을 사용하면 테이블에 `Exclusive 모드 TM Lock`이 걸린다는 사실을 기억하자. 트랜잭션이 빈번한 주간에 이 옵션을 사용하는 것은 금물이다!

### 병렬 DML이 잘 작동하는지 확인하는 방법
- DML 작업을 `각 병렬 프로세스가 처리하는지`, 아니면 `QC가 처리하는지`를 실행계획에서 확인

```sql
-- UPDATE가 PX COORDINATOR 아래쪽에 나타나면 각 병렬 프로세스가 처리
------------------------------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation             | Name     | Starts | E-Rows |E-Bytes| Cost (%CPU)| E-Time   |    TQ  |IN-OUT| PQ Distrib |
------------------------------------------------------------------------------------------------------------------------------------------------------------------
|   0 | UPDATE STATEMENT      |          |    1   |        |       |     2 (100)|          |        |      |            |
|   1 |  PX COORDINATOR       |          |    1   |        |       |            |          |        |      |            |
|   2 |   PX SEND QC (RANDOM) | :TQ10000 |    0   |    14  |    56 |     2   (0)| 00:00:01 |  Q1,00 | P->S | QC (RAND)  |
|   3 |    UPDATE             | E2       |    0   |        |       |            |          |  Q1,00 | PCWP |            |
|   4 |     PX BLOCK ITERATOR |          |    0   |    14  |    56 |     2   (0)| 00:00:01 |  Q1,00 | PCWC |            |
|*  5 |      TABLE ACCESS FULL| E2       |    0   |    14  |    56 |     2   (0)| 00:00:01 |  Q1,00 | PCWP |            |
------------------------------------------------------------------------------------------------------------------------------------------------------------------
```

```sql
-- UPDATE가 PX COORDINATOR 위쪽에 나타나면 QC가 처리
------------------------------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation             | Name     | Starts | E-Rows |E-Bytes| Cost (%CPU)| E-Time   |    TQ  |IN-OUT| PQ Distrib   |
------------------------------------------------------------------------------------------------------------------------------------------------------------------
|   0 | UPDATE STATEMENT      |          |    1   |        |       |     3 (100)|          |        |      |              |
|   1 |  UPDATE               | E2       |    1   |        |       |            |          |        |      |              |
|   2 |   PX COORDINATOR      |          |    1   |        |       |            |          |        |      |              |
|   3 |    PX SEND QC (RANDOM)| :TQ10000 |    0   |    14  |    56 |     3   (0)| 00:00:01 |  Q1,00 | P->S | QC (RAND)    |
|   4 |     PX BLOCK ITERATOR |          |    0   |    14  |    56 |     3   (0)| 00:00:01 |  Q1,00 | PCWC |              |
|*  5 |      TABLE ACCESS FULL| E2       |    0   |    14  |    56 |     3   (0)| 00:00:01 |  Q1,00 | PCWP |              |
------------------------------------------------------------------------------------------------------------------------------------------------------------------
```

---
## 6.3 파티션을 활용한 DML 튜닝
파티션을 이용하면 대량 추가/변경/삭제 작업을 빠르게 처리할 수 있다.

## 6.3.1 테이블 파티션
`파티셔닝(Partitioning)`: 테이블 또는 인덱스 데이터를 특정 컬럼(파티션 키) 값에 따라 별도 세그먼트에 나눠서 저장하는 것

![그림_6_10.png](image%2F%EA%B7%B8%EB%A6%BC_6_10.png)

> 계절별로 옷을 관리하면 외출할 때 필요한 옷을 쉽고 빠르게 찾을 수 있다.
>
> 데이터도 월별, 분기별, 반기별, 연별로 분할해서 저장하면 빠르게 조회할 수 있으며 관리하기도 쉽다.
> 
> 일반적으로 시계열에 따라 Range 방식으로 분할하지만, 그 외 다른 기준(리스트, 해시)으로 분할할 수도 있다.

### 파티션이 필요한 이유
- `관리적 측면`: 파티션 단위 백업, 추가, 삭제, 변경 -> 가용성 향상
- `성능적 측면`: 파티션 단위 조회 및 DML, 경합 또는 부하 분산
---
### 파티션 종류
파티션에는 `Range`, `해시`, `리스트` 세 종류가 있다.

### Range 파티션
- 오라클 8 버전부터 제공된 가장 기초적인 방식
- 주로 날짜 컬럼을 기준으로 파티셔닝한다.

```sql
-- 주문 테이블을 주문일자 기준으로 분기별 Range 파티셔닝 예시
CREATE TABLE 주문(
주문번호 NUMBER
, 주문일자 VARCHAR2(8)
, 고객ID VARCHAR2(5)
, 배송일자 VARCHAR2(8)
, 주문금액 NUMBER
, -- . . .
)
    PARTITION BY RANGE(주문일자) (
          PARTITION P2017_Q1 VALUES LESS THAN(‘20170401’)
        , PARTITION P2017_Q2 VALUES LESS THAN(‘20170701’)
        , PARTITION P2017_Q3 VALUES LESS THAN(‘20171001’)
        , PARTITION P2017_Q4 VALUES LESS THAN(‘20180101’)
        , PARTITION P2018_Q1 VALUES LESS THAN(‘20180401’)
        , PARTITION P9999_MX VALUES LESS THAN(MAXVALUE) -> 주문일자 >= ‘20180401’
);
```

그림은 아래와 같다.

![그림_6_11.png](image%2F%EA%B7%B8%EB%A6%BC_6_11.png)

#### 장점
- 파티션 키 값에 따라 분할 저장이 가능하다.
- 조회 시에도 검색 조건을 만족하는 파티션만 골라 읽을 수 있어 이력성 데이터를 Full Scan 방식으로 조회할 때 성능을 크게 향상한다.
- 보관주기 정책에 따라 과거 데이터를 백업/삭제 측면에서 효율적이고 빠르게 관리할 수 있다.

### 파티션 테이블에 대한 SQL 성능 향상 원리
원리는 `파티션 Pruning(= Elimination)`에 있다.
> prune은 '쓸데없는 가지를 치다' 라는 뜻을 가진다.
> 
> 따라서 `파티션 Pruning`은 'SQL 하드파싱이나 실행 시점에 조건절을 분석해서 읽지 않아도 되는 파티션 세그먼트를 액세스 대상에서 제외하는 기능'이다.

```sql
select *
from 주문
where 주문일자 >= '20120401'
and 주문일자 <= '20120630'

-- 조회 결과 300만 건
```

- 왼쪽: 300만 건 정도의 데이터를 인덱스로 건건이 랜덤 액세스하면 테이블 전체를 스캔하는 것보다 오히려 성능이 느리다.
- 오른쪽: Full Scan 하더라도 전체가 아닌 일부 파티션 세그먼트만 읽고 멈출 수 있다.
  - 병렬 처리가 만나면 그 효과는 배가된다.
![그림_6_12.png](image%2F%EA%B7%B8%EB%A6%BC_6_12.png)

> 참고로 오른쪽의 파티션 테이블도 인덱스로 액세스할 수 있지만, 파티션 Pruning을 이용한 테이블 스캔보다 훨씬 느리다.

파티션도 클러스터, IOT와 마찬가지로 관련 있는 데이터가 물리적으로 연결되어 있도록 저장하는 클러스터링 기술에 속한다.

클러스터와 다른 점은 세그먼트 단위로 모아서 저장한다는 점이다.

> 클러스터: 데이터를 블록 단위로 모아 저장
> 
> IOT: 데이터를 정렬한 순서로 저장하는 구조