# SQL 처리 과정과 I/O

## 1.1 SQL 파싱과 최적화
- 옵티마이저가 SQL을 어떻게 처리하는가
- 서버 프로세스는 데이터를 어떻게 읽고 저장하는가

### 1.1.1 구조적 집합적, 선언적 질의 언어
아래 두 테이블을 부서번호(`DEPTNO`)로 조인해서 사원명(`ENAME`) 순으로 정렬해야한다면?

![image_1-1.png](image%2Fimage_1-1.png)

요즘에는 아래 처럼 SQL로 간단히 처리가 가능하다. 하지만 예전에는 직접 로직을 프로그래밍해야만 했다.

```sql

SELECT E.EMPNO, E.ENAME, E.JOB, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
ORDER BY E.ENAME
```

#### SQL
- `Structured Query Language`의 줄임말
  - 말 그대로 `구조적 질의 언어`
  - (위키피디아)
    - 관계형 데이터베이스 관리 시스템(RDBMS)의 데이터를 관리하기 위해 설계한 특수 목적의 프로그래밍 언어이다.
    - SQL은 집합 기반의 선언적 질의 언어이지, C나 BASIC 같은 명령형 언어가 아니다.

#### SQL 옵티마이저
- `SQL`은 기본적으로 구조적(`structured`)이고 집합적(`set-based`)이고 선언적(`declarative`)인 언어이다.
- 원하는 결과 집합을 구조적, 집합적으로 선언하지만 그 `결과 집합을 만드는 과정은 절차적일 수밖에 없다.`
- 즉, 프로시저가 필요한데, 그런 프로시저를 만들어 내는 DBMS 내부 엔진이 `SQL 옵티마이저이다.`

![image_1-2.png](image%2Fimage_1-2.png)

> 따라서 옵티마이저가 예전처럼 로직을 직접 프로그래밍하는 것을 대신해 주는 셈이다.

---
### 1.1.2 SQL 최적화
`DBMS 내부에서 프로시저를 작성하고 컴파일해서 실행 가능한 상태로 만드는 전 과정`을 말한다.

#### 최적화 과정
- SQL 파싱
  - 사용자로부터 SQL을 전달받으면 가장 먼저 SQL 파서(parser)가 파싱을 진행
    - `파싱 트리 생성`: SQL 문을 이루는 개별 구성요소를 분석해서 파싱 트리 생성
    - `Syntax 체크`: 문법적 오류 확인
      - 사용할 수 없는 키워드 사용, 올바르지 않은 순서, 누락된 키워드 확인
    - `Semantic 체크`: 의미상 오류가 없는지 확인
      - 존재하지 않는 테이블 또는 컬럼을 사용했는지 확인
      - 사용한 오브젝트에 대한 권한이 있는지 확인
- SQL 최적화
  - 옵티마이저가 진행
  - 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 `다양한 실행경로를 생성해서 비교한 후 가장 효율적인 하나를 선택`
  - `데이터베이스 성능을 결정하는 가장 핵심적인 엔진`
- 로우 소스 생성
  - 로우 소스 생성기가 진행
  - 옵티마이저가 선택한 실행결로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅

---
### 1.1.3 SQL 옵티마이저
- 사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 액세스 경로를 선택해 주는 DBMS의 핵심 엔진

#### 옵티마이저 최적화 단계
- 사용자로부터 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 찾아낸다.
- 데이터 딕셔너리에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상비용을 산정한다.
- 최저 비용을 나타내는 실행계획을 선택

![image_1-3.png](image%2Fimage_1-3.png)

> 옵티마이저는 프로세스가 아니다!
> 
> 옵티마이저는 별도 프로세스가 아니라 서버 프로세스가 가진 기능(Funtion)일 뿐이다. (SQL 파서와 로우 소스 생성기 또한 마찬가지)

---
### 1.1.4 실행계획과 비용
> SQL 옵티마이저는 자동차 내비게이션가 여러모로 흡사하다.
> 
> e.g) 경로 요약이나 모의 주행 등
>
> 경로를 검색하고 나서 미리 확인하는 기능이며, 내비게이션이 선택한 경로가 마음에 들지 않으면 
> 검색모드를 변경하거나 경유지를 추가해서 운전자가 원하는 경로로 바꿀 수 있다.
> 
> DBMS 또한 `'SQL 실행경로 미리보기'` 기능이 존재한다. ==> `실행 계획(Execution Plan)`

```sql
// 아래와 같이 사용자가 처리절차를 확인할 수 있게 트리 구조로 표현한 것이 '실행계획'
Execution Plan
-------------------------------------------------
0 SELECT STATEMENT Optimizer=ALL_ROWS (COST=209 Card=5 Bytes=175)
1 0 TABLE ACCESS (BY INDEX ROWID) OF 'EMP' (COST=2 Card=5 Bytes=85)
2 1  NESTED LOOPS (Cost=209 Card=5 Bytes=175)
3 2   TABLE ACCESS (BY INDEX ROWID) OF 'DEPT' (Cost=207 Card=1 Bytes=18)
4 3    INDEX (RANGE SCAN) OF 'DEPT_LOC_IDX' (NON_UNIQUE) (Cost=7 Card=1)
5 2   INDEX (RANGE SCAN) OF 'EMP_DEPTNO_IDX' (NON-UNIQUE) (Cost=1 Card=5)
```

- 미리보기 기능을 통해 사용자가 작성한 SQL에 대해 확인 가능
  - 테이블을 스캔하는지
  - 인덱스를 스캔하는지
    - 스캔한다면 어떤 인덱스인지
  - 예상과 다른 방식으로 처리되는지
    - 다른 방식으로 처리된다면 실행경로를 변경할 수 있다.

#### 옵티마이저가 특정 실행계획을 선택하는 근거는 무엇일까?
- 아래는 이를 설명하기 위한 테스트용 테이블을 생성하는 SQL
```markdown
SQL> create t
 2   as
 3   select d.no, e.*
 4   from   scott.emp e
 5       , (select rownum no from dual connect by level <= 1000) d;
```

- 인덱스도 생성
```markdown
SQL> create index t_x01 on t(deptno, no);
SQL> create index t_x02 on t(deptno, job, no);
```

- 생성했던 T 테이블에 통계정보를 수집하는 명령어
```markdown
SQL> exec dbms_stats.gather_table_stats( user, 't');
```

- 아래와 같이 AutoTrace를 활성화하고 SQL을 실행하면 실행계획을 확인할 수 있다.
![실행계획1.png](image%2F%EC%8B%A4%ED%96%89%EA%B3%84%ED%9A%8D1.png)

- `T_X01, T_X02, 풀스캔` 세가지 경우 존재
- `옵티마이저는 T_X01 선택`
- 선택한 근거는 무엇일까?


![실행계획2.png](image%2F%EC%8B%A4%ED%96%89%EA%B3%84%ED%9A%8D2.png)
![실행계획3.png](image%2F%EC%8B%A4%ED%96%89%EA%B3%84%ED%9A%8D3.png)

> 위 사진은 각각 T_X02 인덱스를 선택, 풀스캔을 선택한 실행계획이다. T_X01와 Cost를 비교해보면 각각 2, 19, 29임을 확인할 수 있다.
> 
> 비용(Cost)은 `쿼리를 수행하는 동안 발생할 것으로 예상하는 I/O 횟수 또는 예상 소요시간을 표현한 값`이다.
> 
> Cost 또한 내비게이션의 도착 시간처럼 '예상치'이다. 단지 옵티마이저가 실행경로를 선택하기 위해 여러 통계정보를 통해 계산해낸 값.
> 
> 따라서 실제 수행하는 I/O 또는 시간과는 많은 차이가 난다.

---
### 1.1.5 옵티마이저 힌트
> 내비게이션은 보통 좋은 선택을 하지만, 그 선택이 항상 최선은 아니다. 옵티마이저도 대부분 좋은 선택을 하지만 완벽하진 않다.(SQL이 복잡할수록 실수할 가능성도 크다.)
> 
> 운전자가 본인만 아는 경로가 있듯이 개발자가 직접 더 효율적인 경로를 찾아낼수도 있다! 
> 
> = "이럴 때 `옵티마이저 힌트`를 이용해 액세스 경로를 바꿀 수 있다."

#### 힌트 사용법(주석 기호에 '+' 붙이기)
```sql
SELECT /*+ INDEX(A 고객 PK) */
       고객명, 연락처, 주소, 가입일시
  FROM 고객 A
 WHERE 고객ID = '000000008'
```

#### 권장 안하는 방식 (코딩하는 과정에서 줄바꿈 오류가 발생할 수 있기 때문)
```sql
SELECT --+ INDEX(A 고객 PK)
       고객명, 연락처, 주소, 가입일시
  FROM 고객 A
 WHERE 고객ID = '000000008'
```

```java
SQLStmt = "SELECT --+ INDEX(A 고객 PK) "  -> 아래쪽 라인이 모두 주석으로 처리됨
        + "       고객명, 연락처, 주소, 가입일시 "
        + "  FROM 고객 A "
        + " WHERE 고객ID = '000000008'" ;
```