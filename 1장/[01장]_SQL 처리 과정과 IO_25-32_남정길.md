# SQL 처리 과정과 IO
---
### 주의사항
힌트안에 인자를 나열할 땐 ',' 를 사용할 수 있지만, 힌트와 힌트 사이에 사용하면 안 된다.

```sql
/*+ INDEX(A A-X01) INDEX(B , B_X03) */ -> 모두 유효
/*+ INDEX(C) , FULL(D) */ -> 첫 번쨰 힌트만 유효
```
테이블 지정시 스카마명까지 명시하면 안됨

`SELECT /*+ FULL(SCOTT.EMP) */ FROM EMP -> 무효`

FROM절에 ALIAS를 지정했다면 힌트도 반드시 ALIAS를 사용해야 한다.

`SELECT /*+ FULL(EMP) */ FROM EMP E -> 무효`

### 자율이냐 강제냐 그것이 문제

  "중부내륙 고속도로로 가다가 대구에서 경부 고속도로 진입!
  나머지는 알아서 결정해!"
  
위 문장은 경로는 운전자가 선택하고 나머지는 내비게이션에 맡겼다.
SQL 옵티마이저에게도 이런 식으로 지시할 수 있다.

```sql
SELCET /*+ INDEX(A (주문일자)) */
      A.주문번호, A.주문금액, B.고객명, B.연락처, B.주소
FROM 주문 A, 고객 B
WHERE A.주문일자 = :ORD_DT
AND A.고객ID = B.고객ID
```

1. 주문 테이블을 액세스할 때 주문일자 컬럼이 선두인 인덱스를 사용하도록 힌트로 지정

2. 조인방식과 순서, 고객 테이블 액세스 방식은 옵티마이저가 알아서 판단

```sql
SELCET /*+ LEADING(A), USE_NL(B), INDEX(A (주문일자)), INDEX(B 고객_PK) */
      A.주문번호, A.주문금액, B.고객명, B.연락처, B.주소
FROM 주문 A, 고객 B
WHERE A.주문일자 = :ORD_DT
AND A.고객ID = B.고객ID
```

반면 이 쿼리는 옵티마이저가 절대 다른방식을 선택하지 못하도록 힌트를 빈틈없이 지정한 것

> 어떤방식이 옳은지는 환경에 따라 다르다 옵티마이저가 가끔 실수하더라도 별문제가 없는 시스템이 있는가 하면 옵티마이저의 작은 실수가 기업에 큰 손실을 끼치는 시스템도 있다. 기왕에 힌트를 쓸거면 빈틈없이 기술하는게 좋다

### 자주사용하는 힌트목록
| 분류           | 힌트                 | 설명                                                                                            |
| ------------ | ------------------ | --------------------------------------------------------------------------------------------- |
| **최적화 목표**   | `ALL_ROWS`         | 전체 처리속도 최적화                                                                                   |
|              | `FIRST_ROWS(N)`    | 최초 N건 응답속도 최적화                                                                                |
| **액세스 방식**   | `FULL`             | Table Full Scan으로 유도                                                                          |
|              | `INDEX`            | Index Scan으로 유도                                                                               |
|              | `INDEX_DESC`       | Index를 역순으로 스캔하도록 유도                                                                          |
|              | `INDEX_FFS`        | Index Fast Full Scan으로 유도                                                                     |
|              | `INDEX_SS`         | Index Skip Scan으로 유도                                                                          |
| **조인순서**     | `ORDERED`          | FROM 절에 나열된 순서대로 조인                                                                           |
|              | `LEADING`          | LEADING 힌트 끝줄에 기술한 순서대로 조인 <br>(예: `LEADING(T1 T2)`)                                          |
|              | `SWAP_JOIN_INPUTS` | 해시 조인 시 BUILD INPUT을 명시적으로 선택 <br>(예: `SWAP_JOIN_INPUTS(T1)`)                                 |
| **조인방식**     | `USE_NL`           | NL(Nested Loop) 조인으로 유도                                                                       |
|              | `USE_MERGE`        | Sort Merge 조인으로 유도                                                                            |
|              | `USE_HASH`         | Hash 조인으로 유도                                                                                  |
|              | `NL_SJ`            | NL 세미조인으로 유도                                                                                  |
|              | `MERGE_SJ`         | Sort Merge 세미조인으로 유도                                                                          |
|              | `HASH_SJ`          | Hash 세미조인으로 유도                                                                                |
| **서브쿼리 팩토링** | `MATERIALIZE`      | WITH문으로 정의한 집합을 물리적으로 생성하도록 유도 <br>(예: `WITH /*+ MATERIALIZE */ T AS (SELECT ...)`)           |
|              | `INLINE`           | WITH문으로 정의한 집합을 물리적으로 생성하지 않고 Inline 처리하도록 유도 <br>(예: `WITH /*+ INLINE */ T AS (SELECT ...)`) |
| **쿼리 변환** | `MERGE`          | 뷰 머징 유도                                                               |
|           | `NO_MERGE`       | 뷰 머징 방지                                                               |
|           | `UNNEST`         | 서브쿼리 Unnesting 유도                                                     |
|           | `NO_UNNEST`      | 서브쿼리 Unnesting 방지                                                     |
|           | `PUSH_PRED`      | 조인조건 Pushdown 유도                                                      |
|           | `NO_PUSH_PRED`   | 조인조건 Pushdown 방지                                                      |
|           | `USE_CONCAT`     | OR 또는 IN-List 조건을 OR-Expansion으로 유도                                   |
|           | `NO_EXPAND`      | OR 또는 IN-List 조건에 대한 OR-Expansion 방지                                  |
| **병렬 처리** | `PARALLEL`       | 테이블 스캔 또는 DML을 병렬 방식으로 처리 유도 <br>(예: `PARALLEL(T1 2) PARALLEL(T2 2)`) |
|           | `PARALLEL_INDEX` | 인덱스 스캔을 병렬 방식으로 처리 유도                                                 |
|           | `PQ_DISTRIBUTE`  | 병렬 수행 시 데이터 분배 방식 결정 <br>(예: `PQ_DISTRIBUTE(T1 HASH HASH)`)           |
| **기타**    | `APPEND`         | Direct-Path Insert로 유도                                                |
|           | `DRIVING_SITE`   | DB Link Remote 쿼리에 대한 최적화 및 실행 주체 지정 (Local 또는 Remote)                |
|           | `PUSH_SUBQ`      | 서브쿼리를 가급적 빨리 필터링하도록 유도                                                |
|           | `NO_PUSH_SUBQ`   | 서브쿼리를 가급적 늦게 필터링하도록 유도                                                |

## 1.2 SQL공유 및 재사용
1.2장은 소프트 파싱과 하드 파싱의 차이점을 설명한다.
SQL내부의 최적화 과정의 복잡성을 알고 나면 동시성이 높은 온라인 트랜잭션 처리시스템에서 바인드 변수의 중요성을 이해할 수 있다.

### 소프트파싱 VS 하드파싱

### ✅ SGA (System Global Area)
- 서버 프로세스와 백그라운드 프로세스가 **공통으로 액세스**하는 데이터와 제어 구조를 캐싱하는 메모리 공간

### ✅ 라이브러리 캐시 (Library Cache)
- SQL 파싱, 최적화, 로우 소스 생성 과정을 거쳐 만든 **내부 프로시저를 재사용**할 수 있도록 저장하는 공간
- 캐싱해두면 여러 사용자가 **동시에 재사용 가능**

![image_1-4.png](image%2Fimage_1-4.png)

1. 사용자가 SQL문을 전달하면 DBMS는 SQL을 파싱한후 해당 SQL이 라이브 러리 캐시에 존재하는지 확인한다.

2. 캐시에서 찾으면 곧바로 실행단계로 넘어가지만, 찾지 못하면 최적화 단계를 거친다. 

SQL을 캐시에서 찾아 곧바로 실행단계로 넘어가는 것을 **소프트 파싱**이라 하고 
찾는데 실패해 최적화 및 로우소스 생성 단계 까지 모두 거치는 것을 **하드 파싱**이라고 한다.

![image_1-5.png](image%2Fimage_1-5.png)

### SQL최적화 과정은 왜 Hard할까?

옵티마이저가 SQL을 최적화 할때 많은 일을 수행하게 된다.

예를들어 5개의 테이블을 조인하는 쿼리하나를 최적화 하는데도 무수히 많은 경우의 수가 존재한다.

>조인순서 120(5!)개 + (NL조인, 소트 머지 조인, 해시조인) + (FULL스캔, 인덱스(인덱스도 다양한방식 존재))

옵티마이저가 사용하는 정보
 - 테이블, 컬럼, 인덱스 구존
 - 오브젝트 통계: 테이블 통계, 인덱스 통계, 컬럼 통계
 - 시스템 통계: CPU속도, Single Block I/O 속도, Miltiblock I/O속도 등
 - 옵티마이저 관련 파라미터 

 > 👉 이렇게 어려운 작업을 거쳐 생성한 내부프로시저를 한 번만 사용하고 버린다면 비효율적 <br>
 > 👉 그래서 라이브러리 캐시가 필요하다!

### 바인드 변수의 중요성

### 이름 없는 SQL 문제

- 사용자 정의 함수나 프로시저는 **생성 시부터 이름을 가지며**, 컴파일 후 데이터 딕셔너리에 저장됩니다.  
  삭제하지 않는 한 영구적으로 보관되며, 실행 시 라이브러리 캐시에 적재되어 여러 사용자가 공유할 수 있습니다.  

- 반면 SQL은 **이름이 따로 없고 전체 SQL 텍스트가 이름 역할**을 합니다. (딕셔너리 저장 X) <br> 
  처음 실행할 때 최적화 과정을 거쳐 **동적으로 내부 프로시저를 생성**하고, 라이브러리 캐시에 적재하여 여러 사용자가 재사용할 수 있습니다.
  그러나 캐시 공간이 부족하면 제거되고, 다음 실행 시 동일한 최적화 과정을 다시 거쳐 캐시에 적재됩니다.  

- **SQL을 영구 저장할 수 없는 이유**
  - 사용자 정의 함수/프로시저는 이름이 변하지 않으므로 수정해도 같은 객체를 재사용할 수 있지만,  
    SQL은 **SQL 텍스트 자체가 이름**이기 때문에 작은 부분이라도 수정되면 새로운 객체가 생성됩니다.  
  - 모든 SQL을 영구 저장하면 많은 저장 공간이 필요하고, SQL 검색 속도도 느려집니다.  
  - 따라서 Oracle, SQL Server 등 대부분의 DBMS는 SQL을 **영구 저장하지 않고 캐시 방식으로 관리**합니다.










