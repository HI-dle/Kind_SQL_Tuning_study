## 4.3.4 해시 조인 실행계획 제어
### 해시 조인 실행계획
```shell
Execution Plan
-------------------------------------------------------
0  1 SELECT  STATEMENT Optimizer=ALL_ROWS
1  0   HASH JOIN
2  1     TABLE ACCESS (BY INDEX ROWID) OF '사원' (TABLE)
3  2       INDEX (RANGE SCAN) OF '사원_X1' (INDEX)
4  1     TABLE ACCESS (BY INDEX ROWID) OF '고객' (TABLE)
5  4       INDEX (RANGE SCAN) OF '고객_N1' (INDEX)
```
> 사원 데이터로 해시 테이블을 생성한 후, 고객 테이블에서 읽은 조인 키값으로 해시 테이블을 탐색하면서 조인한다.
> 
> 인덱스를 사용했다는 것도 확인할 수 있다. (물론 Table Full Scan으로 처리할 수도 있다.)

### use_hash 힌트
해시 조인 실행계획을 제어할 때 아래와 같이 `use_hash` 힌트를 사용한다.

```sql
select /*+ use_hash(e c) */
      e.사원번호, c.고객명
from  사원 e, 고객 c
where c.관리사원번호 = e.사원번호
and   e.부서코드 = 'Z123'
and   c.최종주문금액 >= 20000
```

- `use_hash` 힌트만 사용했으므로 `Build Input`은 옵티마이저가 선택한다.`(일반적으로 카디널리티가 작은 테이블을 선택)`
  - 테이블 전체 카디널리티가 아닌, 각 테이블 조건절에 대한 카디널리티를 의미

### Build Input을 사용자가 직접 선택하는 법
- `leading` 힌트
- `ordered` 힌트
- `swap_join_inputs` 힌트

오라클은 기본적으로 이들 힌트로 지시한 순서에 따라 가장 먼저 읽는 테이블을 `Build Input`으로 선택한다.
```sql
select /*+ leading(e) use hash(c) */ -- e를 먼저 읽고 c를 해시로 조인해라
```

```sql
select /*+ ordered use hash(c) */
from e, c
```

아래와 같이 `swap_join_inputs` 힌트로 Build Input을 명시적으로 선택할 수 있다.

```sql
select /*+ leading(e) use hash(c) swap_join_inputs(c) */ -- c를 bulid input으로 사용하도록 명시
```

### 세 개 이상 테이블 해시 조인
예를 들어, `A, B, C` 세 개 테이블이 있다. 이 테이블들을 조인하는 경로는 아래 그림처럼 두 가지다.
- `A와 B`를 조인하고, `B와 C`를 조인(`where` A.key = B.key `and` B.key = C.key)
- `A와 B`를 조인하고, `A와 C`를 조인(`where` A.key = B.key `and` A.key = C.key)

![image_4-14.png](image%2Fimage_4-14.png)

경로 2를 아래와 같이 바꿔 표현할 수 있다.

![image_4-15.png](image%2Fimage_4-15.png)

> 결국, 세 테이블을 조인하는 경로는 아래 그림처럼 단 한가지다!

![image_4-16.png](image%2Fimage_4-16.png)

문제가 단순해졌으니, 그림 순서에 따라 `leading 힌트`를 지정해 주면 된다.
```sql
select /*+ leading(T1, T2, T3) use_hash(T2) use_hash(T3) */
from T1, T2, T3
where T1.key = T2.key
and T2.key = T3.key
```
- 해시 조인에서 `leading 힌트 첫 번째 파라미터`로 지정한 테이블은 무조건 `Build Input`으로 선택된다.
  - e.g) 위 예시는 T1 테이블을 첫 번째 파라미터로 지정
    - T2 테이블과 조인할 때 T1이 `Build Input`
    - 따라서 나올 수 있는 실행계획 패턴은 아래 두 가지뿐이다.

> - 패턴1: `(T1 + T2)` + `T3`
> - 패턴2: `T3` + `(T1 + T2)`

```shell
<패턴 1>

Execution Plan 
-------------------------------------------------------
0    SELECT  STATEMENT Optimizer=ALL_ROWS
1  0   HASH JOIN
2  1     HASH JOIN
3  2       TABLE ACCESS (FULL) OF 'T1' (TABLE)
4  2       TABLE ACCESS (FULL) OF 'T2' (TABLE)
5  1     TABLE ACCESS (FULL) OF 'T3' (TABLE)
```

```shell
<패턴 2>

Execution Plan 
-------------------------------------------------------
0    SELECT  STATEMENT Optimizer=ALL_ROWS
1  0   HASH JOIN
2  1     TABLE ACCESS (FULL) OF 'T3' (TABLE)
3  1     HASH JOIN
4  3       TABLE ACCESS (FULL) OF 'T1' (TABLE)
5  3       TABLE ACCESS (FULL) OF 'T2' (TABLE)
```

---

위 처럼 `T1이 Build Input`으로 선택된 상황에서 `T2를 Build Input으로 바꾸고`싶다면, 아래와 같이 `swap_join_inputs`힌트를 사용하면 된다.
```sql
select /*+ leading(T1, T2, T3) swap_join_inputs(T2) */ ...
```

이랬을 때, 실행계획은 각각 아래와 같이 바뀐다.(`T1, T2 테이블 Access 순서가 바뀜`)

```shell
<패턴 1>

Execution Plan 
-------------------------------------------------------
0    SELECT  STATEMENT Optimizer=ALL_ROWS
1  0   HASH JOIN
2  1     HASH JOIN
3  2       TABLE ACCESS (FULL) OF 'T2' (TABLE) -- 둘이 순서
4  2       TABLE ACCESS (FULL) OF 'T1' (TABLE) -- 바뀜
5  1     TABLE ACCESS (FULL) OF 'T3' (TABLE)
```

```shell
<패턴 2>

Execution Plan 
-------------------------------------------------------
0    SELECT  STATEMENT Optimizer=ALL_ROWS
1  0   HASH JOIN
2  1     TABLE ACCESS (FULL) OF 'T3' (TABLE)
3  1     HASH JOIN
4  3       TABLE ACCESS (FULL) OF 'T2' (TABLE) -- 둘이 순서
5  3       TABLE ACCESS (FULL) OF 'T1' (TABLE) -- 바뀜
```

### 패턴1을 패턴2로 바꾸고 싶다면?
즉, `(T1 + T2) + T3` 을 `T3 + (T1 + T2)`으로 바꾸는 것이므로 `T3를 Build Input으로 선택`하는 것을 의미한다.

따라서 `swap_join_inputs(T3)`를 해준다.

```sql
select /*+ leading(T1, T2, T3) swap_join_inputs(T3) */

select /*+ leading(T1, T2, T3) swap_join_inputs(T2) swap_join_inputs(T3) */
```

### 반대로, 패턴2를 패턴1로 바꾸고 싶다면?
즉, `(T1 + T2)`와 `T3` 중에 `(T1 + T2)`를 `Build Input으로 선택하는 것을 의미`한다.

따라서 T1과 T2를 조인한 결과집합을 `swap_join_inputs` 힌트에 지정해야하는데, 방법이 없다.

이 때, `no_swap_join_inputs` 힌트를 사용하면 된다!
> : T3를 `Probe Input`으로 선택해주는 방식

```sql
select /*+ leading(T1, T2, T3) no_swap_join_inputs(T3) */

-- T3는 선택하지 않겠다.(= T1 + T2 선택하겠다.)
```

> 💡 no_swap_join_inputs 힌트는 오라클 10.1.0.3 버전부터 제공됐다.
> 
> 이 힌트가 없을 때는 SQL을 아래와 같이 변환하고 인라인 뷰 Alias로 제어해야만 했다.
> 
> ```sql
> select /*+ leading(T4) use_hash(T3) */
> from (select * from T1, T2 where T1.key = T2.key) T4, T3
> where T4.key = T3.key 
> ```
> 또는
> ```sql
> select /*+ use_hash(T3 T4) swap_join_inputs(T4) */
> from (select * from T1, T2 where T1.key = T2.key) T4, T3
> where T4.key = T3.key
> ```

### 정리
- 조인하는 테이블이 몇 개든, 원리는 똑같다.
- 조인 연결고리를 따라 순방향 또는 역방향으로 `leading` 힌트에 기술
- `Build Input`으로 선택하고 싶은 테이블을 `swap_join_inputs` 힌트에 지정
- build input으로 선택하고 싶은 테이블이 `조인된 결과 집합`이라면, `no_swap_join_inputs` 힌트로 반대쪽 `Probe Input`을 선택

---
## 4.3.5 조인 메소드 선택 기준
해시 조인이 워낙 빠르다 보니 내부 수행원리를 잘 모르는 개발자는 유혹에 빠지기 쉽다.

인덱스 설계에 공들이지 않아도 되니 편리하기까지 하기 때문이다.

그런데 이는 매우 위험한 생각이다. 수행빈도가 매우 높은 쿼리에 대해서 특히 그렇다.

왜 위험한지는 뒤에서 살펴보기로 하고, `일반적인 조인 메소드 선택 기준`부터 알아보겠다.

---
### 일반적인 조인 메소드 선택 기준
![image_4-18.png](image%2Fimage_4-18.png)
1. 소량 데이터 조인할 때: **NL 조인**
2. 대량 데이터 조인할 때: **해시 조인**
3. 대량 데이터 조인인데 해시 조인으로 처리할 수 없을 때, 즉, 조인 조건식이 `등치(=)`가 아닐 때(조인 조건식이 아예 없는 카데시안 곱 포함): **소트 머지 조인**

### 데이터의 소량과 대량의 기준
- 단순히 데이터량의 많고 적음에 있지 않다.
- NL 조인 기준으로 최적화했는데도, 랜덤 액세스가 많아 `만족스럽지 못한 성능`이라면 `대량 데이터 조인에 해당`한다.

> 책의 저자는 `수행빈도가 높은 쿼리`에 대해 아래와 같은 조인 메소드 선택 기준도 제시한다.
> 
> - (최적화된) NL 조인과 해시 조인 성능이 같으면: `NL 조인`
> - 해시 조인이 약간 더 빠른 경우: `NL 조인`
> - NL 조인보다 해시 조인이 매우 빠른 경우: `해시 조인`
> 
> : 핵심은 **'수행빈도가 높은 소량 데이터 조인에서 설령 해시 조인이 약간 더 빠르더라도 NL 조인을 선택하라'** 라고 한다.

### 왜 조인 메서드를 선택할 때 NL 조인을 가장 먼저 고려해야 할까?
NL 조인 위주로 하면 인덱스 설계가 부담된다. 심지어 해시 조인이 약간 더 빠른데도 `왜 NL 조인을 선택해야 할까?`

- `인덱스`: (DBA가 Drop하지 않는 한)영구적으로 유지하면서 다양한 쿼리를 위해 공유 및 재사용하는 자료구조
- `해시 테이블`: 단 하나의 쿼리를 위해 생성하고 조인이 끝나면 곧바로 소멸하는 자료구조
  - e.g) 같은 쿼리를 100개의 프로세스가 동시에 수행
    - 해시 테이블 100개 생성

> 🚀 따라서 `수행시간이 짧으면서 수행빈도가 높은 쿼리`를 `해시 조인으로 처리`하면 `CPU와 메모리 사용률이 증가`한다!
> 
> 해시 맵을 만드는 과정에 여러 가지 래치 경합도 발생한다.

### 결론
해시 조인은 아래 세 가지 조건을 만족하는 SQL문에 주로 사용한다.
- 수행 빈도가 낮고
- 쿼리 수행 시간이 오래 걸리는
- 대량 데이터 조인할 때

> 위 세가지 조건은 `배치 프로그램`, `DW`, `OLAP`성 쿼리의 특징이기도 하다.
> 
> OLTP 환경에서도 해시 조인을 쓸 수 있지만, 세 가지 기준을 만족하는지 점검해 봐야 한다.
> 
> 쉽게 말하면, OLTP 환경에서 `최적화된 NL 조인으로 0.1초 걸리는 쿼리를 0.01초로 단축하기 위해 해시 조인을 쓰는 것은 자제하라`는 뜻이다.
> 
> 만약 시스템 운영자가 0.1초 걸리는 쿼리를 0.01초로 단축해 달라고 했다면, 이는 수행 빈도가 아주 높은 쿼리임이 분명하므로 NL 조인이 더 적합하다.
>
> ---
> *`DW(데이터 웨어하우스)`: 데이터를 통합, 저장, 분석하기 위해 만든 대규모 데이터 저장소
> 
> *`OLAP(Online Analytical Processing)`: DW에 저장된 데이터를 기반으로 복잡한 분석, 집계를 빠르게 수핼할 수 있는 처리 방식