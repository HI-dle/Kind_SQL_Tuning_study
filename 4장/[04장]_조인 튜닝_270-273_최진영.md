# 4.1.7 NL 조인 확장 메커니즘
버전이 올라가면서 오라클은 `NL 조인`의 성능을 높이기 위해 두가지를 도입했다.
- `테이블 Prefetch`: 인덱스를 이용해 테이블을 액세스하다가 디스크 I/O가 필요해지면, 이어서 곧 읽게 될 블록까지 버퍼캐시에 적재하는 기능
- `배치 I/O`: 디스크 I/O call을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리하는 기능

> 두 기능 모두, `읽는 블록 건건마다 I/O Call을 발생시키는 비효율을 줄이기 위해` 고안됨

---
내부 원리까지 자세히 알 필요는 없지만, 튜닝 과정에서 이 기능들을 표현한 실행계획을 자주 보게 되므로 `표현 방식`을 알아볼 예정

### 1. 전통적인 실행계획
오라클이 NL 조인을 표현하기 위해 전통적으로 사용해 온 방식
```sql
Rows Rows Source Operation
---- --------------------------
 5     NESTED LOOPS
 3       TABLE ACCESS BY INDEX ROWID OF 사원
 5         INDEX RANGE SCAN OF 사원_X1
 5       TABLE ACCESS BY INDEX ROWID OF 고객
 8         INDEX RANGE SCAN OF 고객_X1
```

### 2. 테이블 Prefetch 실행계획
오라클 9i부터 아래와 같은 표현방식도 같이 나타남
> 테이블 Prefetch를 다시 짚고가자면, `이어서 읽게 될 블록까지 미리 버퍼캐시에 적재하는 기능이다.`
```sql
Rows Rows Source Operation
---- --------------------------
 5     TABLE ACCESS BY INDEX ROWID OF 고객 -- Inner 쪽 테이블(고객)
 12      NESTED LOOPS
 3         TABLE ACCESS BY INDEX ROWID OF 사원
 3           INDEX RANGE SCAN OF 사원_X1
 8         INDEX RANGE SCAN OF 고객_X1
```
- `Inner 쪽 테이블`에 대한 디스크 I/O 과정에 `테이블 Prefetch 기능이 작동할 수 있음을 표시`하기 위함
- `nlj_prefetch`, `no_nlj_prefetch` 힌트를 이용해 이 실행계획이 나오게 or 안나오게 할 수도 있다.

### 3. 배치 I/O 실행게획
오라클 11g부터 아래와 같은 표현방식도 같이 나타남
> 배치 I/O를 다시 짚고가자면, `디스크 I/O Call을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리하는 기능이다.`
```sql
Rows Rows Source Operation
---- --------------------------
 5     NESTED LOOPS
 8       NESTED LOOPS
 3         TABLE ACCESS BY INDEX ROWID OF 사원
 3           INDEX RANGE SCAN OF 사원_X1
 8         INDEX RANGE SCAN OF 고객_X1
 5       TABLE ACCESS BY INDEX ROWID OF 고객 -- Inner 쪽 테이블(고객)
```
- `Inner 쪽 테이블`에 대한 디스크 I/O 과정에 `배치 I/O 기능이 작동할 수 있음을 표시`하기 위함
- `nlj_batching`, `no_nlj_batching` 힌트를 이용해 이 실행계획이 나오게 or 안나오게 할 수도 있다.

> - 오라클 11g에서는 위 세 가지 실행계획이 모두 나타나는데, `Inner 쪽 테이블 블록을 모두 버퍼캐시에서 읽는다면` 어떤 방식으로 수행하든 성능에 차이가 없다.
>   - 데이터 출력 순서도 동일하다
> - 다만, `일부를 디스크에서 읽게 되면` 성능에 차이가 나타날 수 있다.
>   - 배치 I/O 실행계획이 나타날 때는 결과집합의 정렬 순서도 다를 수 있어서 주의가 필요하다.
>   - 11g부터 NL 조인 Inner 쪽 테이블에 작동하는 배치 I/O 기능도 결과집합의 정렬 순서를 보장하지 않는다.

### 예시
```sql
SELECT /*+ ordered use_nl(b) */
    A.등록일시, A.번호, A.제목, B.회원명, A.게시판유형, A.질문유형
FROM (
    SELECT A.*, ROWNUM NO
    FROM (
        SELECT 등록일시, 번호, 제목, 작성자번호, 게시판유형, 질문유형
        FROM 게시판
        WHERE 게시판유형 = :TYPE
        ORDER BY 등록일지 DESC -- 인덱스 구성 : 게시판 유형 + 등록일시
        ) A
    WHERE ROWNUM <= (:page * 10)
     ) A, 회원 B
WHERE A.NO >= (:page-1)*10 + 1
AND   B.회원번호 = A.작성자번호
ORDER BY A.등록일시 DESC -- 11g부터 여기에 ORDER BY를 명시해야 정렬 순서 보장
```
- `안쪽 인라인 뷰에서 이미 등록일시 역순으로 정렬`
- 회원 테이블과는 한 건씩 순차적으로 진행하는 NL 방식으로 조인하도록 힌트를 명시

### 결론
- 배치 I/O가 작동하지 않는 버전까지는 맨 바깥쪽 ORDER BY 절이 없어도 상관없었다.
- 11g부터 NL 조인 결과집합이 항상 일정한 순서로 출력되기를 원한다면, 두 방법이 있다.
  - `no_nlj_batching(b)` 힌트를 추가하거나
  - 맨 바깥쪽 ORDER BY를 명시하기
    - 주의할 점은 바깥쪽 ORDER BY를 추가했어도, 안쪽 ORDER BY를 함부로 제거해선 안된다.
      - TOP N 쿼리를 구현하기 위한 것이기 때문

### NL 조인 자가 진단
> 책의 저자분이 개발팀으로부터 인덱스를 생성해 달라는 요청을 받은 예시라고 합니다.
> 
> 예시를 통해 NL 조인을 잘 이해했는지, 아래 요구한 인덱스를 어떻게 재구성해야하는지 직접 생각해보라고 합니다.

PRA_HST_STC_N1 : `SALE_ORG_ID + STRD_GRP_ID + STRD_ID + STC_DT`

#### 해당 SQL
```sql
select *
from PRA_HST_STC a, ODM_TRMS b
where a.SALE_ORG_ID = :sale_org_id
and   a.STRD_GRP_ID = b.STRD_GRP_ID
and   a.STRD_ID     = b.STRD_ID
order by a.STC_DT desc
```

#### 인덱스를 어떻게 재구성해야할까?
> 개발자라면 Inner 테이블 alias를 왼쪽에 기술하는 습관을 들여야한다고합니다.
> 
> 그리고 이 습관이 이 문제를 해결할 수 있는 힌트라고합니다.
```sql
select *
from PRA_HST_STC a, ODM_TRMS b
where a.SALE_ORG_ID = :sale_org_id
and   b.STRD_GRP_ID = a.STRD_GRP_ID -- 이 줄 바뀜
and   b.STRD_ID     = a.STRD_ID     -- 이 줄 바뀜
order by a.STC_DT desc
```

---
#### 🤔 정답은 아니지만 그냥 제 생각
a가 outer 테이블, b가 inner 테이블이라고 할 때, 위에서 개발자가 요구한 것은 a 테이블에 조건절에 있는 컬럼이 모두 포함된 인덱스를 추가하는 것.

하지만 해당 쿼리는 `where a.SALE_ORG_ID = :sale_org_id` 즉, a(outer)테이블에서 row 1건마다 b(inner)테이블에서 조건에 부합하는 row를 찾습니다.
```sql
and   b.STRD_GRP_ID = a.STRD_GRP_ID 
and   b.STRD_ID     = a.STRD_ID     
```

그렇기 때문에 a 테이블에 인덱스를 추가하는 것이 아닌, b 테이블에 `[STRD_GRP_ID + STRD_ID]` 인덱스를 추가해야하는 것이 아닌가.. 라는 생각입니다.

