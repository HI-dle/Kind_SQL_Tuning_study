#### Later 인라인 뷰, Cross/Outer Apply 조인

- 인라인 뷰 안에서 메인쿼리 테이블 컬럼을 참조하면 `ìnvalid identifier`에러가 발생한다.
- 오라클 12c 부터 인라인 뷰를 `Lateral`로 선언하면 인라인 뷰 안에서 메인쿼리 테이블의 컬럼을 참조할 수 있다.
    ```sql
    select * from 사원 e,
            LATERAL (select * 
                        from 조직
                        where 조직코드 = e.조직코드)
    ```
- Lateral 인라인 뷰와 Outer 조인하는 방법은 아래와 같다.
    ```sql
    select * from 사원 e,
            LATERAL (select * 
                        from 조직
                        where 조직코드 = e.조직코드)(+)
- Outer 조인이 필요하면 12c의 `Outer Apply` 조인구문을 사용할 수도 있다.
    ```sql
    select * from 사원 e,
            OUTER APPLY (select * 
                        from 조직
                        where 조직코드 = e.조직코드)
    ```
- 12c에서는 `Cross Apply` 조인 구문도 지원한다. 기능적으로는 Lateral 인라인 뷰와 같다.
    ```sql
    select * from 사원 e,
            CROSS APPLY (select * 
                        from 조직
                        where 조직코드 = e.조직코드)
    ```

- 유용해 보이지만 굳이 이들 새 구문을 사용할 이유는 찾기힘들다. 최근 오라클 버전에선 `조인조건 Pushdown 기능이 아주 잘 작동하기 때문이다.
- 이들 구문을 남용하게되면 뷰가 서로 얽히고설킨 복잡한 쿼리가 양산될 수 있으며, 새 구문을 사용하면 실행계획 제어가 어려운 사례도 발견되고 있다.
- 아래 SQL에 (5장 3절, 4절에서 설명할) `TOP N Stopkey 알고리즘이 잘 작동하면 꽤 쓸만할 텐데, 유감스럽게 그렇지 않다.
    ```sql
    select * from 사원 e
        LATERAL (select *
                    from 사원변경이력
                    where 사원코드 = e.사원코드
                    order by 변경일시 desc)
                where rownum <= 5);
    ```

> 정리하면, 기본적으로 Lateral 인라인 뷰, Cross/Outer Apply 조인을 사용할 이유는 없다. <br> 기존 익숙한 구문으로도 원하는 실행계획을 만들어 낼 수 있기 때문이다.<br> 튜닝 과정에 알 수 없는 이유로 조인 조건 Pushdown 기능이 잘 작동하지 않을 때가 있는데, 그럴 때 Lateral 인라인 뷰가 도움이 된다.

### 4.4.4 스칼라 서브쿼리 조인
1. 스칼라 서브쿼리의 특징
    ```sql
    /*부서번호(deptno)를 넣으면 부서명(dname)을 반환하는 함수*/
    create or replace function GET_DNAME(p_deptno number) return varchar2
    is
        l_dname dept.dname%TYPE;
    begin
        select dname into l_dname 
        from dept 
        where deptno = p_deptno;

        return l_dname;

    exception
        when others then
            return null;
    end;
    /
    ```
    GET_DNAME 함수를 사용하여 아래 쿼리를 실행하면, 함수 안에 있는 SELECT 쿼리를 메인 쿼리 결과만큼 `재귀적으로` 반복 실행한다
    >재귀적 실행이란 → 메인 쿼리가 한 행을 읽을 때마다, 별도의 컨텍스트(독립적인 실행 스택) 를 열고 함수나 서브쿼리를 따로 수행하는 걸 의미
    ```sql
    select empno, ename, sal, hiredate,
       GET_DNAME(e.deptno) as dname
        from emp e
        where sal >= 2000;
    ```

    아래 스칼라 서브쿼리는 메인쿼리의 각 레코드마다 정확히 하나의 값을 반환한다.
    즉, 메인쿼리 건수만큼 DEPT 테이블을 반복해서 읽는다는 점에서 함수와 비슷해 보이지만,
    함수처럼 재귀적으로 실행되는 구조는 아니다.

    컨텍스트 스위칭(context switching) 없이 메인쿼리와 서브쿼리를 하나의 몸체처럼 실행한다.

    ```sql
    select empno, ename, sal, hiredate,
       (select d.dname from dept d where d.deptno = e.deptno) as dname
    from emp e
    where sal >= 2000;
    ```

    아래 Outer 조인문처럼 하나의 문장으로 이해하면 더 편하다. 스칼라 서브쿼리를 사용한 위 쿼리문을 아래처럼 NL 조인 방식으로 실행된다. DEPT와 조인에 실패하는 EMP 레코드는 DNAME에 NULL을 출력한다는 점도 같다.

    ```sql
    select /*+ ordered use_nl(d) */ e.empno, e.ename, e.sal, e.hiredate, d.dnane
    from emp e, dept d
    where d.deptno(+) = e.deptno. /*left outer 조인방식, emp에 있는 직원은 모두 출력하고,만약 dept에 해당 deptno가 없으면 dname은 NULL로 채운다.*/
    and e.sal >= 2000
    ``` 

    차이가 있다면, 스칼라 서브쿼리는 처리 과정에서 캐싱 작용이 일어난다는 데 있다.

2. 스칼라 서브쿼리 캐싱 효과

    스칼라 서브쿼리로 조인하면 오라클은 조인 횟수를 최소화하려고 입력 값과 출력 값을 내부 캐시에 저장해둔다. 조인할 때마다 캐시에서 `입력 값` 을 찾아보고, 찾으면 저장된 `출력 값`을 반환한다.

    캐시에서 찾지 못할 때만 조인을 수행하며, 결과는 버리지 않고 캐시에 저장한다.
    스칼라 서브쿼리의 입력 값은 그 안에서 참조하는 메인 쿼리의 컬럼 값이다.

    ```sql
    select empno, ename, sal, hiredate
        ,(
            select d.dname              -> 출력 값 : d.dname
            from depd d
            where d.deptno = e.deptno   -> 입력 값 : e.deptno
        )
    from emp e
    where sal >= 2000
    ```

    스칼라 서브쿼리 캐싱은 필터 서브쿼리 캐싱과 같은 기능이다. 이런 캐싱 메커니즘은 조인 성능을 높이는 데. 큰 도움이 된다.
    특히 메인쿼리 집합이 아무리 커도 조인할 데이터를 대부분 캐시에서 찾는다면, 조인 수행횟수를 최소화 할 수 있다.

    캐싱은 쿼리 단위로 이루어진다. 쿼리를 시작할 때 PGA 메모리에 공간을 할당하고, 쿼리를 수행하면서 공간을 채워나가며 쿼리를 마치는 순간 공간을 반환한다.

    - 많이 활용되는 튜닝 기법
        - SELECT-LIST에 사용한 함수는 메인쿼리 결과 건수만큼 반복 수행되는데, 아래와 같이 스칼라 서브쿼리를 덧씌우면 호출 횟수를 최소화할 수 있다.
        - 이는 스칼라 서브 쿼리의 캐싱효과 때문이다. 
        - 함수에 내장된 SELECT 쿼리도 그만큼 덜 수행된다.
            ```sql
            select empno, ename, sal, hiredate,
            (select GET_DNAME(e.deptno) from dual) dname
                from emp e
                where sal >= 2000;
            ```

3. 스칼라 서브쿼리 캐싱 부작용

    모든 캐시가 다 그렇듯 캐시 공간은 늘 부족하다. 스칼라 서브쿼리에 사용하는 캐시도 매우 작은 메모리 공간이다. 
    오라클 8i, 9i 기준으로 256개 엔트리를 캐싱하고, 10g 이후로는 입력과 출력 값 크기, `_query_execution_cache_max_size` 파라미터에 의해 사이즈를 결정한다.

    스칼라 서브쿼리 캐싱 효과는 입력 값의 종류가 소수여서 해시 충돌 가능성이 작을 때 효과가 있다. 반대의 경우라면 캐시를 매번 확인하는 비용 때문에 오히려 성능이 나빠지고, CPU 사용률만 높게 만든다. 메모리도 더 사용한다.

    예를들어, 아래 쿼리에 거래구분코드로 20개 값이 존재한다면, 20개는 캐시에 모두 저장하고도 남는다. <br>
    메인쿼리에서 50,000개 거래를 읽는 동안 거래구분 코드별 조인 액세스는 최초 한번씩만 발생한다. <br>
    이후로는 모두 캐시에서 데이터를 찾게 되므로 조인 성능을 높이는데 큰 도움이 된다.

    ```sql
    -- 최근 3개월간 거래 데이터를 조회하면서 거래구분명과 고객명을 스칼라 서브쿼리로 가져오는 예시
    SELECT 거래번호,고객번호,영업조직ID,거래구분코드,
    (SELECT 거래구분명 FROM 거래구분 WHERE 거래구분코드 = t.거래구분코드) 거래구분명
    FROM 거래 t
    WHERE t.거래일자 >= TO_CHAR(ADD_MONTHS(SYSDATE, -3), 'YYYYMMDD'); -- 50,000건
    ```
    
    고객테이블과 조인하는 경우를 보자. 고객은 100만명이다. 캐시에 도저히 담을 수 없을 만큼 많은 고객번호가 존재한다. 그렇다면 메인쿼리에서 50,000개 거래를 읽는 동안 캐시를 매번 탐색하지만, 대부분 데이터를 찾지 못해 결국 조인을 해야만 한다.

    불필요한 캐시 탐색 때문에 일반 조인문보다 느리고 불필요하게 자원만 낭비하는 셈이다.

    ```sql
        -- 최근 3개월간 거래 데이터를 조회하면서 거래구분명과 고객명을 스칼라 서브쿼리로 가져오는 예시
    SELECT 거래번호,고객번호,영업조직ID,거래구분코드,
    (SELECT 고객명 FROM 고객 WHERE 고객번호 = t.고객번호) 고객명
    FROM 거래 t
    WHERE t.거래일자 >= TO_CHAR(ADD_MONTHS(SYSDATE, -3), 'YYYYMMDD'); -- 50,000건
    ```

    위 쿼리에서 스칼라 서브쿼리가 성능에 도움이 되려면 최근 3개월간 수백 명 이내 일부 고객만 거래를 발생시켰어야 했다.

    함수 호출 횟수를 줄이기 위해 스칼라 서브쿼리를 덧씌우는 경우를 보자.<br>
    아래 쿼리문에서 체결 테이블에 입력된 매도계좌번호, 매수계좌번호가 무수히 많다면 스칼라 서브쿼리 캐싱 효과를 전혀 기대할 수 없으며 오히려 성능을 떨어뜨린다.

    ```sql
    SELECT 매도회원번호,
        매수회원번호,
        매도투자자구분코드,
        매수투자자구분코드,
        체결유형코드,
        매도계좌번호, (SELECT acnt_nm(매도계좌번호) FROM dual) AS 매도계좌명,
        매수계좌번호, (SELECT acnt_nm(매수계좌번호) FROM dual) AS 매수계좌명,
        체결시각,
        체결수량,
        체결가,
        체결수량 * 체결가 AS 체결금액
    FROM 체결;
    WHERE 종목코드 = :종목코드
    AND 체결일자 = :체결일자
    AND 체결시각 between sysdate-10/24/60 and sysdate

    ```

    스칼라 서브쿼리 캐싱이 성능에 도움을 주지 못하는 경우가 또 있는데, 메인 쿼리 집합이 매우 작은 경우다.<br>
    앞서 스칼라 서브쿼리 캐싱은 쿼리 단위로 이루어진다고 했다. 쿼리 단위로 쓰고 버린다는 뜻이다.<br>
    따라서 메인쿼리 집합이 클수록 재사용성이 높아 효과도 크다. 반대로 메인쿼리 집합이 작으면 캐시 재사용성도 낮다.<br>
    
    예를들어 아래 쿼리는 스칼라 서브쿼리 캐싱 효과를 거의 기대할 수 없고 오히려 성능을 떨어뜨린다. 고객당 계좌가 많지 않기 때문이다.
    보통은 한 개일 것이므로 쓰지도 않을 캐시를 할당에서 값을 채웠다가 바로 버리는 결과를 낳는다.

    ```sql
    select 계좌번호, 계좌명, 고객번호, 개설일자, 계좌종류구분코드, 은행개설여부, 은행연계여부,
        (select brch_nm(관리지점코드) from dual) 관리지점명,
        (select brch_nm(개설지점코드) from dual) 개설지점명,
    from 계좌
    where 고객번호 = :고객번호
    ```

    쿼리 단위로는 느낄 수 없는 미미한 차이겠지만, 전체적으로 이런 패턴을 불필요하게 많이 사용했을때 시스템에 미치는 영향을 생각해야한다.
    무엇이든지 원리를 정확히 알고 써야한다.


