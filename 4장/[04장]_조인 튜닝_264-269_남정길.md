# 조인 튜닝

---

### 4.1.4 NL 조인 튜닝 포인트 

![그림_4_7.png](image%2F%EA%B7%B8%EB%A6%BC_4_7.png)
 1. **사원_X1 인덱스를 읽은 후 사원 테이블 액세스 부분**
    * 만약 사원 테이블로 많은 양의 랜덤 액세스가 발생했고, 부서코드 = 'Z123' 조건에 의해 필터링 되는 비율이 높다면 사원_X1 인덱스에 부서코드 컬럼을 추가하는 방안을 고려할 수 있다. 
    

 2. **고객_X1 인덱스 탐색 부분**
    * 고객_X1 인덱스를 탐색하는 횟수, 즉 조인 액세스 횟수가 많을수록 성능이 느려진다.<br> 
     조인 액세스 횟수는 Outer테이블인 사원을 읽고 필터링한 결과 건수에 의해 결정<br>
     만약 만족하는 레코드가 10만건 일때 인덱스 Depth가 3이라면 수직적 탐색만 30만개 블럭을 읽어야 한다.

    
 3. **고객_X1 인덱스를 읽고 나서 고객 테이블 액세스 부분**
    * 최종주문금액 >= 20000 조건에 의해 필터링 되는 비율이 높다면 고객_X1인덱스에 최종주문 금액 추가 고려
 

 4. **맨 처음 액세스하는 사원_X1 인덱스에서 얻은 결과 건수에 의해 전체 일량이 좌우된다**
    * 사원_X1 인덱스를 스캔하면서 추출한 레코드가 많으면, 사원 테이블로 랜덤 액세스 하는 횟수, 고객_X1 인덱스를 탐색하는 횟수가 전반적으로 많아진다.

### 4.1.5 NL 조인 특징 요약

1. 랜덤 액세스 위주의 조인 방식
    * 레코드 하나를 읽으려고 블록을 통째로 읽는 랜덤 액세스 방식은 메모리 버퍼에서 빨리 읽더라도 비효율이 존재한다 -> 인덱스 구성이 완벽하더라도 대량 데이터 조회시 NL조인이 불리한 이유

2. 조인을 한 레코드씩 순차적으로 진행
    * 이 특징은 아무리 큰 테이블을 조인 하더라도 매우 빠른 응답 속도를 낼 수 있다. 부분 범위 처리가 가능한 상황에서 그렇다
      아래 쿼리는 조회버튼을 누르자마자 결과를 출력한다.
3. 다른 조인 방식과 비교할 때 인덱스 구성 전략이 특히 중요하다
    * 조인컬럼에 대한 인덱스가 있느냐 없느냐, 있다면 컬럼이 어떻게 구성됐느냐에 때라 조인 효율이 크게 달라진다.


종합적으로 고려했을시 NL조인은 소량데이터를 주로 처리하거나 부분 범위 처리가 가능한 온라인 트랜잭션 처리 시스템에 적합한 조인 방식이다.

### 4.1.6 NL조인 튜닝 실습

```sql
select /*+ ordered use_nl(b) index(e) index(c)*/
e.사원번호,e.사원명,e.입사일자,
c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.관리사원번호 = e.사원번호
and e.입사일자 >= '19960101'
and e.부서코드 >= 'Z123'
and e.최종주문금액 >= 20000
```
실행시 블록I/O는 9개로 튜닝할 필요가 없어 보인다 <br>
하지만 결과가 아래와 같다면?
```oracle-sql
Rows   Row Source Operation
-----  ----------------------------------------
5       Nested loops
3         Table access (by index rowid) of '사원' (Table)
2780      index (range scan) of '사원_x1' (index)
5         Table access (by index rowid) of '고객' (Table)
8         index (range scan) of '고객_x1' (index)
```
사원_X1 인덱스를 스캔하고서 테이블 액세스한 횟수가 2780인데 부서코드 = 'Z123' 조건을 필터링한 결과는 3건이다.

> ✅ **개선방안:**  
> 테이블 액세스 한 후에 필터링 되는 비율이 높다면 <br>
> 인덱스에 테이블 필터 조건 컬럼(`부서코드`)을 **추가**한다.

**사원_X1 인덱스에 부서코드 컬럼을 추가한 후**
```oracle-sql
Rows   Row Source Operation
-----  ----------------------------------------
5       Nested loops
3         Table access (by index rowid) of '사원' (Table)
5         index (range scan) of '사원_x1' (index)
5         Table access (by index rowid) of '고객' (Table)
8         index (range scan) of '고객_x1' (index)
```
불필요한 액세스는 사라졌지만 테이블을 액세스 하기전 인덱스 스캔 단계에서의 일량은 확인하지 않아서 튜닝이 끝난것이 아니다.

```oracle-sql
Rows   Row Source Operation
-----  ----------------------------------------
5       Nested loops (Table)(cr=112, pr=34, pw=0, time=122us)
3         Table access (by index rowid) of '사원' (Table)(cr=105, pr=32, pw=0, time=118us)
5         index (range scan) of '사원_x1' (index)(cr=102, pr=31, pw=0, time=16)
5         Table access (by index rowid) of '고객' (Table)(cr=7, pr=2, pw=0, time=4)
8         index (range scan) of '고객_x1' (index)(cr=5, pr=1, pw=0, time=122us)
```
여기서 사원_X01 인덱스로부터 읽은 블록이 102개인데 한 블록에 500개 레코드가 있다고 가정하면
인덱스에서 3건을 얻기위해 50000여개를 읽은셈이다.
> ✅ **개선방안:**  
> 인덱스 컬럼 순서를 `부서코드 + 입사일자` 순으로 변경.


```oracle-sql
Rows   Row Source Operation
-----  ----------------------------------------
5       Nested loops (Table)(cr=2732, pr=386, pw=0, ...)
2780      Table access (by index rowid) of '사원' (Table)(cr=166, pr=2, pw=0,...)
2780      index (range scan) of '사원_x1' (index)(cr=4, pr=0, pw=0, t...)
5         Table access (by index rowid) of '고객' (Table)(cr=2566, pr=384, pw=0, ..)
8         index (range scan) of '고객_x1' (index)(cr=2558, pr=383, pw=0, ...)
```
부하지점: 사원 테이블을 읽고나서 고객 테이블과 조인하는 횟수다.<br>

2780번 조인시도를 했지만 조인에 성공하고 필터링까지 마친 결과집합은 5개 뿐

> ✅ **개선방안:**
>1. **조인 순서 변경** 시도  
>   → `최종주문금액` 조건으로 먼저 필터링 (레코드 수 적은 쪽부터)
> 2. 그래도 개선되지 않으면  
>    → **Sort Merge Join** 또는 **Hash Join** 검토

