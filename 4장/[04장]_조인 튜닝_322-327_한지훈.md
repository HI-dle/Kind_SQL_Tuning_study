# 조인 튜닝

---

### (4) 두 개 이상의 값 반환

```oracle-sql
select c.고객번호, c.고객명
    ,(select round(avg(거래금액), 2) 평균거래금액
      from  거래
      where 거래일시 >= trunc(sysdate, 'mm')
      and 고객번호 = c.고객번호)
from 고객 c
where c.가입일시 >= trunc(add_months(sysdate, -1) , 'mm')

Execution Plan
--------------------------------
....
```

 - 위는 스칼라 서브쿼리를 사용할 때이다.
 - 해당 스칼라 서브쿼리의 실행 계획을 보게 되면 ...처리를 해두었지만 스칼라 서브쿼리가 위쪽에 나오게 되고 메 쿼리는 아래에 나오게 된다.
 - 실행 계획의 표현방식은 NL 조인과 다르지만, 프로세싱 과정은 NL 조인과 같다.
 - NL 조인처럼 부분범위 처리도 가능하고 앞서 설명됐듯 NL 조인과 다른 점이 있다면 캐싱 효과가 나타난다는 점이다.
 - 스칼라 서브쿼리에는 치명적인 제약이 하나 있다. 두 개 이상의 값을 반환할 수 없다는 제약이다.

```oracle-sql
select c.고객번호, c.고객명
    ,(select avg(거래금액), min(거래금액), max(거래금액)
      from  거래
      where 거래일시 >= trunc(sysdate, 'mm')
      and 고객번호 = c.고객번호)
from 고객 c
where c.가입일시 >= trunc(add_months(sysdate, -1) , 'mm')

```

 - 위 쿼리와 같이 작성할 수 없다. 부분범위 처리 가능하다는 슼칼라 서브쿼리 장점을 이용하고 싶을 때 고민이 생기게 된다.

```oracle-sql
select c.고객번호, c.고객명
    ,(select avg(거래금액) from 거래 where 거래일시 >= trunc(sysdate, 'mm') and 고객번호 = c.고객번호)
    ,(select min(거래금액) from 거래 where 거래일시 >= trunc(sysdate, 'mm') and 고객번호 = c.고객번호)
    ,(select max(거래금액) from 거래 where 거래일시 >= trunc(sysdate, 'mm') and 고객번호 = c.고객번호)
      from  거래
      where 거래일시 >= trunc(sysdate, 'mm')
      and 고객번호 = c.고객번호)
from 고객 c
where c.가입일시 >= trunc(add_months(sysdate, -1) , 'mm')
```

- 그렇다고 위처럼 작성하게 되면 거래 테이블에서 같은 데이터를 반복해서 읽는 비효율이 생긴다.

```oracle-sql
select 고객번호, 고객명
    , to_number(substr(거래금액, 1, 10))    평균거래금액
    , to_number(substr(거래금액, 11, 10))   최소거래금액
    , to_number(substr(거래금액, 21))       최대거래금액
    from ( 
      select c.고객번호, c.고객명
    ,(select lpad(avg(거래금액), 10) || lpad(min(거래금액), 10) || max(거래금액)
      from  거래
      where 거래일시 >= trunc(sysdate, 'mm')
      and 고객번호 = c.고객번호) 거래금액
from 고객 c
where c.가입일시 >= trunc(add_months(sysdate, -1) , 'mm')
)
```

 - SQL 튜너들은 위와 같은 방식을 전통적으로 사용해왔다.
 - 구하는 값들을 문자열로 모두 결합하고 바깥쪽 액세스 쿼리에서 substr 함수로 다시 분리하는 방식이다.

```oracle-sql
create or replace type 거래금액_T as object 
( 평균거래금액 number, 최소거래금액 number, 최대거래금액 number)
/

select 고객번호, 고객명
    , 거래.금액.평균거래금액, 거래.금액.최소거래금액, 거래.금액.최대거래금액
from (
    select c.고객번호, c.고객명
    ,(select 거래금액_T( avg(거래금액), min(거래금액), max(거래금액) ) 금액
      from  거래
      where 거래일시 >= trunc(sysdate, 'mm')
      and 고객번호 = c.고객번호) 거래
    from 거래
    where 거래일시 >= trunc(sysdate, 'mm')
    and 고객번호 = c.고객번호) 거래
where c.가입일시 >= trunc(add_months(sysdate, -1) , 'mm')

)
```

 - 위처럼 오브젝트 TYPE을 사용하는 방법도 있으나, TYPE을 미리 선언해 두어야 하는 불편함 떄문에 잘 쓰이지 않는다.

 - 두 개 이상의 값을 반환하고 싶을 때, 인라인 뷰를 사용하면 편하긴 하다.

```oracle-sql
select c.고객번호, c.고객명, t.평균거래, t.최소거래, t.최대거래
from 고객 c
    ,(select 고객번호, avg(거래금액) 평균거래
        , min(거래금액) 최소거래, max(거래금액) 최대거래
      from  거래
      where 거래일시 >= trunc(sysdate, 'mm')
      group by 고객번호) t
where c.가입일시 >= trunc(add_months(sysdate, -1) , 'mm')
and t.고객번호(+) = c.고객번호

Execution Plan
--------------------------------------------------
.....
```

- 위는 인라인 뷰를 사용한 예시이다.
- 뷰를 사용하면 (뷰가 머징되지 않았을 때) 댱월 거래 전체를 읽어야 하거나 위에선 실행 계획을 기입하지 않았지만 실행 계획에서 뷰가 머징 되는 부분이 있다. 
- 실행 계획에서 뷰가 머징 되었는지 확인 하는 방법은 실행 계획상 VIEW가 없으면 머징이 된 것이다. 책에선 실행 계획에 VIEW가 없다.
- 뷰가 머징될 때 Group By 때문에 부분범위 처리가 안 되는 문제가 있다. 인라인 뷰를 사용했을 때 어떤 장단점이 있는지는 4절 3항(4.4.3) 뷰와 조인에서 설명이 됐다.
- SQL 튜너들이 두 개 이상의 값을 반환해야 할 때 스칼라 서브쿼리와 인라인 뷰 사이에서 많은 고민을 했고 11g 이후로 조인 조건 Pushdown 기능이 동작하기에 인라인 뷰를 편히 사용할 수 있다.
- 
>머징이 머징ㅋㅋㅋ
> 
> 앞서 설명이 되었을 수 있지만...
> 
> “뷰 머징(View Merging)”은 SQL 옵티마이저가 인라인 뷰(또는 서브쿼리) 를 메인 쿼리에 합쳐서 하나의 쿼리로 최적화하는 과정이다.
뷰 머징이 일어나면 인라인 뷰는 더 이상 독립적으로 실행되지 않고 메인 쿼리의 실행 계획 속으로 흡수돼서 실행된다.

### (5) 스칼라 서브쿼리 Unnesting
 - 스칼라 서브쿼라도 NL 방식으로 조인하므로 캐싱 효과가 크지 않으면 랜덤 I/O 부담이 있다. 그래서 다른 조인 방식을 선택하기 위해 스칼라 서브쿼리를 일반 조인문으로 변환하고 싶을 때가 있다.
 - 특히, 병렬 쿼리에선 될 수 있으면 스칼라 서브쿼리를 사용하지 않아야 한다. 대량 데이터를 처리하는 병렬 쿼리는 해시 조인으로 처리해야 효과적이기 때문이다.
 - 어떤 이유에서건 사용자가 직접  쿼리를 변환해야 하는 상황에서 길고 복잡한 스칼라 서브쿼리를 만나면 한숨부터 나온다고 한다.
 - 오라클 12c부터 스칼라 서브쿼리도 Unnesting이 가능해졌다. 옵티마이저가 사용자 대신 자동으로 쿼리를 변환해 주는 것이다.
 - 해당 기능 떄문에 곤욕을 치르는 경우도 있는데, 대개 _Optimizer_unnest_scalar_sq 파라미터를 false로 설정함으로써 일단 문제를 해결하지만 장기적으로 이 기능을 쓸지 말지는 시스템 특성에 따라 고민해야 한다.
 - 이 파라미터를 true로 설정하면, 스칼라 서브쿼리를 Unnesting 할지 여부를 옵티마이저가 결정한다. false로 설정시 옵티마이저가 이 기능을 사용하지 않지만 사용자가 unnest 힌트로 유도할 순 있다.
 - 스칼라 서브쿼리를 Unnesting 하면 스칼라 서브쿼리인데도 NL 조인이 아닌 해시 조인으로 실행될 수 있는데 이때 이유는 Unnesting 되기 때문이다.
```oracle-sql
SELECT c.고객번호,
       (SELECT SUM(거래금액)
          FROM 거래 t
         WHERE t.고객번호 = c.고객번호)
FROM 고객 c;
```
- 이 스칼라 서브쿼리를 Unnesting 하면 

```oracle-sql
SELECT c.고객번호, SUM(t.거래금액)
FROM 고객 c
LEFT JOIN 거래 t ON t.고객번호 = c.고객번호
GROUP BY c.고객번호;
``` 
 - 위처럼 평탄화 된다. 이후 옵티마이저는 스칼라 서브쿼리 대신 조인 전략을 자유롭게 선택할 수 있게 된다.
 - UNNEST와 merge 힌트를 같이 사용했을 경우 UNNEST 힌트로 서브쿼리를 조인 형태로 변환하도록 강제하고 MERGE 힌트로 인라인 뷰를 외부 쿼리와 병합해서 하나의 쿼리로 최적화하도록 강제할 수 있다.
 - 12c부터 옵티마이저가 스칼라 서브쿼리를 자동으로 Unnesting 하면서 조인 순서나 조인 방식이 바뀌어 논리적으로는 같은 쿼리인데 결과가 달라지는 일이 발생하고 중복 계산이나 누락된 결과가 발생할 수 있었다.
   기존 스칼라 서브쿼리가 NL 방식 실행에서 자동 Unnesting을 통해 옵티마이저가 해시 조인이나 머지 조인으로 바꾸기도 하며 기존보다 많은 I/O가 발생하는 문제가 생기기도 한다.
 - 12c 업그레이드 이후 스칼라 서브쿼리 Unnesting을 통해 일부 쿼리가 문제가 생겼을때, _Optimizer_unnest_scalar_sq 파라미터를 false로 설정하지 않고 no_unnest 힌트를 통해 문제를 부분적으로 해결할 수 있다.

```oracle-sql
select c.고객번호, c.고객명
    ,(select /*+ no_unnest */ round(avg(거래금액), 2) 평균거래금액
      from  거래
      where 거래일시 >= trunc(sysdate, 'mm')
      and 고객번호 = c.고객번호)
from 고객 c
where c.가입일시 >= trunc(add_months(sysdate, -1) , 'mm')
```
 - DB 전체 영향을 주는 파라미터 변경 보단 문제가 되는 쿼리에 한해 no_unnest 힌트를 통해 부분적으로 해결하기도 한다.