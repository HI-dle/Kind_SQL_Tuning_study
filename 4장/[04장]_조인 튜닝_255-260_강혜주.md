# 4.1 NL 조인

- 인덱스를 이용한 조인
- 소트 머지 조인, 해시 조인도 프로세싱 과정은 다르지 않으며, 어떤 자료구를 사용하느냐의 차이가 있을 뿐이다.

## 4.1.1 기본 메커니즘

- 아래와 같이 사원 테이블과 고객 테이블이 있다.
- 이 두테이블에서 1996년 1월 1일 이후 입사한 사원이 관리하는 고객데이터를 추출하는 프로그램을 작성해 보자.

![[4-1.png]]

```sql
select e.사원명, c.고객명, c.전화번호
from 사원 e, 고객 c
where e.입사일자 >= '19960101'
and c.관리사원번호 = e.사원번호
```

-  위와 같은 sql 을 작성하면 원하는 결과 집합을 쉽게 추출할 수 있지만, sql 탄생 전에는 두 테이블을 조인하는 프로그램을 개발자가 직접 작성해야 했다. 어떤 알고리즘을 사용하면 좋을까 ?

> 가장 쉽게 생각할 수 있는 방식은, 사원 테이블로부터 1996년 1월 1일 이후 입사한 사원을 찾아 '건건이' 고객 테이블에서 사원번호가 일치(사원.사원번호 = 고객.관리사원번호) 하는 레코드를 찾는것이다.
> ** 이것이 바로 Nested Loop 조인이 사용하는 알고리즘이다.**

```java
// C, JAVA
for (i = 0; i < 100; i++) {      // outer loop
    for (j = 0; j < 100; j++) {  // inner loop
        // Do Anything ...
    }
}
```

```sql
-- PL/SQL
for outer in 1..100 loop
    for inner in 1..100 loop
        dbms_output.put_line(outer || ' : ' || inner);
    end loop;
end loop;
```

NL 조인은 위 중첩 루프문과 같은 수행 구조를 사용한다.

- NL 조인이 데이터를 액세스 하는 순서
```sql
begin
    for outer in (
        select 사원번호, 사원명 
        from 사원 
        where 입사일자 >= '19960101'
    )
    loop  -- outer 루프: `사원` 테이블에서 조건(`입사일자 >= '19960101'`)에 맞는 각 행을 하나씩 읽음
        for inner in (
            select 고객명, 전화번호 
            from 고객 
            where 관리사원번호 = outer.사원번호
        )
        loop  -- inner 루프: outer에서 읽은 각 사원번호를 이용해 `고객` 테이블에서 `관리사원번호`가 같은 고객을 탐색.
            dbms_output.put_line(
                outer.사원명 || ' : ' || inner.고객명 || ' : ' || inner.전화번호
            );
        end loop;
    end loop;
end;

```

일반적으로 NL 조인은 Outer와 Inner 양쪽 테이블 모두 인덱스를 이용한다.
Outer 테이블은 Table Full Scan을 하더라도 한번에 그치기 때문에 사이즈가 크지 않으면 인덱스를 이용하지 않을 수 있지만, Inner 쪽 테이블은 인덱스를 사용해야 한다.

그렇지 않으면 아래 그림과 같이 Outer 루프에서 읽은 건수만큼 Table Full Scan을 반복하기 때문이다.

![[4-2.png]]
결국 NL조인은 `인덱스를 이용한 조인방식` 이라고 할 수 있다.

![[4-3.png]]

1.  사원 X1 인덱스에서 입사일자 >= ‘19960101’ 인 첫 번째 레코드를 찾는다.
2. 인덱스에서 읽은 ROWID로 사원 테이블 레코드를 찾아간다.
3.  사원 테이블에서 읽은 사원번호 ‘0006’으로 고객 X1 인덱스를 탐색한다.
4. 고객 X1 인덱스에서 읽은 ROWID로 고객 테이블 레코드를 찾아간다.

![[4-4.png]]

5. 고객 X1 인덱스에서 한 건 더 스캔하고 관리사원번호가 ‘0006’ 임을 확인한다.
6. 고객 X1 인덱스에서 읽은 ROWID로 고객 테이블 레코드를 찾아간다.  
   (고객 X1 인덱스에서 한 건 더 스캔하고는 관리사원번호가 ‘0006’보다 크므로 거기서 인덱스 스캔을 멈춘다.)

![[4-5.png]]

7.  사원 X1 인덱스에서 한 건 더 스캔해서 입사일자가 ‘19960712’ 인 레코드를 읽는다.
8.  인덱스에서 읽은 ROWID로 사원 테이블 레코드를 찾아간다.
9. 사원 테이블에서 읽은 사원번호 ‘0003’으로 고객 X1 인덱스를 탐색한다.
10. 고객 X1 인덱스에서 읽은 ROWID로 고객 테이블 레코드를 찾아간다.

![[4-6.png]]

11. 고객 X1 인덱스에서 한 건 더 스캔하고 관리사원번호가 ‘0003’임을 확인한다.
12. 고객 X1 인덱스에서 읽은 ROWID로 고객 테이블 레코드를 찾아간다.  
    (고객 X1 인덱스에서 한 건 더 스캔하고는 관리사원번호가 ‘0003’보다 크므로 인덱스 스캔을 멈춘다.)

>사원 X1 인덱스에서 입사일자가 >= ‘19960101’인 모든 레코드에 대해 같은 과정을 반복한다.
>뒤에서 설명하는 소트 머지 조인과 해시 조인도 각각 Sort Area와 Hash Area에 가공해 둔 데이터를 이용한다는 점만 다를 뿐, 기본적인 조인 프로세싱은 다르지 않다.