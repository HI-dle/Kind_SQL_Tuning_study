# 조인 튜닝

---

### 4.1.2 NL 조인 실행계획 제어

```oracle-sql
Execution Paln
------------------------------------------------
0       select statement optimizer=ALL_ROWS
1   0       Nested loops
2   1           Table access (by index rowid) of '사원' (Table)
3   2            index (range scan) of '사원_x1' (index)
4   3           Table access (by index rowid) of '고객' (Table)
5   4            index (range scan) of '고객_x1' (index)
```

 - 위 는 NL 조인 실행계획이다. 위쪽 사원 테이블 기준 아래쪽 고객 테이블과 NL 조인한다고 해석된다.
 - 각 테이블을 액세스할 때 인덱스를 이용한다는 사실도 실행계획에서 확인할 수 있다.

 - NL 조인 제어는 아래와 같다.
```oracle-sql
select /*+ ordered use_nl(c) */
        e.사원명, c.고객명, c.전화번호
from 사원 e, 고객 c
where e.입사일자 >= '19960101'
and c.관리사원번호 = e.사원번호
```

 - ordererd 힌트는 form 절에 기술한 순서대로 조인하라고 옵티마이저에 지시할 때 사용한다. use_nl 힌트는 NL 방식으로 조인하라고 지시할 떄 사용한다.
 - 위에서는 ordered와 use_nl(c) 힌트를 같이 사용했으므로 사원 테이블 기준으로 고객 테이블과 조인하라는 뜻이다.

```oracle-sql
select /*+ ordered use_nl(B) use_nl(C) use_hash(D) */ *
from A, B, C, D
where ...
```
 - 3개 이상의 테이블을 조인할땐 힌트를 위처럼 사용한다.
 - 해석하면 A -> B -> C -> D 순으로 조회하되 B와 조인할 때 그리고 이어서 C와 조인할 때는 NL 방식으로 하고 D와 조인할 땐 해시 방식으로 조인하란 뜻이다.
 - ordered 대신 leading 힌트를 사용할 수 있다. 이 힌트를 사용하면 FROM 절을 바꾸지 않고도 마음껏 순서를 제어할 수 있어 편리하다.

```oracle-sql
select /*+ leading(C, A, D, B) use_nl(A) use_nl(D) use_hash(B) */ *
from A, B, C, D
where ...
```

- 다음은 ordered나 leading 힌트를 기술하지 않고 4개 테이블을 NL 방식으로 조인하되 순서는 옵티마이저가 스스로 정하도록 맡긴 것을 확인해보자.
```oracle-sql
select /*+ use_nl(A, B, C, D) */ *
from A, B, C, D
where ...
```



### 4.1.3 NL 조인 수행 과정 분석
- 간단히 조인문을 통해 NL 조인의 기본 알고리즘과 이를 제어하는 힌트 사용법까지 알아보았다.
- 좀 더 자세한 NL 조인 수행 과정을 분석하기 위해 조건절을 추가해서 확인해보자.

```oracle-sql
select /*+ ordered use_nl(c) index(e) index(c) */
from 사원 e, 고객 c
where c.관리사원번호 = e.사원번호 ---1
and e.입사일자 >= '19960101' ---2
and e.부서코드 = 'Z123' ---3
and c.최종주문금색 >= 20000 ---4
```

- 인덱스 구성은 다음과 같다.
```oracle-sql
* 사원_PK : 사원번호
* 사원_X1 : 입사일자
* 고객_PK : 고객번호
* 고객_X1 : 관리사원번호
* 고객_X2 : 최종주문금액
```

 - 두 테이블에 index 힌트를 명시했으므로 둘 다 인덱스를 이용해서 액세스한다. 인덱스명은 명시하지 않았으므로 어떤 인덱스를 사용할지 옵티마이저가 결정한다.
 - 조건절 비교 순서와 함께 위 다섯 개 인덱스 중 어떤 것이 사용될지도 고민해 봐야한다.
 - 조건절 비교 순서와 인덱스를 찾았다면 힌트에 지시한대로 SQL문을 수행했을 때 실행 계획을 확인하게 되면 위 쿼리 기준 인덱스는 사원_X1과 고객_X1인 것을 알 수 있다.

 - 조건절 옆 번호 기준 조건절 비교 순서를 나열하면 2->3->1->4 순이다.

1. 조건절 번호 2: 입사일자 >= '19960101' 조건을 만족하는 레코드를 찾으려고 사원_X1 인덱스를 Range 스캔한다.
2. 조건절 번호 3: 사원_X1 인덱스에서 읽은 ROWID로 사원 테이블을 액세스해서 부서코드 'Z123' 필터 조건을 만족하는지 확인한다.
3. 조건절 번호 1: 사원 테이블에서 읽은 사원번호 값으로 조인 조건을 만족하는 고객 쪽 레코드를 찾으려고 고객_X1 인덱스를 Range 스캔한다.
4. 조건절 번호 4: 고객_X1 인덱스에서 읽은 ROWID로 고객 테이블을 액세스해 최종주문금액 >= 20000 필터 조건을 만족하는지 확인한다.

 - 여기서 기억할 점은 각 단계를 모두 환료하고 다음 단계로 넘어가는게 아닌 한 레코드씩 순차적으로 진행한다는 사실이다.

![그림_4_7.png](image%2F%EA%B7%B8%EB%A6%BC_4_7.png)

 - 위 그림에서 숫자를 1부터 따라가다보면 NL 조인의 수행 절차를 알 수 있다.
 - 11, 19, 31, 32는 one-plus 스캔을 표시한 것이고 (O)는 테이블 필터 조건에 의해 레코드가 걸러지지 않는 것을 의미하고 (X)는 반대로 필터 조건에 의해 걸러진 것을 의미한다.


