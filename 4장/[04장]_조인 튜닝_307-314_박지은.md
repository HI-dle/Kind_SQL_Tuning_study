## ROWNUM - 잘 쓰자.

### 쿼리1: ROWNUM 사용
- ROWNUM: 조건절을 만족하는 레코드를 지정한 개수(n)만큼 찾고 나면, 조건 필터링을 더 진행하지 않고 멈추게 하고 싶을 때 사용

```sql
SELECT 글번호, 제목, 작성자, 등록일시
FROM 게시판
WHERE 게시판구분 = '공지'
  AND 등록일시 >= TRUNC(SYSDATE - 1)
  AND ROWNUM <= :n;
```

- (5장에서 확인) **ROWNUM**을 잘 사용하면 쿼리 성능을 높이는 데 아주 효과적
- 반면, 잘못 사용하면 쿼리 성능을 떨어뜨리기도 한다.
  - 특히 병렬 쿼리나 서브쿼리에 **ROWNUM**을 사용하는 경우가 대표적임

### 쿼리2: **EXISTS**와 의미 중복

- `EXISTS`: 매칭되는 데이터 존재 여부를 확인하는 연산자
  - 조건절을 만족하는 레코드를 만나는 순간 멈추는 기능을 이미 가짐
    - 즉, EXISTS 서브쿼리에 **ROWNUM** 조건까지 사용하면 의미가 중복됨
      ```sql
      SELECT 글번호, 제목, 작성자, 등록일시
      FROM 게시판 b
      WHERE 게시판구분 = '공지'
        AND 등록일시 >= TRUNC(SYSDATE - 1)
        AND EXISTS (
          SELECT 'x'
          FROM 수신대상자
          WHERE 글번호 = b.글번호
            AND 수신자 = :memb_no
            AND ROWNUM <= 1
        );
      ```
> “중복한다고 뭐가 문제일까?: 실제로 성능에 문제를 일으킬 수 있다.
>
> 서브쿼리를 **Unnesting** 하면 필터 오퍼레이션보다 더 좋은 실행 경로를 찾을 가능성이 커진다.
> 
> 그런데 서브쿼리에 **ROWNUM**을 사용하면 이 중요한 **옵티마이징 기능**을 막는 부작용이 있다.
> 
> 서브쿼리 Unnesting을 방지하는 공식 힌트인 `NO_UNNEST`가 따로 있는데도 SQL 튜너들이 **ROWNUM**을 자주 쓰는 것은, **ROWNUM**이 그만큼 강력하기 때문이다.

### 쿼리 3: Unnesting을 막는 ROWNUM
```sql
SELECT 글번호, 제목, 작성자, 등록일시
FROM 게시판 b
WHERE 게시판구분 = '공지'
  AND 등록일시 >= TRUNC(SYSDATE - 1)
  AND EXISTS (
    SELECT /*+ UNNEST NL_SJ */ 'x'
    FROM 수신대상자
    WHERE 글번호 = b.글번호
      AND 수신자 = :memb_no
      AND ROWNUM <= 1
  );
```
- 서브쿼리에 사용한 힌트는 전혀 작동하지 않는다.
  - rownum 조건때문에 Unnesting 불가능(**NL 세미조인**이 작동하려면 서브쿼리가 Unnesting 필요)

**ROWNUM**은 이처럼 옵티마이저를 꼼짝 못 하게 하는 강력한 독이 될 수 있으므로,
(서브쿼리 Unnesting을 방지하려는 목적이 아니라면) 서브쿼리에 함부로 사용하지 않는다.


## 서브쿼리 Pushing

- **Unnesting** 되지 않은 서브쿼리는 
  - 항상 **필터(Filter)** 방식으로 처리
  - 대개 실행계획 상에서 **맨 마지막 단계**에 처리

### ex. 상품과 주문 테이블을 조인 

#### 조인 후, 서브쿼리 필터링
```sql
SELECT /*+ LEADING(p) USE_NL(t) */ 
       COUNT(DISTINCT p.상품번호), SUM(t.주문금액)
FROM 상품 p, 주문 t
WHERE p.상품번호 = t.상품번호
  AND p.등록일시 >= TRUNC(ADD_MONTHS(SYSDATE, -3), 'mm')
  AND t.주문일시 >= TRUNC(SYSDATE - 7)
  AND EXISTS (
    SELECT 'x'
    FROM 상품분류
    WHERE 상품분류코드 = p.상품분류코드
      AND 상위분류코드 = 'AK'
  );
```

- 트레이스 결과
  | Call      | Count | CPU Time  | Elapsed Time | Disk    | Query     | Current | Rows  |
  | --------- | ----- | --------- | ------------ | ------- | --------- | ------- | ----- |
  | Parse     | 1     | 0.000     | 0.000        | 0       | 0         | 0       | 0     |
  | Execute   | 1     | 0.000     | 0.000        | 0       | 0         | 0       | 0     |
  | Fetch     | 2     | 0.484     | 3.493        | 650     | 38103     | 0       | 1     |
  | **Total** | **4** | **0.484** | **3.493**    | **650** | **38103** | **0**   | **1** |

  ```sql 
  Rows Row Source Operation
  0    STATEMENT
  1    SORT AGGREGATE (cr=38103 pr=650 pw=0 time=3493306 us) -- 1
  3000     FILTER (cr=38103 pr=650 pw=0 time=3486253 us) -- 2
  60000     NESTED LOOPS (cr=38097 pr=650 pw=0 time=3602032 us) -- 3,4
  1000       TABLE ACCESS FULL 상품 (cr=95 pr=0 pw=0 time=342023 us) -- 5
  60000       TABLE ACCESS BY INDEX ROWID (cr=38002 pr=650 pw=0 time= ··. )
  60000         INDEX RANGE SCAN 주문_PK (cr=2002 pr=90 pw=0 time=964606 us)
  1       TABLE ACCESS BY INDEX ROWID 상품분류 (cr=6 pr=0 pw=0 time=78 us)
  3         INDEX UNIQUE SCAN 상품분류_PK (cr=3 pr=0 pw=0 time=36 us)
  ```

- 상품으로부터 주문 테이블로 1,000번의 조인 액세스 --5
- 조인에 성공한 주문 데이터는 60,000개 --3
- 조인 과정에서 38,097개 블록을 읽었고,  --4
- 서브쿼리 필터링을 거쳐 3,000개로 줄었다. --2
- 총 읽은 블록 수는 38,103 이다. --1 

대부분의 I/O가 조인 과정에서 발생

> 서브쿼리 필터링을 먼저 수행하여 조인 단계로 넘어가는 로우 수를 줄일 수 있다면, 성능은 크게 향상된다.

#### 조인 전, 서브쿼리 필터링 먼저
아래는 주문 테이블과 조인하기 전에 서브쿼리 필터링을 먼저 수행한 경우다.
- 이를 위해 `PUSH_SUBQ` 힌트 사용

```sql
SELECT /*+ LEADING(p) USE_NL(t) */ 
       COUNT(DISTINCT p.상품번호), SUM(t.주문금액)
FROM 상품 p, 주문 t
WHERE p.상품번호 = t.상품번호
  AND p.등록일시 >= TRUNC(ADD_MONTHS(SYSDATE, -3), 'mm')
  AND t.주문일시 >= TRUNC(SYSDATE - 7)
  AND EXISTS (
    SELECT /*+ NO_UNNEST PUSH_SUBQ */ 'x'
    FROM 상품분류
    WHERE 상품분류코드 = p.상품분류코드
      AND 상위분류코드 = 'AK'
  );
```
- 트레이스 결과
  | Call      | Count | CPU Time  | Elapsed Time | Disk  | Query    | Current | Rows  |
  | --------- | ----- | --------- | ------------ | ----- | -------- | ------- | ----- |
  | Parse     | 1     | 0.000     | 0.000        | 0     | 0        | 0       | 0     |
  | Execute   | 1     | 0.000     | 0.000        | 0     | 0        | 0       | 0     |
  | Fetch     | 2     | 0.125     | 0.129        | 0     | 1903     | 0       | 1     |
  | **Total** | **4** | **0.125** | **0.129**    | **0** | **1903** | **0**   | **1** |

```sql
Rows | Row Source Operation
   0    STATEMENT
   1      SORT AGGREGATE (cr=1903 pr=0 pw=0 time=128934 us) --1
3000       NESTED LOOPS (cr=1903 pr=0 pw=0 time=153252 us)
 150        TABLE ACCESS FULL 상품 (cr=101 pr=0 pw=0 time=18230 us) --2
   1          TABLE ACCESS BY INDEX ROWID 상품분류 (cr=6 pr=0 pw=0 time=135 us)
   3            INDEX UNIQUE SCAN 상품분류_PK (cr=3 pr=0 pw=0 time=63 us)
3000          TABLE ACCESS BY INDEX ROWID (cr=1802 pr=0 pw=0 time=100092 us) --3
3000            INDEX RANGE SCAN 주문_PK (cr=302 pr=0 pw=0 time=41733 us)
```

- 서브쿼리 필터링 결과가 150건  -- 2
  - ➡️주문 테이블과의 조인 횟수도 150번으로 줄었음 
- 주문 데이터도 3,000건만 읽었다.  -- 3
- 총 읽은 블록 수도 1,903개로 감소했다. -- 1

### 정리
- **Pushing 서브쿼리**: 서브쿼리 필터링을 가능한 한 앞 단계에서 처리하도록 강제하는 기능
  - `PUSH_SUBQ` / `NO_PUSH_SUBQ` 힌트로 제어
- 주의
  - 이 기능은 **Unnesting 되지 않은 서브쿼리**에만 작동한다.
    - 서브쿼리가 Unnesting 되면 필터가 아닌 다양한 조인 방식으로 실행되며, 이 경우 `PUSH_SUBQ` 힌트는 무용지물이 됨
    - 즉, `PUSH_SUBQ` 힌트는 항상 `NO_UNNEST` 힌트와 함께 기술하는 것이 올바른 사용법이다.

- 반대로, 서브쿼리 필터링을 가능한 한 **나중에** 처리하게 하려면 `NO_UNNEST`와 `NO_PUSH_SUBQ`를 함께 사용한다.

# 4.4.3 뷰(View)와 조인

최적화 단위는 **쿼리 블록**이므로, 옵티마이저가 뷰(View) 쿼리를 변환하지 않으면 뷰 쿼리 블록을 **독립적으로** 최적화한다.

## ex. 전월 이후에 가입한 고객들의 당월 거래 내역을 요약(평균, 최소, 최대)” 해서 조회
뷰를 독립적으로 최적화하려다 보니 “당월 거래 전체”를 읽어 고객번호 수준으로 `GROUP BY` 하는 실행계획을 수립하였다.

그 후 고객 테이블과 조인은 그 다음 단계에서 처리된다.

```sql
SELECT c.고객번호, c.고객명, t.평균거래, t.최소거래, t.최대거래
  FROM 고객 c
  ,(SELECT 고객번호, AVG(거래금액) 평균거래, MIN(거래금액) 최소거래, MAX(거래금액) 최대거래
      FROM 거래
     WHERE 거래일시 >= TRUNC(SYSDATE, 'mm') -- 당월 발생한 거래 -> 인라인 뷰 안쪽 조건
     GROUP BY 고객번호) t
WHERE c.가입일시 >= TRUNC(ADD_MONTHS(SYSDATE, -1), 'mm') -- 전월 이후 가입 고객 -> 인라인 뷰 밖의 고객 테이블 조건
  AND t.고객번호 = c.고객번호;
```
- 서브쿼리
  - 대상 테이블: 거래
  - 역할: 각 고객별로 이번 달(TRUNC(SYSDATE, 'mm') 이후)의 거래 데이터를 집계.
  - 산출 컬럼:
    - 평균거래: 고객의 당월 거래금액 평균
    - 최소거래: 고객의 당월 거래금액 중 최소값
    - 최대거래: 고객의 당월 거래금액 중 최대값
  - 결과적으로 고객번호 단위의 거래 요약 데이터를 만듦.
- 실행계획
  ```sql
  ------------------------------------------------------------
  | Id | Operation                                           | Cost | Card | Bytes  |
  ------------------------------------------------------------
  |  0 | SELECT STATEMENT Optimizer=ALL_ROWS                 |  1M  | 1K   | 112K   |
  |  1 |  NESTED LOOPS                                       |      |      |        |
  |  2 |   NESTED LOOPS                                      |  1M  | 1K   | 112K   |
  |  3 |    VIEW                                             |  2K  | 427K | 21M    |  ← 인라인 뷰 (거래 요약)
  |  4 |     HASH (GROUP BY)                                 |  2K  | 427K | 14M    |
  |  5 |      TABLE ACCESS (BY INDEX ROWID) OF '거래' (TABLE) |  2K  |      |        |
  |  6 |       INDEX (RANGE SCAN) '거래_X01' (INDEX)          | 988  | 427K |        |
  |  7 |    INDEX (RANGE SCAN) '고객_X01' (INDEX)             |  1   | 190  |        |  ← 고객 테이블 접근 (뷰 밖)
  |  8 |   TABLE ACCESS (BY INDEX ROWID) '고객' (TABLE)       |  3   | 1    |        |
  ------------------------------------------------------------
  ```

- 문제: 고객 테이블에서 ‘전월 이후 가입한 고객’을 필터링하는 조건이 인라인 뷰 **바깥에** 있음
  - ➡️ 인라인 뷰 안에서는 당월에 거래한 **모든 고객의 거래 데이터**를 읽어야 한다.

### 뷰를 메인 쿼리와 Merging
아래는 `MERGE` 힌트를 이용해 뷰를 메인 쿼리와 **머징(Merging)** 하도록 한 예시다.
- 뷰 머징을 방지하고자 할 때는 `NO_MERGE` 힌트를 사용한다.

```sql
SELECT c.고객번호, c.고객명, t.평균거래, t.최소거래, t.최대거래
  FROM 고객 c
    ,(SELECT /*+ MERGE */ 고객번호, AVG(거래금액) 평균거래, MIN(거래금액) 최소거래, MAX(거래금액) 최대거래
        FROM 거래
       WHERE 거래일시 >= TRUNC(SYSDATE, 'mm')
       GROUP BY 고객번호) t
 WHERE c.가입일시 >= TRUNC(ADD_MONTHS(SYSDATE, -1), 'mm')
   AND t.고객번호 = c.고객번호;
```
```sql
------------------------------------------------------------
| Id | Operation                               | Cost | Card | Bytes |
------------------------------------------------------------
|  0 | SELECT STATEMENT Optimizer=ALL_ROWS     |   4  |   1  |   27  |
|  1 |  HASH (GROUP BY)                        |   4  |   1  |   27  |
|  2 |   NESTED LOOPS                          |   3  |   5  |  135  |
|  3 |    TABLE ACCESS (BY INDEX ROWID) '고객'  |   2  |   1  |   —   |  ← 고객 테이블 접근
|  4 |     INDEX (RANGE SCAN) '고객_X01'        |   1  |   1  |   —   |  ← 고객 조건 필터
|  5 |    TABLE ACCESS (BY INDEX ROWID) '거래'  |   1  |   5  |   —   |  ← 거래 테이블 접근
|  6 |     INDEX (RANGE SCAN) '거래_X02'        |   0  |   5  |   —   |  ← 거래 조건 필터
------------------------------------------------------------
```

실행계획을 토대로 아래와 같이 변환되었다는 것을 알 수 있다.
```sql
select c.고객번호, c.고객명, avg(t. 거래금액) 평균거래, min(t.거래금액) 최소거래, max(t. 거래금액) 최대거래
 from 고객 c, 거래 t
 where c.가입일시 >= trunc(add_months(sysdate, -1), 'mm')
   and t. 고객번호 = c. 고객번호
   and t. 거래일시 >= trunc(sysdate, 'mm')
 group by c.고객번호, c.고객명
```

- `고객_X01` 인덱스(가장 먼저 액세스): **가입일시**가 선두 컬럼
  - 인덱스를 Range Scan.
- `거래_X02` 인덱스는 `(고객번호 + 거래일시)` 순으로 구성돼 있어야 최적

#### 실행계획 분석
1. 고객 테이블을 먼저 읽는다.
   - 인덱스를 이용해 전월 이후 가입한 고객만 읽는다.
2. 거래 테이블과 조인할 때는 해당 고객들에 대한 **당월 거래**만 읽는다.

인덱스(여기서는 거래 테이블 `(고객번호 + 거래일시)` 순 구성)를 이용하는 **NL 방식 조인**이기 때문에 가능한 일이다.

- 단점
  - 조인에 성공한 전체 집합을 `GROUP BY` 하고 나서야 데이터를 출력할 수 있다.
    - ➡️ **부분범위 처리**가 불가능!
      - 만약 전월 이후 가입한 고객이 매우 많고 당월 거래도 많다면, 부분범위 처리가 불가능한 상황에서 **NL 조인**은 좋은 선택이 아님 
      - 이런 상황은 **해시 조인(Hash Join)** 이 보통 빠르다.

### 해시 조인 후 GROUP BY

- 뷰를 머징한 거래 테이블을 고객과 해시 조인한 후 `GROUP BY` 하는 실행계획

물론 고객과 거래 테이블을 읽는 과정에 각각 인덱스를 사용할 수도 있다.

```sql
Execution Plan

SELECT STATEMENT Optimizer=ALL_ROWS (Cost=8 Card=1 Bytes=27)
  HASH (GROUP BY) (Cost=8 Card=1 Bytes=27)
    HASH JOIN (Cost=7 Card=5 Bytes=135)
      TABLE ACCESS (FULL) OF '고객' (TABLE) (Cost=3 Card=1 Bytes=20)
      TABLE ACCESS (FULL) OF '거래' (TABLE) (Cost=3 Card=14 Bytes=98)
```

## 조인 조건 Pushdown

- Pushdown: 메인 쿼리를 실행하면서 **조인 조건절 값을 건건이 뷰 안으로 밀어 넣는 기능**
  - Oracle 11g 이후로 ‘조인 조건 Pushdown’이라는 쿼리 변환 기능 추가
  - 힌트: `PUSH_PRED`

```sql
select c.고객번호, c. 고객명, t. 평균거래, t. 최소거래, t.최대거래
  from 고객 c
    ,(select /*+ no_merge push_pred */ 고객번호, avg(거래금액) 평균거래, min(거래금액) 최소거래, max(거래금액) 최대거래
        from 거래
       where 거래일시 >= trunc(sysdate, 'mm')
       group by 고객번호) t
where c. 가입일시 >= trunc(add_months(sysdate, -1), 'mm')
and t. 고객번호 = c.고객번호
```
실행계획의 `VIEW PUSHED PREDICATE` 오퍼레이션을 통해 이 기능의 작동 여부를 확인할 수 있다.
```sql
Execution Plan
-----------------------------------------------------------
SELECT STATEMENT Optimizer=ALL_ROWS (Cost=4 Card=1 Bytes=61)
  NESTED LOOPS (Cost=4 Card=1 Bytes=61)
    TABLE ACCESS (BY INDEX ROWID BATCHED) OF '고객' (TABLE) (Cost=2 … )
        INDEX (RANGE SCAN) OF '고객_X01' (INDEX) (Cost=1 Card=1)
    VIEW PUSHED PREDICATE (Cost=2 Card=1 Bytes=41)
      SORT (GROUP BY) (Cost=2 Card=1 Bytes=7)
        TABLE ACCESS (BY INDEX ROWID BATCHED) OF '742H' (TABLE) (Cost=2 .. )
          INDEX (RANGE SCAN) OF '거래_X02' (INDEX) (Cost=1 Card=5)
```

- 해당 방식으로, 전월 이후 가입한 고객을 대상으로 **건건이 당월 거래 데이터만** 읽어서 조인하고 `GROUP BY`를 수행
- 중간에 멈출 수도 있으므로, **부분범위 처리**가 가능하다.
- 뷰를 독립적으로 실행할 때처럼 당월 거래를 모두 읽을 필요도 없다.
- 뷰를 머징할 때처럼 조인에 성공한 전체 집합을 `GROUP BY` 할 필요도 없다.


> 단, 옵티마이저가 뷰를 머징하면 힌트가 작동하지 않으므로,`NO_MERGE` 힌트를 함께 사용하는 습관이 필요
