# 3.4 인덱스 설계
> 인덱스 설계에 필요한 여러 가지 판단 기준, 공식을 초월한 전략적 설계의 필요성, 방법론 등을 설명

## 3.4.1 인덱스 설계가 어려운 이유
인덱스가 많으면 구체적으로 아래와 같은 문제가 생긴다.
- DML 성능 저하(-> TPS 저하)
- 데이터베이스 사이즈 증가(-> 디스크 공간 낭비)
- 데이터베이스 관리 및 운영 비용 상승

예를 들어 아래 그림처럼 테이블에 인덱스가 세 개 달려 있으면, 신규 데이터를 입력할 때마다 세 개 인덱스에도 데이터를 입력해야 한다.

![그림_3-45.png](image%2F%EA%B7%B8%EB%A6%BC_3-45.png)

인덱스는 정렬 상태를 유지해야 하므로 수직적 탐색을 통해 입력할 블록부터 찾는다. 찾은 블록에 여유 공간이 없으면 `인덱브 분할(index split)`도 발생한다.

> 💡 인덱스 분할
> 
> 만약 5번 블록에 데이터를 넣어야하는데, 공간이 없다면 `[5번 블록] - [새 블록] - [6번 블록]`과 같이 5,6번 블록 사이에 `새 블록을 끼워넣는다.`
> 
> 그리고 [5번 블록]에 공간을 만들어줘야하므로 `5번 블록에 저장된 데이터 중 뒤쪽 절반을 새 블록으로 옮긴다.`
> 
> 그리고 `5번 블록에 데이터를 넣는다.`

데이터를 지울 때도 마찬가지로, 세 개 인덱스에서 레코드를 일일이 찾아 지워줘야 한다.

핵심 트랜젝션이 참조하는 테이블에 대한 `DML 성능 저하는 TPS 저하로 이어진다.`

꼭 필요하지 않은 인덱스를 많이 만들면 `디스크 공간을 낭비`하고, `데이터베이스 사이즈가 커지는 만큼` 백업, 복제 재구성 등을 위한 `운영 비용도 상승한다.`

> 따라서 개별 쿼리 성능뿐만 아니라 인덱스 개수를 최소화하여 DML 부하를 줄여야 하므로 인덱스 설계가 어렵다.

---

## 진퇴양난 SQL 튜닝 - 개발 단계에서 최적 인덱스 설계의 중요성
- 인덱스 개수를 최소화하려면 기존 인덱스 구성을 변경해야한다.
  - 시스템 개발 단계에서는 비교적 쉽게 변경할 수 있지만, 운영 환경에서는 쉽지 않다.
- 그나마 신규 인덱스 추가는 비교적 영향도가 적다.
  - 하지만, 추가할수록 시스템 수준 TPS는 점점 나빠진다.

> 정리: `인덱스 추가는 시스템에 부하`를 주고, `인덱스 변경은 운영 리스크가 크다.` 따라서 시스템 개발 단계에서 인덱스를 최적으로 설계하는 일이 무엇보다 중요하다.
> 
> 특히 핵심 트랜잭션에서 데이터의 추가, 변경, 삭제가 발생한다면 SQL 튜닝 전문가를 통해 정교하게 설계해야 한다.
> 
> 자동화된 인덱스 설계 도구도 필요하다. 인덱스 설계도를 작성하려면 `각 테이블에 대한 액세스 경로를 모두 수집`해서 패턴별로 압축/정리해야하는데, 양이 수십만 개나 되기 때문에 시간과 노력이 많이 들어간다.
> 
> 따라서 `시간과 노력을 줄이기 위해서 자동화 도구가 필요하다.`

---
## 3.4.2 가장 중요한 두 가지 선택 기준
1. 조건절에 항상 사용하거나, 자주 사용하는 컬럼을 설정한다.
2. `'='` 조건으로 자주 조회하는 컬럼을 앞쪽에 둔다.

인덱스 스캔 방식 중 가장 정상적이고 일반적인 방식은 `Index Range Scan`이다.

이를 위해서는 인덱스 선두 컬럼을 조건절에 반드시 사용해야한다. 따라서 결합 인덱스를 구성할 때 첫번째 기준은 `조건절에 항상 사용하거나, 자주 사용하는 컬럼을 선정하는 것`이다.

두번째 기준은, 그렇게 선정한 컬럼 중 `'='` 조건으로 자주 조회하는 컬럼을 앞쪽에 두는 것이다.

---
## 3.4.3 스캔 효율성 이외의 판단 기준
> 방금 본 두 가지는 `스캔 효율성`이 판단 기준이였다. 방금 두 가지가 인덱스를 설계할 때 일반적으로 사용하는 기본 공식임에는 틀림없지만, 인덱스 설계가 그리 간단하지만은 않다.

따라서 `스캔 효율성` 외에 고려해야 할 판단 기준을 나열하면 아래와 같다.
- 수행 빈도
- 업무상 중요도
- 클러스터링 팩터
- 데이터량
- DML 부하(: 기존 인덱스 개수, 초당 DML 발생량, 자주 갱신하는 컬럼 포함 여부 등)
- 저장 공간
- 인덱스 관리 비용 등

> 판단 기준에 대한 해석은 설계자마다 달라서 결과물도 크게 달라진다.(전장에서 지휘관 스타일에 따라 결과가 달라지듯)

### 1. 이 중에서 `수행 빈도`는 가장 중요한 기준 중 하나이다.

- 자주 수행하지 않는 SQL이라면 인덱스 스캔 과정에 비효율이 있더라도 큰 문제가 아닐 수 있다.
- 반면, 수행빈도가 매우 높은 SQL에는 최적의 인덱스를 구성해줘야 한다.
- `수행 빈도`와 관련해, `NL 조인`할 때 어느 쪽에서 자주 액세스 되는지도 중요한 판단 기준이 된다.

> 아래 그림처럼 `NL 방식`으로 조인하는 두 테이블이 있을 때, 1번과 2번 중 어느 쪽 인덱스가 더 중요할까?
![그림_3-46.png](image%2F%EA%B7%B8%EB%A6%BC_3-46.png)
> 어느 쪽 인덱스가 더 중요한지 판별하기 위해, 우리는 아래와 같이 비교할 것이다.
> 
> - Outer 테이블의 인덱스가 비효율적
> - Inner 테이블의 인덱스가 비효율적
>   - 둘 중에 뭐가 더 치명적인가?

```java
// 💡 잠깐 짚고가기: NL 조인 메커니즘
for each outerRow in OUTER_TABLE {
    for each innerRow in INNER_TABLE where 조건(innerRow, outerRow) {
        output(joinResult)
    }
}
// 바깥 반복문의 대상이 Outer 테이블
// 안쪽 반복문의 대상은 Inner 테이블
// 즉, Outer 테이블에서 레코드를 먼저 도출한다음, 각 레코드에 대해 Inner 테이블에서 조건에 맞는 레코드를 찾는다.
```

예시로 아래 쿼리를 보겠다. 인덱스는 `[거래일자 + 거래구분코드]`이다.
```sql
SELECT /*+ leading(a) use_nl(b) (거래가 Outer 테이블, 상품이 Inner 테이블) */ 
       b.상품코드, b.상품명,
       a.고객번호, a.거래일자, a.거래량, a.거래금액
FROM 거래 a, 상품 b
WHERE a.거래구분코드 = 'AC'
  AND a.거래일자 BETWEEN '20090101' AND '20090131'
  AND b.상품번호 = a.상품번호
  AND b.상품번호 = '가전'
```

> 💡 거래(a)가 Outer, 상품(b)이 Inner
>
> : 거래(a)를 먼저 읽어서 조건에 맞는 레코드를 찾고, 거래(a)의 상품번호로 상품(b)를 찾는 NL 조인 수행 
> 
> 💡 인덱스가 [거래일자 + 거래구분코드]
> 
> : 인덱스를 [거래구분코드 + 거래일자]로 결정했을 때보다 비효율적이다. `a.거래구분코드 = 'AC'`로 먼저 등가 조건으로 빠르게 줄일 수 있기 때문

이제 지금 상황을 `NL 조인`관점에서 보자면, `Outer 테이블에서의 인덱스 비효율은 큰 문제가 되지 않는다.` 비효율이 있더라도, `그 과정을 1번만 수행하기 때문이다.`

반면에 아래와 같이, Inner 테이블의 인덱스가 `[거래일자 + 상품번호 + 거래구분코드]`로 비효율이 존재한다면?
```sql
SELECT /** leadling(b) use_nl(a) */
b.상품코드, b.상품명, a.고객번호, a.거래일자, a.거래량, a.거래금액
FROM 거래 a, 상품 b
WHERE a.거래구분코드 = ‘AC’
AND a.거래일자 BETWEEN ‘20090101’ AND ‘20090131’
AND b.상품번호 = a.상품번호
AND b.상품번호 = ‘가전’
```

Outer의 건수만큼 Inner 테이블을 접근해야하는데, 접근마다 비효율을 반복하게 되므로 치명적이다.

> 정리: Inner 쪽 인덱스가 매우 중요하기 때문에, Inner 쪽 인덱스는 `'='` 조건 컬럼을 선두에 두는 것이 중요하고, 될 수 있으면 테이블 액세스 없이 인덱스에서 필터링을 마치도록 구성해야한다.

---
### 2. `데이터량`도 인덱스를 설계할 때 중요한 판단 기준이다.
- 데이터량이 적다면 굳이 인덱스를 만들 필요가 없다.
  - 풀스캔도 충분히 빠르기 때문
  - 반대로, 인덱스를 많이 만든다해도 저장 공간이나 트랜잭션 부하 측면에서 그다지 문제될 것이 없다.
    - : 테이블이 작다면 심각하게 고민하지 않아도 된다.
- 초대용량 테이블이라면?
  - Insert도 많을 것 -> DML 발생량은 TPS에 영향을 준다.
  - 인덱스를 설계할 때 전문가의 손길이 필요하다.

---
## 3.4.4 공식을 초월한 전략적 설계
- 조건절 패턴이 여러개 있을 때, 패턴마다 인덱스를 만들 수는 없다.
- 가장 핵심적인 액세스 `경로 한두 개를 선택해서 최적 인덱스를 설계하고,`
- 나머지 액세스 경로는 `약간의 비효율이 있더라도 목표 성능을 만족하는 수준으로 인덱스를 구성할 수 있어야한다.`

> 아래는 예신데 크게 중요하진 않은 것 같다.
> 
> ![그림_3-47.png](image%2F%EA%B7%B8%EB%A6%BC_3-47.png)
> 앞 선택은 `'='` 조건절이고, 뒤 선택은 `BETWEEN` 연산자를 사용한다.

인덱스 스캔 효율을 위해 `24개의 인덱스 패턴을 모두 생성할 수는 없다.`

`일자/일시 조건을 선두에 두고, 자주 사용하는 필터 조건을 모두 뒤쪽에 추가하는 방식`으로 설계해보자.

- `X01`: 청약일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리점설계사 + 대리점지사
- `X02`: 보험개시일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리점설계사 + 대리점지사
- `X03`: 보험종료일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리점설계사 + 대리점지사
- `X04`: 데이터생성일시 + 취급부서 + 취급지점 + 취급자 + 대리점설계사 + 대리점지사

설계 이유는 아래와 같다.
- `가계약`은 주로 3일 이내 데이터를 조회한다. 어쩌다 한 달 치를 조회해도 사용자가 인내할 수 있는 수준이다.
- 인덱스 스캔 효율보다 테이블 액세스가 더 큰 부하요소이기 때문

물론, `BETWEEN 조건 연산자`를 사용하는 일자/일시가 선두컬럼인 점이 찝찝하다. 하지만 이 또한 이유가 있다.

`가계약` 테이블에서 가장 많이 사용하는 인덱스 패턴이 `[입력자 + 데이터생성일시]` 이었기 때문이라고한다.

따라서 아래와 같은 인덱스를 더 추가해주었다고 한다.
- `X05`: 입력자 + 데이터생성일시

> 결론: 
> 
> 공식대로 한다면 24개의 인덱스가 필요했겠지만, 업무 상황을 고려한 전략적 판단을 통해 인덱스를 5개로 줄였다.
> 
> 이렇게 인덱스 개수를 최소화하면, 사용빈도가 높거나 중요한 액세스 경로가 새로 도출됐을 때 인덱스를 추가할 여유도 생긴다.

---
## 3.4.5 소트 연산을 생략하기 위한 컬럼 추가
- 인덱스는 항상 정렬 상태이므로 `ORDER BY`, `GROUP BY`를 위한 소트 연산을 생략할 수 있게 해 준다.
- 따라서 조건절에 사용하지 않는 컬럼이라도 `소트 연산을 생략할 목적`으로 인덱스 구성에 포함시킴으로써 성능 개선을 도모할 수 있다.

```sql
select 계약ID, 청약일자, 입력자ID, 계약상태코드, 보험시작일자, 보험종료일자
from 계약
where 취급지점ID = :trt_brch_id
and 청약일자 between :sbcp_dt1 and :sbcp_dt2
and 입력일자 >= trunc(sysdate - 3)
and 계약상태코드 in ( :ctr_stat_cd1, :ctr_stat_cd2, :ctr_stat_cd3 )
order by 청약일자, 입력자ID
```
- 위 쿼리에서 소트 연산을 생략하려면 인덱스를 order by 절 순서대로 `[청약일자 + 입력자ID]`로 구성하면 된다.
- `'='` 조건절 컬럼은 order by 절에 없더라도 인덱스에 포함할 수 있다.(위치는 상관없다.)
  - `'='` 이 아닌 조건절 컬럼들은 반드시 order by 컬럼보다 뒤쪽에 두어야 소트 연산을 생략할 수 있다.(e.g [청약일자 + 입력자ID + 입력일자 + 계약상태코드])

이렇게 하면 소트연산은 생략할 수 있지만, 수평 탐색 중에 조건에 해당하는 데이터를 늦게 만난다면 `I/O`가 많이 발생하게 된다.

`I/O`를 최소화하면서도 소트 연산을 생략하려면 아래 공식을 따르면 된다.
- `'='` 연산자로 사용한 조건절 컬럼 선정
- `ORDER BY 절`에 기술한 컬럼 추가
- `'='` 이 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정

> 따라서 `[취급지점ID + 청약일자 + 입력자ID]` 순으로 구성.
> 
> 입력일자와 계약상태코드는 붙이거나 말거나다.(데이터가 적다면 붙이는게 테이블 랜덤 액세스를 줄일 수 있다.)

### IN 조건은 `'='`이 아니다.

```sql
select 고객번호, 고객명, 거주지역, 혈액형, 연령
from 고객
where 거주지역 = '서울'
and 혈액형 in ( 'A', 'O' )
order by 연령
```

위에서 `'='` 조건절 컬럼은 인덱스 앞쪽에 두어도 소트연산을 생략할 수 있다고 했다.

결론부터 말하면 `IN 절은 '=' 이 아니기 때문에 인덱스 앞쪽에 두어도 소트연산을 생략할 수 없다.`

예시를 보자. 인덱스는 아래 표처럼 `[거주지역 + 혈액형 + 연령]` 순으로 구성했다.

![표_3-3.png](image%2F%ED%91%9C_3-3.png)

만약 `IN 절이 '='로 동작한다면` 위 쿼리가 아래와 같은 방식으로 실행되어야한다.

```sql
select 고객번호, 고객명, 거주지역, 혈액형, 연령
from 고객
where 거주지역 = '서울'
and 혈액형 = 'A'

union all /* A형 조회 + O형 조회 */

select 고객번호, 고객명, 거주지역, 혈액형, 연령
from 고객
where 거주지역 = '서울'
and 혈액형 = 'O'

order by 연령
```

우리의 목적처럼 `order by 절이 있음에도 소트 연산이 생략되려면` A + O의 결과가 연령순으로 정렬돼야한다.

하지만 그것이 가능하려면 서울에 사는 모든 A형이 O형보다 나이가 적어야한다. `즉, 불가능 !!`

> 결론:
> 
> `IN 절`이 `'='` 로 동작되어서는 소트 연산을 생략할 수 없다.
> 
> -> 소트 연산을 생략하기 위해서는 `IN 절`을 `인덱스 액세스 조건으로 사용하면 안된다.`
> 
> -> 소트 연산을 생략하기 위해서는 `IN 절`은 `필터 조건으로 사용해야한다.` 
> 
> (e.g `[거주지역 + 연령 + 혈액형]`)