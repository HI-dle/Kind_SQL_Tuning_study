# 인덱스 튜닝

---

### 3.3.5 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율

 - 인덱스 스캔 효율성은 인덱스 컬럼을 조건절에 모두 등치 조건으로 사용할 떄가 가장 좋다.
 - 리프 블록을 스캔하면서 읽은 레코드는 하나도 걸러지지 않고 모두 테이블 액세스로 이어지므로 인덱스 스캔 단게에서 비효율은 전혀 없다.
 - 인덱스 컬럼 중 일부 가 조건절에 없거나 등치 조건이 아니더라도 그것이 뒤쪽 컬럼일 때는 비효율이 없다.

```oracle-sql
where 아파트시세코드 = :a
where 아파트시세코드 = :a and 평형 = :b
where 아파트시세코드 = :a and 평형 = :b and 평형타입 = :c
where 아파트시세코드 = :a and 평형 = :b and 평형타입 = :c between :c and :d
```

 - 위에서 인덱스를 아파트시세코드 + 평형 + 평형타입 + 인터넷매물 순으로 구성했을 때 조건절이 위와 같은 경우 위 조건은 모두 액세스 조건으로 사용된다.
 - 하지만 인덱스 선행 컬럼이 조건절에 없거나 부등호, Between, like 같은 범위검색 조건이면 인덱스를 스캔하는 과정에서 비효율이 생긴다.


![그림_3_32.png](image%2F%EA%B7%B8%EB%A6%BC_3_32.png)

```oracle-sql
select *
from 매물아파트매매
where 아파트시세코드 = 'A01011350900056'
and 평형 = '59'
and 평형타입 = 'A'
and 인터넷매물 between '1' and '3'
order by 입력일 desc
```
 - 위 조건을 만족하는 3개의 레코드를 스캔하는 과정을 도식화한 것이다.
- 인터넷매물이 between 조건이지만 선행 컬럼들이 모두 = 조건이기 때문에 전혀 비효율 없이 조건을 만족하는 3건을 빠르게 찾지만 맨 마지막 스캔은 조건을 만족하는 레코드가 더 없음을 확인하기 위한 one-plus 스캔이므로 불가피하다.
- 인덱스 선행 컬럼이 모두 = 조건일 때 필요한 범위만 스캔하고 멈출 수 있는 것은 조건을 만족하는 레코드가 모두 모여있기 때문이다.
- 만약 인덱스 구성을 인터넷매물 + 아파트시세코드 + 평형 + 평형타입 으로 한다면 인덱스 스캔 범위가 넓어진다.

![그림_3_33.png](image%2F%EA%B7%B8%EB%A6%BC_3_33.png)

- 인덱스 선두 컬럼 인터넷매물에 between을 사용하게 되었을 때 나저미 조건을 만족하는 레코드가 흩어진 것을 확인할 수 있다.따라서 조건을 만족하지 않는 레코드까지 스캔하고 버리는 비효율이 생긴다.
- 다행인 점은 인터넷매물 조건절의 시작 값인 1 구간에서는 전체를 다 읽지 않는 다는 것이고 

```oracle-sql
where 인터넷매물 = '1'
and 아파트시세코드 = 'A01011350900056'
and 평형 = '59'
and 평형타입 = 'A'
```
 - 위 조건을 만족하는 첫 번째 레코드부터 읽는다. between 조건 마지막 값인 3 구간에서도 전체를 다 읽지 않고 아래 조건절 보다 큰 값을 만나는 순간 스캔을 멈춘다.

```oracle-sql
where 인터넷매물 = '3'
and 아파트시세코드 = 'A01011350900056'
and 평형 = '59'
and 평형타입 = 'A'
```

 - 하지만 인터넷매물 between 조건 중간에 걸친 2 구간은 전체 레코드를 스캔해야 한다.

### between을 IN-List로 전환
 - 범위검색 컬럼이 맨 뒤로 가도록 인덱스를 아파트시세코드+평형+평형코드+인터넷매물 순으로 변경하면 좋겠지만 운영 시스템에서 인덱스 구성을 바꾸기는 쉽지 않다. 이럴 때 Between 조건을 In-List로 바꿔주면 큰 효과를 덕는 경우가 있다.

```oracle-sql
select *
from 매물아파트매매
where 인터넷매물 in ('1', '2', '3')
and 평형 = '59'
and 평형타입 = 'A'
and 아파트시세코드 = 'A01011350900056'
order by 입력일 desc
```

![그림_3_34.png](image%2F%EA%B7%B8%EB%A6%BC_3_34.png)

 - 왼쪽 화살표가 3개인 이유는 인덱스 수직적 탐색이 3번 발생했기 때문이고 인덱스를 3번 탐색하게 된다.
 - 인덱스를 3번 탐색한다는 것은 


```oracle-sql
select *
from 매물아파트매매
where 인터넷매물 = '1'
and 평형 = '59'
and 평형타입 = 'A'
and 아파트시세코드 = 'A01011350900056'
order by 입력일 desc

select *
from 매물아파트매매
where 인터넷매물 = '2'
and 평형 = '59'
and 평형타입 = 'A'
and 아파트시세코드 = 'A01011350900056'
order by 입력일 desc

select *
from 매물아파트매매
where 인터넷매물 = '3'
and 평형 = '59'
and 평형타입 = 'A'
and 아파트시세코드 = 'A01011350900056'
order by 입력일 desc
```

 - SQL을 위와 같이 작성한 것과 같은 효과를 가진다. 위에서 where 조건에 = 이 사용된 것과 같고 IN-List 개수 만큼 UNION ALL 브랜치가 생성되고 각 브랜치마다 모든 컬럼을 = 조건으로 검색하므로 앞서 선두 컬럼에 between을 사용할 때와 같은 비효율은 사라진다.

 - 2장 3절 4항에서 배운 Index Skip Scan 방식으로 유도해도 비슷한 효과를 얻을 수 있다.
 - In-List 항목 개수가 늘어날 수 있다면 해당 방식을 사용하긴 곤란하다. 그럴땐 NL 방식의 조인문이나 서브쿼리로 구현하면 된다. 물론 In-List 값들을 코드 테이블로 관리하고 있을 떄 사용할 수 있는 방식이다. 자세한 원리는 4장 1절에 NL 조인 부분에서 나온다고 한다.

 - Between 조건을 In-List로 전환시 주의사항
   - 주의점은 개수가 많지 않아야 한다는 것이다. 수직적 탐색이 많이 발생하면 Between과 같이 넓게 탐색하는 것과 같은 비효율의 수직 탐색이 이루어질 수 있기 때문이다. 루트에서 브랜치 블록까지 Depth가 깊을 때 특히 그렇다.
   - 인덱스 스캔 과정에서 선택되는 레코드들이 서로 멀리 떨어져 있을 떄만 유용하다는 것이다.
   - 마지막 이미지 기준으로 인터넷 매물의 수인 1,2,3이 멀리 떨어져 있고 후행으로 오는 = 데이터가 적다면 In-List의 효과는 증대한다.
   - 하지만 만약 인터넷 매물의 1,2,3에 대해 가깝고 둘 사이 인덱스 블록이 매우 소량이라면 In-List가 효과가 없거나 오히려 블록 I/O가 많이 발생할 수 있다.
 - 정리하자면 between 조건 때문에 인덱스를 비효율적으로 스캔하더라도 블록 I/O 측면에서는 대개 소량에 그치는 경우가 많다. 인덱스 리프 블록에는 테이블 블록과 달리 매우 많은 레코드가 담기기 때문이다.
 - In-List 개수가 많으면 수직적 탐색 과장에서 이미 많은 블록을 읽게 되고 데이터 분포나 수직적 탐색 비용을 따져보지도 않고 between을 in-list로 바꾸는 일은 하지 않아야 한다.

### 3.3.7 Index Skip Scan 활용
 - 조금 전 Index Skip Scan 방식으로 유도해도 비슷한 효과를 얻을 수 있다고 했다.
 - 월별고객별판매집계라는 테이블이 있다고 하고 2018년 1월부터 12월까지 월별로 10만개(총 120만 개) 판매데이터가 입력되도록 할때, 판매구분이란 값으로 A와 B라는 값을 주고 A는 10만 B는 110만 개 일때, 아래와 같은 COUNT 쿼리를 한다고 가정하자.

```oracle-sql
select count(*)
from 월별고객별판매집계 t
where 판매구분 = 'A'
and 판매월 between '201801' and '201812'
```
 - 이 쿼리를 최적으로 수행하려면 = 조건인 판매구분이 선두 컬럼에 뒤치하도록 아래와 같은 인덱스를 구성해야 한다.

```oracle-sql
create index 월별고객별판매집계_IDX1 on 월별고객별판매집계(판매구분, 판매월);
```

 - 위 인덱스를 사용할때 인덱스 스캔에서 281개의 블록 I/O가 발생했다고 하고 테이블 액세스는 전혀 발생하지 않았다 하자.
 - 그리고 Between 조건의 판매월 컬럼이 선두인 인덱스를 사용하는 경우를 보자.

```oracle-sql
create index 월별고객별판매집계_IDX2 on 월별고객별판매집계(판매월, 판매구분);
```
![그림_3_38.png](image%2F%EA%B7%B8%EB%A6%BC_3_38.png)
- 판매구분이 'A'인 레코드는 위에서 보는 것처럼 2018년 1월부터 12월까지 각 팬매월 앞쪽에 위치하고 전체 차지하는 비중이 10/120인 8.3%의 불과하므로 서로 멀리 떨어지게 된다.
