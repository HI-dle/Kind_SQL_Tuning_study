# 인덱스 튜닝

---

# 3.1.5 인덱스만 읽고 처리

### 인덱스: [부서번호]
```sql
SELECT 부서번호, SUM(수량)
  FROM 판매집계
 WHERE 부서번호 LIKE '12%'
 GROUP BY 부서번호;
```

위 쿼리는 `LIKE` 조건에 해당하는 데이터들을 집계하는 쿼리이다.

- 즉, `LIKE` 조건에 해당하는 데이터를 찾고 테이블을 액세스한 뒤에 버리는 데이터가 하나도 없다.
  - 필터 조건에 의해 버려지는 없기 때문에 비효율은 없다고 할 수 있다.
  - 성능이 느린 이유는 단지 인덱스 스캔 과정에서 얻은 데이터가 많기 때문에 일(집계)이 증가했기 때문

### Q: 이런 경우는 어떻게 튜닝할 수 있을까?
A: 성능을 개선해야한다면, `쿼리에 사용된 컬럼을 모두 인덱스에 추가`해서 `테이블 액세스가 아예 발생하지 않게 하는 방법`을 고려해볼 수 있다.
- 이는 인덱스만 읽어서 처리하는 쿼리로 `Covered 쿼리`라고 부르며, 쿼리에 사용한 인덱스는 `Covered 인덱스`라고 한다.

`[부서번호]` 단일 컬럼으로 구성된 위 예시 같은 경우 `[수량]` 컬럼만 더 추가하면 된다.

- 이 방법은 효과는 매우 좋지만, 추가해야 할 컬럼이 많으면 실제로 적용하긴 어렵다.

---
## include 인덱스
> SQL Server, PostgreSQL에는 존재, Oracle에는 없음

### 정의
인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능

### 사용방법
아래와 같이 인덱스를 생성할 때 include 옵션을 지정하면 된다.
```sql
create index emp_x01 on emp (deptno) include (sal)
```

### 비교
```sql
-- include 인덱스 생성
create index emp_x01 on emp (deptno) include (sal)

-- 일반적인 인덱스 생성
create index emp_x02 on emp(deptno, sal)
```
- 일반적인 인덱스
  - `deptno, sal` 컬럼 모두 루트와 브랜치 블록에 저장
  - 둘 다 수직적 탐색에 사용할 수 있다.

- include 인덱스
  - `sal` 컬럼을 리프 블록에만 저장
  - 수직적 탐색에는 `deptno`만 사용하고, 수평적 탐색에는 `sal` 컬럼도 필터 조건으로 사용할 수 있다.
    - 즉, `sal` 컬럼은 테이블 랜덤 액세스 횟수를 줄이는 용도로만 사용

```sql
select sal from emp where deptno = 20

-- 위 SQL을 처리할 때는 
-- 두 인덱스 모두 `Covered 인덱스`이므로 테이블 랜덤 액세스를 생략할 수 있다.
```

```sql
select * from emp where deptno = 20 sal >= 2000

select * from emp where deptno = 20 sal <= 3000

select * from emp where deptno = 20 sal between 2000 and 3000
                  
-- 위 SQL을 처리할 때는
-- 테이블 랜덤 액세스 측면에서는 일량이 똑같다.
-- 하지만 include 인덱스의 경우 sal로는 정렬이 안되어있기 때문에 인덱스 스캔량이 더 많다.
```

```sql
select * from emp where deptno = 20 order by sal

-- 복합인덱스의 경우 SORT 연산을 생략할 수 있지만,
-- include 인덱스는 SORT 연산을 생략할 수 없다.
```

# 3.1.6 인덱스 구조 테이블
인덱스를 이용한 테이블 액세스가 고비용 구조라고 하니, 랜덤 액세스가 아예 발생하지 않도록 `테이블을 인덱스 구조로 생성하면 어떨까?`

- 실제로 제공되는 방법
  - 오라클: `IOT(Index-Organized Table)`
  - MS-SQL: `클러스터형 인덱스(Clustered Index)`

![그림_3-11.png](image%2F%EA%B7%B8%EB%A6%BC_3-11.png)

## 1. 인덱스 구조 테이블을 만드는 구문
```sql
create table index_org_t ( a number, b varchar(10)
                         constraint index_org_t_pk primary key (a) )
organization index ;
```

```sql
-- 💡 참고: 일반 테이블은 `힙 구조 테이블`이라고 부른다.

create table heap_org_t ( a number, b varchar(10)
                        constraint index_org_t_pk primary key (a) )
organization heap ; -- 대개 생략하지만 organization 옵션을 명시할 수도 있다.
```

## 2. 데이터 Insert 방식
- 일반 힙 구조 테이블
  - `랜덤 방식`: Freelist로부터 할당 받은 블록에 정해진 순서 없이 데이터를 입력

> `Freelist`: 새로운 레코드를 넣을 후보 블록들의 목록

- IOT(Index-Organization Table)
  - 인덱스 구조 테이블이므로 `정렬 상태`를 유지하며 데이터를 `Insert`

## 3. 클러스터링 팩터와의 연관성
IOT는 인위적으로 클러스터링 팩터를 좋게 만드는 방법 중 하나이다.
> `클러스터링 팩터`: 인덱스의 순서와 테이블 행의 물리적 순서가 얼마나 일치하는지 나타내는 값
> - 값이 낮으면 `읽기 효율 좋음`
> - 값이 높으면 인덱스 순서와 테이블 블록 순서가 제멋대로 흩어져 있음 -> `랜덤 액세스가 많아서 비효율`

- IOT
  - 같은 값을 가진 레코드들이 100% 정렬된 상태로 모여 있으므로 랜덤 액세스가 아닌 `시퀀셜 방식으로 데이터를 액세스한다.`
  - (`BETWEEN 이나 부등호 조건으로 넓은 범위를 읽을 때 유리하다.`)
  - 데이터 입력과 조회 패턴이 서로 다른 테이블에도 유용하다.

### 데이터 입력과 조회 패턴이 서로 다른 테이블의 예시: 영업사원의 연(1년) 판매실적 조회
- 영업사원은 100명이라고 가정
- 한 블록에는 최대 100개의 레코드가 담긴다고 가정
  - 일별 집계이므로 매일 하나의 블록이 생성됨(`100명 -> 100 레코드`)
  - `[1일 : 1블록 생성]` = `[1년 : 365블록 생성]`

```sql
-- where 조건절 사원의 일년 총판매금액, 평균판매금액 조회 쿼리

select 일자, sum(판매금액), avg(판매금액)
from   영업실적
where  사번 = 'S1'
and    일자 between '20250101' and '20251231'
group by 일자
```

- 만약 위 쿼리에 인덱스를 사용한다면
  - 랜덤 액세스 방식으로 `365개의 테이블 블록을 읽어야한다.`
    - 하루마다 테이블 블록이 생성됐었기 때문
    - 즉, `클러스터링 팩터가 매우 안좋으므로 조회 건수만큼 블록 I/O가 발생한다.`


만약 IOT를 아래와 같이 `사번이 첫 번째 정렬 기준이 되도록` 구성해준다면?
```sql
create table 영업실적 ( 사번 varchar2(5), 일자 varchar2(8) ), ...
        , contraint 영업실적_pk primary key (사번, 일자) )
organization index ;
```
- `4개의 테이블 블록만 읽고 처리할 수 있다!`
  - 하나의 사원당 365 레코드 필요 = 한 블록(100개 레코드) * 4 필요

---
# 3.1.7 클러스터 테이블
클러스터 테이블에는 `인덱스 클러스터 테이블`과 `해시 클러스터 태이블` 두 가지가 있다.

## 인덱스 클러스터 테이블

클러스터 키 값이 같은 레코드를 `한 블록`에 모아서 저장하는 구조다.

![그림_3-12.png](image%2F%EA%B7%B8%EB%A6%BC_3-12.png)

- 한 블록에 담을 수 없을 때는 새로운 블록을 할당해서 `클러스터 체인`으로 연결한다.
- `여러 테이블 레코드를 같은 블록에 저장`할 수도 있다. 이를 `다중 테이블 클러스터`라고 부른다.

> 💡 다중 테이블 클러스터 예시
> 
> 부서(`Dept`) 테이블과 직원(`Emp`) 테이블
> - 부서: 부서번호, 부서명
> - 직원: 부서번호, 사원번호, 이름
> 
> ❗️일반테이블의 경우라면? - 각 테이블 별로 블록을 따로 저장
> 
> 만약 부서와 직원을 자주 JOIN 한다면? = `부서 블록 조회 + 직원 블록 조회` = `I/O 2번`
> 
> ❗️다중 테이블 클러스터라면? 
> 
> 부서와 직원을 부서번호 기준으로 같은 블록으로 묶어서 한 번의 I/O로 조회 가능

### 인덱스 클러스터 테이블 구성
```sql
-- 클러스터 생성
create cluster c_dept# ( deptno number(2) ) index ;
       
-- ❗️필수: 클러스터 인덱스 정의하기(클러스터 테이블 생성 전에 먼저)
create index c_dept#_idx on cluster c_dept#;

-- 클러스터 테이블 생성
create table dept (
      deptno number(2)  not null
    , dname  varchar2(14) not null
    , loc    varchar2(13) 
  )
cluster c_dept#( deptno );
```

### 클러스터 인덱스의 특징
- 클러스터 인덱스는 테이블 레코드를 일일이 가리키지 않고 `해당 키 값을 저장하는 첫 번째 데이터 블록을 가리킨다.`

![그림_3-13.png](image%2F%EA%B7%B8%EB%A6%BC_3-13.png)

- 즉, `일반 테이블에 생성한 인덱스 레코드는 테이블 레코드와 1:1` 대응 관계를 갖지만, `클러스터 인덱스는 테이블 레코드와 1:M` 관계이다.
- 따라서 클러스터 인덱스의 키 값은 항상 `Unique` 하다.
- 클러스터 인덱스를 스캔하면서 값을 찾을 때는 `랜덤 액세스가 값 하나당 한 번씩 발생한다.`
  - (클러스터 체인을 스캔하면서 발생하는 랜덤 액세스는 제외한다고 가정했다.)
- 클러스터에 도달해서는 `시퀀셜 방식`으로 스캔하기 때문에 `넓은 범위 조회에서도 비효율이 없다는 것이 핵심 원리`이다.

### 실행계획
```sql
select * from dept where deptno = :deptno;

-- 마지막 줄이 핵심
0   SELECT STATEMENT Optimizer=ALL_ROWS (Cost=1 Card=1 Bytes=30)
1 0   TABLE ACCESS (CLUSTER) OF 'DEPT' (CLUSTER) (Cost=1 Card=1 Bytes=30)
2 1     INDEX (UNIQUE SCAN) OF 'C_DEPT#_IDX' (INDEX (CLUSTER)) (Cost=1 Card=1)
    
-- TABLE ACCESS (CLUSTER) OF 'DEPT': DEPT 테이블이 클러스터 테이블이며, 클러스터 블록을 읽어서 레코드를 가져옴
-- INDEX (UNIQUE SCAN) OF 'C_DEPT#_IDX' (INDEX (CLUSTER)): 클러스터 인덱스 사용, 고유 키 검색
-- 결국 B+Tree에서 입력받은 부서번호를 빠르게 찾고 leaf에서 블록 주소를 가져온 후 클러스터 블록을 읽는다.
```

> 💡 참고
> 
> 책에 `클러스터 인덱스도 일반 B*Tree 인덱스 구조를 사용하지만, ...` 이라고 적혀있다.
> 
> 근데 찾아보니 요즘은 다 B+Tree 인 것 같다.(최진영 피셜)

---
## 해시 클러스터 테이블
인덱스를 사용하지 않고 `해시 알고리즘`을 사용하여 클러스터를 찾아간다는 점만 다르다.

![그림_3-14.png](image%2F%EA%B7%B8%EB%A6%BC_3-14.png)

### 해시 클러스터 테이블 구성
```sql
-- 클러스터 생성
create cluster c_dept# ( deptno number(2) ) hashkeys 4;
```
- `hashkeys 4`에서 `4`는 버킷 수


```sql
-- 클러스터 테이블 생성
create table dept (
      deptno number(2)  not null
    , dname  varchar2(14) not null
    , loc    varchar2(13) 
  )
cluster c_dept#( deptno );
```

### 실행계획
```sql
select * from dept where deptno = :deptno;

-- 마지막 줄이 핵심
0   SELECT STATEMENT Optimizer=ALL_ROWS (Cost=1 Card=1 Bytes=30)
1 0   TABLE ACCESS (HASH) OF 'DEPT' (CLUSTER (HASH)) (Cost=1 Card=1 Bytes=30) 
```