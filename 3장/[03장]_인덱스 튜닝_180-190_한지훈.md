# 인덱스 튜닝

---

### 3.3.2 인덱스 스캔 효율성

![그림_3_26.png](image%2F%EA%B7%B8%EB%A6%BC_3_26.png)


 - 다음과 같은 용어사전에서 가나다 순으로 정렬 되었다 할 때
   - 질문 1: '성능검'으로 시작하는 용어를 검색하고자 할 때 어디서 스캔을 시작하고 멈출지
   - 질문 2: '성능'으로 시작하고 네 번째 문자가 '선'인 용어를 검색할 떄 스캔 범위는?

![그림_3_27.png](image%2F%EA%B7%B8%EB%A6%BC_3_27.png)

 - 성능검사에서 스캔을 지가하고 가나다순 정렬이므로 바로 찾아가고 끝까지 안 읽고 멈출 수 있다. 성능계수까지 읽고 2건을 얻기 위해 3건을 읽었다.

![그림_3_27_2.png](image%2F%EA%B7%B8%EB%A6%BC_3_27_2.png)

 - 질문2는 성능으로 시작하고 4번째 문자가 선인 용어를 검색할때 모든 성능으로 시작하는 용어를 스캔하고 결과는 동일하게 2건이지만 더 많은 용어를 스캔해야 한다.

![그림_3_28.png](image%2F%EA%B7%B8%EB%A6%BC_3_28.png)
 - 이번에는 각 문자를 잘라 테이블 컬럼에 각각 저장하고 C1 + C2 + C3 + C4 순으로 인덱스를 구성한 것이다.
 - 질문 3: '성능검'으로 시작하는 레코드를 검색하려면
```oracle-sql
where c1 = '성'
and c2 = '능'
and c3 = '검'
```

 - 위 조건절에서 인덱스를 사용한다면 스캔 범위는 어떻게 될까
 - 질문 4: '성능'으로 시작하고 4번째 컬럼이 '선'인 레코드를 검색할때 동일하게 인덱스를 사용한다면 스캔 범위는?
```oracle-sql
where c1 = '성'
and c2 = '능'
and c4 = '선'
```

![그림_3_29_1.png](image%2F%EA%B7%B8%EB%A6%BC_3_29_1.png)

 - 질문3은 성능검으로 시작하는 레코드를 검색할 땐 인덱스 수직적 탐색을 통해 성능검사 레코드로 찾아간다. 거기서 스캔을 시작해 성능계수까지 총 3개의 범위를 가진다. 

![그림_3_29_2.png](image%2F%EA%B7%B8%EB%A6%BC_3_29_2.png)

 - 질문4는 성능인 레코드를 모두 스캔 후 결과는 똑같이 두 건이지만 똑같이 많이 인덱스 레코드를 스캔해야 한다.

 - 인덱스 스캔을 통해 얻은 결과 건수는 똑같은데 왜 이처럼 인덱스 리프 블록에서 스캔하는 레코드 개수에 차이가 생기고 효율성에서 차이가 나는 걸까?
 - 구체적으로 왜 후자는 전자보다 들인 노력에 비해 얻은 결과가 적을까?
 - 인덱스 선행 컬럼이 조건걸에 없기 때문이다. 위 그림 인덱스에서 C4보다 앞선 선행 컬럼 C3가 조건걸에 없기 때문이다.
 - 선행 컬럼이 조건절에 없거나 = 조건이 아니면 인덱스 스캔 과정에 비효율이 발생한다.


### 인덱스 스캔 효율성 측정
 - 인덱스 스캔 효율이 좋은지 나쁜지는 조건절 데이터를 일일히 조회해 보는 방법도 있지만 SQL 트에이스를 통해 쉽게 알 수 있다.
```postgres-sql
Rows    Row Source operation
----    --------------------------------------------------------------
  10    TABLE ACCESS BY INDEX ROWID BIG_TABLE (cr=7471 pr=1466 pw=0 tune22137 us)
  10      INDEX RANGE SCAN BIG_TABLE_IDX (cr=7463 pr=1466 pw=0 tune22328 us)
```

 - 위 트레이스를 분석해보면 인덱스를 스캔하고 얻은 레코드가 열 개인데, 그 과정에서 7463개 블록을 읽는 것을 확인할 수 있고, 인덱스 리프 블록에는 테이블 블록보다 훨씬 더 많은 레코드가 담긴다.
 - 한 블록당 평균 500개 레코드가 담긴다 가정하면 3,731,500(7463*500)개 레코드를 읽은 셈이다. 큰 비효율인 것을 알 수 있다.

> 선두 컬럼, 선행 컬럼
> 
> 같은 용어라 해석될 수 있지만 아니다. 선두 컬럼은 인덱스 구성상 맨 앞쪽에 있는 컬럼을 지칭하고 선행 컬럼은 어떤 컬럼보다 상대적으로 앞쪽에 놓인 컬럼을 칭할때 사용하기로 하자.

### 3.3.3 액세스 조건과 필터 조건

 - 인덱스를 스캔하는 단계에 처리하는 조건절은 액세스 조건과 필터 조건으로 나뉜다. 인덱스 액세스 조건은 인덱스 스캔 범위를 결정하는 조건절이고 인덱스 수직적 탐색을 통해 스캔 지점을 결정하는데 영향을 미치고 인덱스 리프 블록을 스캔하다 어디서 멈출기 결정하는 데 영향을 미치는 조건절이다. 인덱스 필터 조건은 테이블로 액세스할지를 결정하는 조건절이다.
 - 앞서 본 C1~4 인덱스에서 먼저 본 스캔이 적은 인덱스에선 C1,2,3이 모두 인덱스 액세스 조건이고 스캔 범위가 큰 인덱스에선 C1,2가 인덱스 액세스 조건이고 C4가 인덱스 필터 조건이었다.
 - 인덱스를 이용하든, 테이블을 풀 스캔 하든, 테이블 액세스 단계에서 처리되는 조건절은 모두 필터 조건이다. 테이블 필터 조건은 쿼리 수행 다음 단계로 전달하거나 최종 결과 집합에 포함할지를 결정한다.

### 3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성
 - 테이블과 달리 인덱스에서는 같은 값을 갖는 레코드들이 서로 군집해있다. 같은 값을 찾을 떄 = 연산자를 사용하므로 인덱스 컬럼을 앞쪽부터 누락없이 = 연산자로 조회하면 조건절을 만족하는 레코드는 모두 모여 있다. 어느 하나를 누락하거나 = 조건이 아닌 연산자로 조회하면 조건절을 만족하는 레코드가 서로 흩어진 상태가 된다.

![그림_3_31.png](image%2F%EA%B7%B8%EB%A6%BC_3_31.png)
<span style="opacity:0.5">짜쳐도 봐주세요 힘들었어요...</span>

```postgres-sql
where C1 = 1
and   C2 = 'A'
and   C3 = '나'
and   C4 = 'a'
```

 - 위처럼 모든 조건을 = 으로 비교할 떄는 조건절을 만족하는 레코드들이 모두 연속해 모여 있다.


```postgres-sql
where C1 = 1
and   C2 = 'A'
and   C3 = '나'
and   C4 >= 'a'
```

 - 마지막 조건절에 범위 검색 조건(부등호, BETWEEN, LIKE)일 떄도 조건을 만족하는 레코드가 서로 모여 있다.

```postgres-sql
where C1 = 1
and   C2 = 'A'
and   C3 between '가' and '다'
and   C4 = 'a'
```

 - 중간에 범위 검색 조건이 붙은 경우 세 번째 컬럼 C3이 범위조건인 경우 C1부터 C3까지 세 조건을 만족하는 인덱스 레코드는 모여 있지만 C4 조건까지는 만족하는 흩어지게 된다.

```postgres-sql
where C1 = 1
and   C2 <= 'B'
and   C3 = '나'
and   C4 between 'a' and 'b'
```
 - C2가 범위 조건인 경우 C1~2 까지 만족하는 레코드는 모여 있지만 3,4 까지 만족하는 레코드는 흩어지게 된다.

 - 여기까지 규칙성을 발견할 수 있는데, 선행 컬럼이 모두 = 조건인 상태에서 첫 번째 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드는 모두 연속해서 모여 있지만, 그 이하 조건까지 만족하는 레코드는 비교 연산자 종류에 상관 없이 흩어진단 규칙이다.

```postgres-sql
where C1 between 1 and 3
and   C2 = 'A'
and   C3 = '나'
and   C4 = 'a'
```
 - C1인 선두 컬럼이 범위 조건이면 C1 조건을 만족하는 레코드는 서로 모여 있고 나머지 조건까지 만족하는 레코드는 비교 연산자 종류에 상관없이 흩어져 있게 된다.

 - 인덱스 스캔 범위를 결정하는 조건절이 인덱스 액세스 조건이고 선행 컬럼이 모두 = 조건인 상태에서 첫 번째 나타나는 범위검색 조건이 인덱스 스캔 범위를 결정한다. 조건절 5처럼 가장 선두 컬럼이 범위검색 조건이면 그 조건이 스캔 범위를 결정한다 따라서 이들 조건이 인덱스 액세스 조건이다. 나머지 인덱스 컬럼 조건은 모두 인덱스 필터 조건이다.


![표_3_1.png](image%2F%ED%91%9C_3_1.png)


> 범위검색 조건 맨 처음과 마지막 구간에서의 액세스 조건
> 
> 조건절 5에서 C2,3,4도 인덱스 스캔량을 줄이는데 어느정도 역할을 한다. C1 = 1 인 구간과 C1 = 3인 구간에서 그렇다.
>
> where C1 >= 1 and   C2 = 'A' and   C3 = '나' and   C4 = 'a'
> 
> where C1 <= 3 and   C2 = 'A' and   C3 = '나' and   C4 = 'a'
> 
> 조건보다 큰 값을 만나는 순간 멈추므로 C1 = 3 구간에서도 스캔 범위를 줄이는 역할을 한다. 조건절 3,4의 필터 조건도 범위 검색 조건 맨 처음과 마지막 구간에서는 스캔량 줄이는데 역할을 한다. 하지만 대개 무시할 수준이다.
> 
> 오라클은 실행계획 하단에 액세스 조건과 필터 조건을 정리해서 보여주는데 조건절5로 테스트 해보면 C2,3,4 컬럼이 액세스 조건에 포함되는 이유를 알 수 있다.

```oracle-sql
Preducate information (identified by operation id):
------------------------------------------------------------
2 - access("C1">=1 AND "C2"='A' AND "C3"='나' AND "C4"='a' AND "C1"<=3)
2 - filter("C2"='A' AND "C3"='나' AND "C4"='a')
```

 - 좌변 컬럼을 가공한 조건절
 - 왼쪽 % 또는 양쪽 %를 통한 Like 조건절
 - 같은 컬럼에 대한 조건절이 두 개 이상일 때, 인덱스 액세스 조건으로 선택되지 못한 조건절
 - OR Expansion 또는 INLIST ITERATOR로 선택되지 못항 OR 또는 IN 조건절

> 이 케이스를 제외하면 인덱스 컬럼에 대한 조건절은 모두 액세스 조건에 표시된다. 첫 번째 나타나는 범위검색 조건 이후 조건절 컬럼은 스캔 범위를 줄이는데 큰 역할을 못하는데 말이다.
> 
> 액세스 조건과 필터 조건을 실행계획에 효시된 대로 이해하면 사실 이 둘을 구분할 이유가 없어진다. 따라서 실행계획에 위와 같이 표시되더라도 복작하게 생각하지 말고 첫번쨰 나타나는 범위검색 조건까지가 인덱스 액세스 조건이고 나머지는 필터 조건이라고 이해하면 된다.
