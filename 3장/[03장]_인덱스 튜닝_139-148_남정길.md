# 인덱스 튜닝

---

### 3.1.3 인덱스 손익분기점

![그림_3-7.png](image%2F%EA%B7%B8%EB%A6%BC_3-7.png)
인덱스 ROWID를 이용한 테이블 액세스는 생각보다 **고비용 구조**다.
읽어야 할 데이터가 일정량을 넘는 순간, 테이블 전체를 스캔하는 것 보다 오히려 느려진다.
>Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점을 '인덱스 손익분기점'이라 한다.

#### Table Full Scan의 성능
한건을 조회하든 10만건을 조회하던 성능은 동일하다.
```sql
select /*+ full(t)*/ count(*) from bing_table t where no <=1;
select /*+ full(t)*/ count(*) from bing_table t where no <=10;
select /*+ full(t)*/ count(*) from bing_table t where no <=100;
select /*+ full(t)*/ count(*) from bing_table t where no <=1000;
...
select /*+ full(t)*/ count(*) from bing_table t ;
```

이에 반해 인덱스를 이용해 테이블을 액세스할 때는 전체중 몇건을 추출하느냐에 따라 달라진다. -> 테이블 랜덤 액세스 때문

인덱스를 이용한 테이블 액세스가 더 느려지게 만드는 가장 핵심적인 두가지 요소

| 구분     | Table Full Scan | 인덱스 ROWID를 이용한 테이블 액세스 |
| ------ | --------------- | ---------------------- |
| 액세스 방식 | 시퀀셜 액세스         | 랜덤 액세스                 |
| I/O 단위 | MultiBlock I/O  | SingleBlock I/O        |

이런 요인에 의해 손익분기점은 보통 5~20%의 낮은 수준에서 결정된다.

그리고 그림에서 보듯 CF에 따라 크게 달라진다.
- CF가 나쁘면 → 논리적 I/O ↑ , 물리적 I/O ↑ **손익분기점 5% 미만** 
- CF가 좋다면 → 논리적 I/O ↓, 물리적 I/O ↓ **손익분기점 90%**(인위적으로 데이터를 인덱스 컬럼 순으로 정렬했을시)
- 
>**CF (Clustering Factor) 정의**<br>
>인덱스의 물리적 정렬 정도를 나타내는 지표<br>
>인덱스가 가리키는 테이블의 실제 행(Row)들이 얼마나 순서대로 저장되어 있는지를 수치로 표현

![그림_3-8.png](image%2F%EA%B7%B8%EB%A6%BC_3-8.png)

인덱스가 항상 좋을 수 없음을 설명하려고 손익분기점이란 개념을 사용했을 뿐,
이를 높이기 위해 어떤 조치를 해야한다는 뜻이 아님 즉, 테이블 스캔이 항산 나쁜것이 아니며,
인덱스 스캔이 항상 좋은것도 아니라는 뜻

#### 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝
온라인 프로그램은 보통 소량의데이터를 읽고 갱신하므로 인덱스를 효과적으로 활용하는 것이 중요하다. 
대부분 NL조인을 사용한다. 인덱스를 이용해 소트 연산을 생략해 부분범위 처리 방식으로 구현하면 빠른 응답속도를 낼 수 있다.

반면 대량의 데이터를 읽고 갱신하는 배치 프로그램은 전체범위 처리 기준으로 튜닝해야한다.
따라서 대량의 데이터를 빠르게 처리하려면 인덱스와 NL조인이 아닌 Full Scan과 해시조인이 유리하다

#### 실명확인 번호로 조회한 특정 고객의 최근 1년이내 변경이력중 전월 말일 데이터

```sql
select c.고객번호,c.고객명,h.전화번호,h.주소,h.상태코드,h.변경일시
from 고객 c, 고객변경이력 h
where c.실명확인번호 = :rmnno      -- "여기를 주목
and h.고객번호 = c.고객번호
and h.변경일시 = (select max(변경일시)
                 from 고객변경이력 m
                 where 고객번호 = c.고객번호
                 and 변경일시 >= trunc(add_months(sysdate, -12), 'mm')
                 and 변경일시 < trunc(sysdate, 'mm'))
```
실명확인번호 조건에 해당하는 데이터는 한 건이거나 소량이므로 인덱스와 NL조인을 사용하는 위 방식이 효과적

```sql
insert into 고객_임시
select c.고객번호,c.고객명,h.전화번호,h.주소,h.상태코드,h.변경일시
from 고객 c, 고객변경이력 h
where c.고객구분코드 = 'A001'      -- "여기를 주목
and h.고객번호 = c.고객번호
and h.변경일시 = (select max(변경일시)
                 from 고객변경이력 m
                 where 고객번호 = c.고객번호
                 and 변경일시 >= trunc(add_months(sysdate, -12), 'mm')
                 and 변경일시 < trunc(sysdate, 'mm'))
```
전체 300만건중 고객구분코드 조건을 만족하는 데이터가 100만건이라고 할때 위와 같이 조건절만 바꿔서 수행하면 빠른 성능을 낼 수 없다.

쿼리를 아래와 같이 변경하고 Full Scan과 해시조인을 사용해야 효과적이다.
조건절에 해당하지 않는 고객 데이터, 1년을 초과한 이력 데이터까지 읽는 비효율이 있지만 수행속도는 훨씬 빠르다
```sql
insert into 고객_임시
select /*+ full(c) full(h) index_ffs(m.고객변경이력)
         orderd no_merge(m) use_hash(m) use_hash(h) */
    c.고객번호,c.고객명,h.전화번호,h.주소,h.상태코드,h.변경일시
from 고객 c, (select 고객번호, max(변경일시) 최종변경일시 
              from 고객변경이력
              where 변경일시 >= trunc(add_months(sysdate, -12), 'mm')
              and 변경일시 < trunc(sysdate, 'mm')
              group by 고객번호) m,
              고객변경이력 h            
where c.고객구분코드 = 'A001'      
and m.고객번호 = c.고객번호
and h.고객번호 = m.고객번호
and h.변경일시 = m.최종변경일시
    
```

고객변경이력을 두번읽는 비효율을 없애혀면 윈도우 함수를 이용하면 된다.

대량 배치에선 FullScan이 효과적이지만 초대용량 테이블을 FullScan하면 상당히 오래 기다려야한다.
따라서 배치 프로그램에선 파티션 활용 전략이 매우 중요한 요소이고, 병렬처리 까지 더할 수 있으면 더욱 좋다
위 쿼리의 고객변경이력 테이블을 변경일시 기준으로 파티셔닝 하면 해당하는 파티션만 골라서 FullScan하므고 부담을 크게 줄인다.

파티션 테이블에도 인덱스를 사용할 수 있지만 월 단위나 몇 개월치로 조회할때는 좋은 선택이 아니다.
일주일치를 조회하더라도 FullScan이 유리하다 즉, 파티셔닝을 하는 이유는 FullScan을 빠르게 하기 위함이다.

**모든 성능 문제를 인덱스로 해결하려 하지 말자!!**

### 3.1.4 인텍스 컬럼 추가
테이블 액세스 최소화를 위해 가장 일반적으로 사용하는 튜닝 기법은 인덱스에 컬럼을 추가하는것이다.

```sql
select /*+index(emp emp_x01)*/ ename,job,sal
from emp
where deptno=30
and sal>3000
```

![그림_3-9.png](image/%EA%B7%B8%EB%A6%BC_3-9.png)

만족하는 사원은 단 한명인데 테이블 액세스를 6번하게 되었다.<br>
이를 해결하기 위해 가장 좋은 방법은 인덱스를 deptno + sal 순으로 변경하는것인데 하지만 실 운영환경에선
변경하기가 절대 쉽지않다 
```sql
select * from emp where deptno=30 and job = 'CLERK'
```
위처럼 기존인덱스를 사용하는 쿼리가 있을수있다 
그렇다고 인덱스를 새로 추가하다 보면 관리비용뿐만아니라 DML부하에 따른 트랜잭션 성능저하가 생길 수 있다.

이럴 때 기존 인덱스에 sal 컬럼을 추가해 주는것 만으로 큰 효과를 얻을 수 있다.
인덱스 스캔량을 줄지 않지만 테이블 랜덤 액세스 횟수를 줄여준다.

![그림_3-10.png](image/%EA%B7%B8%EB%A6%BC_3-10.png)

```sql
select 주저리주저리
from 로밍렌탈
where 서비스 번호 like '010%'
and 사용여부 = 'Y'
```
서비스번호 단일 컬럼으로 구성된 인덱스를 사용했을시 인덱스를 스캔하고서 얻은 건수는 266,476
그 건수 만큼 테이블을 랜덤액세스 했는데 그 단계에서만 265,957개 블록을 읽었다
총 소요시간은 49초에 이른다. 문제는 266,476번 방문했지만 최종 결과집합이 1,909건 뿐이라는데 있다.

로밍렌탈 인덱스에 사용여부 컬럼을 추가한 이 후  
인덱스를 거쳐 테이블을 1,909번 방문했고, 불필요한 테이블 액세스가 발생하지 않았다
총 블록 I/O도 2,902개로 줄었다.