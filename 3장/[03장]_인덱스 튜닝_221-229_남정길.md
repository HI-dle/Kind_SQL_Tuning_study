# 3장 인덱스 튜닝 
## 3.3.11 다양한 옵션 조건 처리 방식의 장단점 비교
### UNION ALL 활용
:cust_id 변수에 값을 입력했는지에 따라 위아래 SQL중 하나만 실행되게 하는 방식

```sql
select * from 거래
where :cust_id is null
and 거래일자 between :dt1 and :dt2
union all
select * 거래
where :cust_id is not null
and 고객ID = :cust_id
and 거래일자 between :dt1 and :dt2
```

```sql
Execution Plan
------------------------------------------------------------
0  SELECT STATEMENT Optimizer=ALL_ROWS
1  0  UNION ALL
2  1  FILTER      -- :cust_id is null
2  1    TABLE ACCESS (BY LOCAL INDEX ROWID) OF '거래' (TABLE) 
3  2       INDEX (RANGE SCAN) OF '거래_IDX1' (INDEX) --거래일자
2  1  FILTER      -- :cust_id is not null
2  1    TABLE ACCESS (BY LOCAL INDEX ROWID) OF '거래' (TABLE)
3  2       INDEX (RANGE SCAN) OF '거래_IDX2' (INDEX) --고객ID + 거래일자 
```
여기서 cust_id 변수에 값이 없으면 위쪽 브랜치에서 거래일자가 선두인 인덱스를 사용하고, 
있으면 아래 브랜치에서 고객ID + 거래일자 인덱스를 사용한다.

이 패턴을 사용하면 cust_id에 값을 입력하던 말던 인덱스를 가장 최적으로 사용한다.
LIKE 패턴도 인덱스 사용은 가능하지만 거래일자가 BETWEEN이면 옵션 조건 컬럼을 필터 조건으로 사용한다.
반면 UNOIN ALL방식은  옵션조건 컬럼도 인덱스 액세스 조건으로 사용한다는게 중요하다
유일한 단점은 sql코딩량이 길어진다는 점이다.

### NVL/DECODE 활용

```sql
select * from 거래
where 고객ID = nvl(:cust_id, 고객ID)
and 거래일자 between :dt1 and :dt2

또는

select * from 거래
where 고객ID = decode(:cust_id, null, 고객ID, :cust_id)
and 거래일자 between :dt1 and :dt2
```
cust_id에 값을 입력하지 않으면 거래일자 인덱스를 사용하고 입력시 고객ID + 거래일자 인덱스를 사용한다.
NVL,DECODE 둥 중 어느 것을 사용하든, 실행계획은 똑같다.
```sql
Execution Plan
------------------------------------------------------------
0  SELECT STATEMENT Optimizer=ALL_ROWS
1  0  CONCATENATION
2  1  FILTER      -- :cust_id is null
2  1    TABLE ACCESS (BY LOCAL INDEX ROWID) OF '거래' (TABLE) 
3  2       INDEX (RANGE SCAN) OF '거래_IDX1' (INDEX) --거래일자
2  1  FILTER      -- :cust_id is not null
2  1    TABLE ACCESS (BY LOCAL INDEX ROWID) OF '거래' (TABLE)
3  2       INDEX (RANGE SCAN) OF '거래_IDX2' (INDEX) --고객ID + 거래일자 
```

고객ID 컬럼을 함수의 인자로 사용(인덱스 컬럼 가공)했는데도 인덱스를 사용하는 이유는 OR Expansion 쿼리 변환이 일어났기 때문이다.
앞서 살펴본 UNION ALL 방식으로 옵티마이저가 쿼리를 변환한 것이다.

만약 이 기능이 작동 하지 않으면 NVL,DECODE 패턴도 인덱스 액세스 조건으로 사용이 불가능하다
:cust_id가 null일시 고객ID=고객ID형태가 되므로 조건을 만족하는 시작점을 찾을 수 없게 되기 때문이다.

| 구분                            | 내용                                                         |
|-------------------------------| ---------------------------------------------------------- |
| ✅ **장점**                      |                                                            |
| • 단순한 쿼리 구조                   | UNION ALL보다 단순하면서 같은 성능을 낼 수 있다                            |
| • 동일한 성능                      | 옵티마이저가 내부적으로 UNION ALL로 변환하므로, 수동으로 나눈 쿼리와 동일한 실행 계획/성능 확보 |
| ❌ **단점**                      |                                                            |
| • NULL 허용 컬럼 사용불가             | 조건절 변수에 NULL을 입력하면  값이 NULL인 레코드가 결과 집합에서 누락되기 때문    |

>NVL / DECODE함수를 여러개 사용하면 변별력이 가장 좋은 컬럼 기준으로 한 번만 OR Expansion이 일어난다
따라서 OR Expansion가주능로 선택되지 않으면 인덱스 구성 컬럼이어도 모두 필터 조건으로 처리된다.

다양한 옵션 조건 패턴중 각 방식의 장단점을 이해함으로써 상황에 따라 적절히 선택하여야 한다.

### Dynamic SQL
Dynamic SQL을 이용해서 조건절을 동적으로 구성할 수 있는 시스템에서 개발중인 경우 위 내용에 공감을 못할 수 있다.
>Dynamic SQL을 이용하면 옵션 조건에 '=' 연산자를 사용할 수 있기 때문

옵션 조건에 '='연산자를 사용할 경우, 변별력있는 컬럼을 액세스 조건으로 인덱스만 잘 구성해주면 된다.

⚠️ 주의사항 <br>

1. Dynamic SQL을 사용하는 상황에도 힌트로 액세스경로를 고정하려 할때 튜닝기법을 적절히 활용해야한다.
   -> Dynamic SQL에 힌트를 명시하면 동적으로 구성된 조건절과 서로 상충함으로 성능 문제를 야기할 수 있기 때문
2. 하드파싱에 의한 성능문제가 발생하지 않도록 바인드 변수를 잘 사용해야 한다.


## 3.3.12 함수호출부하 해소를 위한 인덱스 구성

### PL/SQL 함수의 성능적 특성
PL/SQL 사용자 정의 함수는 개발자들의 생각보다 매우 느리다.

#### 1. 가상머신상에서 실행되는 인터프리터 언어

PL/SQL로 작성한 함수와 프로시저를 컴파일 하면 JAVA처럼 바이트코드를 생성해 데이터 딕셔너리에 저장하며
PL/SQL 엔진은 바이트 코드를 런타임시 해석하면서 실행한다.<br>
PL/SQL도 JAVA처럼 인터프리터 언어이기 때문에 Native코드로 컴파일된 내장함수에 비해 많이 느리다.


#### 2. 호출 시마다 컨텍스트 스위칭 발생
실행시 매번 SQL실행 엔진과 PL/SQL가상머신 사이에서 컨텍스트 스위칭이 일어난다.<br>
   
#### 3. 내장 SQL에 대한 Recursive Call 발생
성능을 떨어뜨리는 가장 결정적인 요소

```sql
select 회원번호, 회원명, 생년, 생월일, GER_ADDR(우편번호) as 기본주소
from 회원
where 생월일 like '0%1'
```
SQL에서 조건을 만족하는 회원이 100만명일때 GET_ADDR도 100만번 실행된다.<br>
이때 만약 함수에 SQL이 내장돼 이씅면  그 SQL도 100만번 실핸한다. 대부분 내장되어 있으므로 Recursive Call 부하가 가장 크다

 ```sql
select 회원번호, 회원명, 생년, 생월일, 
(select b.시도 || '' || b.구군 || '' || b.읍면동
 from 기본주소 b
 where b.우편번호 = a.우편번호
 and b.순번 =1 ) 기본주소 
from 회원 a
where 생월일 like '0%1'
 ```     
위 SQL에 PL/SQL함수를 쓰지 않고 아래와 같이 조인문으로 처리하면 성능차이가 매우크다.

PL/SQL 함수 로직이 너무 복잡하면 그대로 쓸 수 밖에 없는데, 그럴 때 함수 호출을 줄이는 방법 중 하나가 액세스 조건을 고려한 인덱스 구성이다.

### 효과적인 인덱스 구성을 통한 함수 호출 최소화
아래와 같이 조건절에 PL/SQL함수를 사용할 때 회원 테이블을 Full Scan방식으로 읽으면 encryption 함수는 조건절을 만족하는 건수만큼 수행된다.
```sql
select /*+ full(a)*/ 회원번호, 회원명, 생년, 생월일, 등록일자
from 회원 a
where 생년 = '1987'
and 암호화된_전화번호 = encryption(:phone_no)
```

```sql
create index 회원_X01 on 회원(생년);
create index 회원_X02 on 회원(생년, 생월일, 암호화된_전화번호);
create index 회원_X01 on 회원(생년, 암호화된_전화번호);
```
회원_X01 인덱스를 사용하면 암호화된_전화번호 조건절을 테이블 액세스 단계에서 필터링한다. 
따라서 encryption함수는 테이블 액세스 횟수(생년 = 1897조건을 만족하는 건수)만큼 수행된다.
```sql
select /*+ index(a 회원_X01)*/ 회원번호, 회원명, 생년, 생월일, 등록일자
from 회원 a
where 생년 = '1987'
and 암호화된_전화번호 = encryption(:phone_no)
  
  Execution Plan
------------------------------------------------------------
0  SELECT STATEMENT Optimizer=ALL_ROWS
1   0   TABLE ACCESS (BY INDEX ROWID BATCHED) OF '회원' (TABLE) 
2   1     INDEX (RANGE SCAN) OF '회원_X01' (INDEX)
------------------------------------------------------------

Predicate information
------------------------------------------------------------
1 - filter("암호화된_전화번호"="ENCRYPTION"(:PHONE_NO))   
2 - acess("생년"= '1897')   
```

X02를 사용하면 암호화된_전화번호는 선행컬럼이 생월일에 대한 '=' 조건이 없으므로 인텍스 필터 조건이다.
따라서 "생년"= '1897'조건을 만족하는 건수만큼 수행된다.

```sql
Predicate information
------------------------------------------------------------ 
2 - acess("생년"= '1897' AND "암호화된_전화번호"="ENCRYPTION"(:PHONE_NO))
2 - filter("암호화된_전화번호"="ENCRYPTION"(:PHONE_NO))  
```
X03을 수행하면 암호화된_전화번호도 생년과 함께 인덱스 액세스 조건으로 사용된다. 따라서 encryption 함수는 단 한번 수행된다.
```sql
Predicate information
------------------------------------------------------------ 
2 - acess("생년"= '1897' AND "암호화된_전화번호"="ENCRYPTION"(:PHONE_NO))
```


     
    
    







