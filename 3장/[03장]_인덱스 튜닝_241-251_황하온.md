## 3.4.6 결합 인덱스 선택도

- 인덱스 생성 여부를 결정할 때, 선택도가 충분히 낮은지는 중요한 판단 기준이며, 선택도(카디널리티)가 높은 인덱스는 생성했을 때 큰 효용가치가 없다.
  - 선택도가 높은 경우, 결국 테이블 액세스가 많이 발생하게 된다.

### 선택도(Selectivity)
- 전체 레코드 중에서 조건절에 의해 선택되는 레코드 비율을 뜻한다.
- 인덱스 선택도: 인덱스 컬럼을 모두 '=' 로 조회할 때 평균적으로 선택되는 비율을 의미한다.

### 카디널리티
- 선택도에 총 레코드 수를 곱해서 카디널리티를 구한다.

### 컬럼 순서 결정 시, 선택도 이슈

- 결합 인덱스를 구성할 때 선택도는 중요한 우선순위가 아니다.
- 보다 '항상 사용하는' 컬럼을 앞쪽에 두고 그 중 '=' 조건을 앞쪽에 위치시키는 것이 기본이다.
  - 그 중 선택도가 낮은 컬럼을 앞쪽에 두는 것은 외려 의미 없거나, 손해일 수 있다.

- 예를 들어, 성별과 고객 번호를 '=' 조건으로 검색할 때, 인덱스 스캔 효율은 두 컬럼의 순서에 상관없이 동일하다.
  - 두 컬럼 모두 인덱스 액세스 조건이기 때문!

- 필수 조건들과 옵션 조건들 간에는 인덱스 스캔 효율과 컬럼 순서가 무관하다.

#### 고려할 점
- 고객등급과 고객번호 컬럼을 인덱스로 구성하는 경우, 고객 등급이 조건절에서 누락될 수 있거나 범위검색 조건일 수 있다면?
  - 고객등급을 앞쪽에 두는 것이 유리하다.
  - Index Skip Scan 이나 IN-List 조건을 활용할 수 있기 때문이다.
  - 더하여 인덱스를 압축할 경우 고객 등급을 앞쪽에 두는 편이 압축률이 더 좋다.

#### 결론
- 인덱스 생성 여부를 결정할 때! 선택도는 매우 중요한 요소이나,
- 컬럼 간 순서를 결정할 때는 컬럼의 선택도보다 필수 조건 여부, 연산자 형태가 더 중요한 판단 기준이다.

## 3.4.7 중복 인덱스 제거

### 완전 중복
```
- X01 : 계약ID + 청약일자
- X02 : 계약ID + 청약일자 + 보험개시일자
- X03 : 계약ID + 청약일자 + 보험개시일자 + 보험종료일자
```
- 위 인덱스의 포함 여부를 보면 X03 > X02 > X01 이기 때문에, X03을 남기고 나머지는 지워도 된다.

### 불완전 중복
```
- X01 : 계약ID + 청약일자
- X02 : 계약ID + 보험개시일자
- X03 : 계약ID + 보험종료일자
- X04 : 계약ID + 데이터생성일시
```
- 위의 인덱스들은 중복이 아니나, 계약 ID의 평균 카디널리티가 매우 낮다면 사실상 중복으로 볼 수 있다.
- 아래와 같이 하나의 인덱스만 만들면 충분하다.
  - X01 : 계약ID + 청약일자 + 보험개시일자 + 보험종료일자 + 데이터생성일시

### 중복제거 실습 1
```
- PK : 거래일자 + 관리지점번호 + 인련번호
- N1 : 계좌번호 + 거래일자
- N2 : 결제일자 + 관리지점번호
- N3 : 거래일자 + 종목코드
- N4 : 거래일자 + 계좌번호
```
- 위 테이블에서 거래일자, 결제일자는 항상 BETWEEN 또는 부등호로 조회된다고 가정한다.
> 아래 표에서 NDV는 Number of Distinct Values 로, 컬럼에 입력된 값의 종류 갯수를 의미한다.

컬럼명 | NDV
-- | --
거래일자 |	2,356
관리지점번호 |	127
일련번호 |	1,850
계좌번호 |	5,956
종목코드 |	1,715
결제일자 |	2,356

- 거래일자가 항상 BETWEEN이면 N3, N4는 둘다 거래일자가 액세스 조건이 된다. 그러므로 인덱스를 2개나 만들 필요 없이 N3, N4를 합쳐준다.
```
- N4 삭제
- N3 : `거래일자 + 종목코드 + 계좌번호` 로 수정
```

- 두번째 방안으로, N3 변경 없이 N4를 제거할 수 있다. 계좌번호와 거래일자로 조회하거나 계좌번호 단독으로 조회할 때는 N1 인덱스를 활용하고, 거래일자만으로 조회할 때는 N3 인덱스를 활용할 수 있다.
- 더하여, 기존에 관리지점번호가 선두 컬럼인 인덱스가 없었기에 관리지점번호로 단독으로 조회하는 경우가 없었던 것으로 추정된다. 그렇지만, PK를 보완하면 관리지점번호 '=' 와 거래일자 BETWEEN 조건일 때 비효율이 발생할 수 있음을 고려하여, 아래와 같이 설계하여 관리지점번호와 거래일자로 조회하는 경우 PK 를 사용하도록 하고, 거래일자만으로 조회하는 경우는 N3을 사용하도록 하여 효율을 높일 수 있을 것이다.
```
- PK : 관리지점번호 + 거래일자 + 일련번호
- N1 : 계좌번호 + 거래일자
- N2 : 결제일자 + 관리지점번호
- N3 : 거래일자 + 종목코드
~N4 : 거래일자 + 계좌번호~
```

### 중복제거 실습 2
```
- PK : 주소ID + 건물동번호 + 건물호번호 + 관리번호
- N1 : 상태구분코드 + 관리번호
- N2 : 관리번호
- N3 : 주소ID + 관리번호
```
컬럼명 | NDV
-- | --
주소ID |	736,000
건물동번호 |	175
건물호번호 |	3,052
관리번호 |	250,782
상태구분코드 |	3

- 위 예시에서 상태구분코드는 NDV가 3으로 선택도가 매우 높은 컬럼이므로, 해당 컬럼만으로 조회하는 경우 N1 인덱스가 사용되지 않을 것이다.
  - 관리번호를 같이 조회하는 경우에만 N1 인덱스 사용
- N2 인덱스는 관리번호로 조회될 때만 사용될 것이므로 이를 제거하고, N1 인덱스의 순서를 변경해서 효율을 높일 수 있다.
- **주의사항**: 그러나 여기서 주의점이 있다. 상태구분코드 중 특정 값이 변별력이 매우 좋을 수 있고(선택도가 매우 낮은), 이러한 경우를 고려하여 인덱스를 생성해둔 것이라면 N1 인덱스 구성을 바꿀 수 없다.

## 3.4.8 인덱스 설계도 작성
![alt text](image/image_3-8.png)
- 인덱스 설계 시 시스템 전체 효율을 고려해야 하므로, 인덱스 설계도를 작성하여 작업을 수행한다.
- 개별 SQL이 아닌 전체를 보며 전략을 수립하기 위해 테이블 별 실제 발생하는 액세스 유형을 모두 조사하는 과정이 필요하다.
  - 하단에 작성된 액세스 경로가 그 예다.
- 설계도 상단에는 파티션 구성을 기록하는 필드도 존재하는데, 인덱스 설계 전에 파티션 설계를 먼저 진행하거나 최소한 병행해야 제대로 된 인덱스 전략을 수립할 수 있기 때문이다.

### 개선 내용
- 해당 테이블의 액세스 경로를 보면 대부분에 '입력일 >=' 조건이 포함되어 있다.
- 변경 전 인덱스 구성에서 대부분 인덱스의 선두 컬럼이 '입력일'이다.
- 범위 조건으로 활용되는 컬럼이 선두인 것도 그렇지만, 선두 컬럼 입력일 조건에 해당하는 범위가 인덱스 전체 레코드에서 95% 이상이라는 사실이 가장 큰 문제였다.
  - 해당 매물 테이블에는 최근 한달 치 데이터만 보관하게 되는데, 만약 과거 데이터가 제대로 커팅되지 않았을 경우를 고려해서 해당 입력일 조건을 쿼리에 포함시켰던 것이다.