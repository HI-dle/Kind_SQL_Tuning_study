# 2. 인덱스 기본
## 2.2.5 ORDER BY 절에서 컬럼 가공
```sql
SELECT *
  FROM (
        SELECT TO_CHAR( A.주문번호, 'FM00000') AS 주문번호, A. 업체번호, A.주문금액
          FROM 주문 A
         WHERE A.주문일자 =: dt
           AND A.주문번호 > NVL(:next_ord_no, 0)
      ORDER BY 주문번호
        )
 WHERE ROWNUM <=30
```
- 인덱스: [주문일자 + 주문번호]
  - 인덱스 선두컬럼인 [주문일자]가 "=" 조건이므로 데이터가 다음 인덱스 컬럼인 [주문번호] 순으로 출력된다.
  - ORDER BY 절이 있어도 정렬 연산을 생략할 수 있는 상태다.

### Q: 그럼에도 불구하고, 실행계획에는 `SORT ORDER BY` 연산이 추가된다. 왜 그럴까?
- A: ORDER BY 절에 기술된 주문번호는 '순수한 주문번호'가 아니라 `TO_CHAR` 함수로 가공한 주문번호이기 때문
- 해결: 진짜 주문번호를 가리키게 주문번호를 명시해준다.
```sql
SELECT *
  FROM (
        SELECT TO_CHAR( A.주문번호, 'FM00000') AS 주문번호, A. 업체번호, A.주문금액
          FROM 주문 A
         WHERE A.주문일자 =: dt
           AND A.주문번호 > NVL(:next_ord_no, 0)
      ORDER BY A.주문번호 -- 이 처럼 A(주문 테이블 Alias를 붙여주기만 하면 된다.)
        )
 WHERE ROWNUM <=30
```

> 💡 참고1: TO_CHAR 함수에 FM000000 옵션은 숫자 1234를 '001234'로 변환해준다. (0으로 시작하는 여섯자리)

> 💡 참고2: `ORDER BY 1;` 은 SELECT-LIST에 나열된 첫번째 컬럼을 의미한다.

## 2.2.6 SELECT-LIST에서 컬럼 가공
### 인덱스: [장비번호, 변경일자, 변경순번] 구성 시
```sql
SELECT MIN(변경순번)
  FROM 상태변경이력
 WHERE 장비번호='C'
   AND 변경일자='2180316';
```
- 변경순번 `최소값`을 구하는 쿼리
  - `수직적 탐색을 통해 조건을 만족하는 가장 왼쪽지점`의 '첫번째 레코드'가 최소값
  - 옵티마이저가 따로 정렬을 수행하지 않음

```sql
SELECT MAX(변경순번)
  FROM 상태변경이력
 WHERE 장비번호='C'
   AND 변경일자='2180316';
```
- 변경순번 `최대값`을 구하는 쿼리도 마찬가지로 정렬을 수행하지 않음
  - 최소값을 찾아 수직적 탐색 시에는 왼쪽이였다면, `최대값을 찾을 때는 오른쪽으로 내려가는 점만 다르다.`

> `수직적 탐색`: 인덱스의 루트에서 시작해 조건에 맞는 리프까지 내려가는 과정
> 
> `MIN`: 왼쪽 끝 리프 노드로
> 
> `MAX`: 오른쪽 끝 리프 노드로
> 
> : 옵티마이저는 정렬을 안한다.

그래서 실행계획을 간단히 보면,
```sql
0 STATEMENT
1  SORT AGGREGATE
1   FIRST ROW
1    INDEX RANGE SCAN(MIN/MAX) ...
```
위와 유사하게 나타나는데, `FIRST ROW`와 `MIN/MAX`만 보면 되고, `최소 또는 최대값을 빠르게 찾을 때. 인덱스 리프 블록의 왼쪽(MIN) 또는 오른쪽(MAX)에서 (FIRST ROW)레코드 하나만 읽고 멈춘다.`는 의미이다.

### Q: 만약 SELECT 절을 아래처럼 바꾸면 어떻게 될까?
```sql
-- 변경 전
SELECT MAX(변경순번)

-- 변경 후
SELECT NVL(MAX(TO_NUMBER(변경순번), 0))
```
- A: 정렬 연산을 생략할 수 없다.
- 이유: 인덱스에는 `문자열 기준으로 정렬`되어 있는데, 이를 숫자값으로 바꾼 값 기준으로 요구했기 때문

```sql
-- 해결
SELECT NVL(TO_NUMBER(MAX(변경순번)), 0)
```
- 위처럼 해결할 수 있지만, `[변경순번]값이 고정너비`로 입력돼 있어야한다.
- 애초에 `[변경순번]데이터타입을 숫자형`으로 설계했다면 이렇게 튜닝할 일도 안 생긴다.

```sql
SELECT 장비번호, 장비명, 상태코드
     , (SELECT MAX(변경일자))
          FROM 상태변경이력
         WHERE 장비번호 = P.장비번호) 최종변경일자
  FROM 장비 P
 WHERE 장비구분코드 = 'A001'
```
- 스칼라 서브쿼리로 `최종변경일자`를 `상태변경이력` 테이블에서 조회
- 이 또한 정렬 연산 없이 `MIN/MAX`, `FIRST ROW` 방식으로 실행한다.

### Q. 최종 변경일자 + 최종 변경순번까지 출력하려면 SQL을 어떻게 작성해야할까?
```sql
SELECT 장비번호, 장비명, 상태코드
     , (SELECT MAX(변경일자))
          FROM 상태변경이력
         WHERE 장비번호 = P.장비번호) 최종변경일자
     , (SELECT MAX(변경순번))
          FROM 상태변경이력
         WHERE 장비번호 = P.장비번호
           AND 변경일자 = (SELECT MAX(변경일자)
                          FROM 상태변경이력
                         WHERE 장비번호 = P.장비번호)) 최종변경순번
  FROM 장비 P
 WHERE 장비구분코드 = 'A001'
```
- 가능은 하지만 `상태변경이력` 테이블을 여러번 읽어야하므로 비효율적이다.
- PK 컬럼이 더 많아지면 SQL 문도 훨씬 더 복잡해지므로 성능도 나빠진다.

```sql
SELECT 장비번호, 장비명, 상태코드
     , SUBSTR(최종이력, 1, 8) 최종변경일자
     , SUBSTR(최종이력, 9) 최종변경순번
  FROM (
        SELECT 장비번호, 장비명, 상태코드
             ,(SELECT MAX(변경일자 || 변경순번) -- || 은 oracle에서 concat(문자열 연결) 즉, MAX 값이 최종
                 FROM 상태변경이력
                WHERE 장비번호 = P.장비번호) 최종이력
         FROM 장비 P
        WHERE 장비구분코드 = 'A001'
        )
```
- PK 컬럼이 많아져도 덜 복잡하다.
- 각 장비당 이력이 많지 않으면 성능 상 크게 상관없지만, 이력이 많다면 성능에 문제가 될 수 있다.
  - 인덱스 컬럼을 가공했기 때문에 조건에 맞는 모든 행을 읽어야함

> 이에 대한 해답을 알기위해 `Top N 알고리즘`을 알아야한다고 합니다. 이는 `5.3.4 이력조회`에서 다룹니다.
> 
> 🤖 GPT 왈
> 
> `Top-N 문제`: "전체 데이터 중 상위 N개만 뽑아라"
> 
> `Top-N 알고리즘`: "상위 N개만 필요하니 전체 정렬하지 말고, 인덱스 활용해서 빠르게 찾아라"
> 
> `MIN/MAX` 집계보다 `ORDER BY ... FETCH FIRST N`이 유리하다.

## 2.2.7 자동 형변환
### 인덱스: [생년월일]이 선두 컬럼
```sql
SELECT * FROM 고객
 WHERE 생년월일 = 19821225
```
- 위 SQL을 실행하면, 생년월일 컬럼을 조건절에서 가공하지 않았음에도 옵티마이저는 `테이블 풀 스캔`을 선택한다.

이유는 옵티마이저가 SQL을 아래와 같이 변환했고, 결과적으로는 인덱스 컬럼이 가공됐기 때문이다.
```sql
SELECT * FROM 고객
 WHERE TO_NUMBER(생년월일) = 19821225
```
- `[생년월일] 컬럼이 문자형인데, 조건절 비교값을 숫자형`으로 표현했기 때문

>💡 조건절에서 양쪽 값의 데이터 타입이 다른 경우 DBMS마다 처리가 다르다.
> 1. 타입 체크를 엄격히 하여 컴파일 시점에 에러를 내는 DBMS
> 2. 오라클처럼 자동으로 형변환 처리. 오라클: 숫자형 vs 문자형 = 숫자형이 이긴다.(문자형 컬럼을 변환한다.)

### 날짜형 vs 문자형
```sql
-- 날짜형 vs 문자형은 날짜형이 이긴다.
SELECT * FROM 고객
 WHERE 가입일자 = '01-JAN-2018';
-- 날짜형 컬럼 기준으로 문자형 컬럼을 변환하므로 인덱스 사용에 전혀 문제가 없다.
-- 하지만, 이렇게 코딩하지말고 날짜 포멧을 정확히 지정해 주는 코딩 습관이 필요하다.
-- NLS_DATE_FORMAT이 다르게 설정된 환경에서 수행하면 오류가 날 수 있기 때문.

SELECT * FROM 고객
 WHERE 가입일자 = TO_DATE('01-JAN-2018', 'DD-MON-YYYY')
```

### LIKE 연산(문자열 비교 연산자)에서는 문자형이 숫자형을 이긴다.
```sql
SELECT * FROM 고객
 WHERE 고객번호 LIKE '9410%'
 
-- 실행계획 일부를 보면 TO_CHAR로 문자형으로 변환되는 것을 볼 수 있다.
1 - filter(TO_CHAR("고객번호") LIKE '9410%')
```

### LIKE 연산을 옵션 조건 처리 목적으로 사용하는 경우
예시: 거래 데이터 조회(거래일자 between)
```sql
-- SQL1: 사용자가 계좌번호를 입력할 경우
SELECT FROM * 거래
WHERE 계좌번호 = :acnt_no
AND 거래일자 between :trd_dt1 and :trd_dt2

-- SQL1: 사용자가 계좌번호를 입력하지 않을 경우
SELECT FROM * 거래
WHERE 거래일자 between :trd_dt1 and :trd_dt2
```

이를 하나의 SQL로 처리하기 위해 아래와 같이 LIKE 조건을 사용하는 방식을 채택하곤 한다.
```sql
SELECT * FROM 거래
WHERE 계좌번호 LIKE :acnt_no || '%'
AND 거래일자 between :trd_dt1 and :trd_dt2
```
- 사용자가 계좌번호를 입력하지 않았을 때, `acnt_no`에 `NULL`값을 입력함으로써 모든 계좌번호가 조회하도록 하는 쿼리
- `LIKE, BETWEEN` 조건을 같이 사용했으므로 인덱스 효율이 좋지 안좋아진다.
- 특히 계좌번호 컬럼이 `숫자형`이라면, `자동 형변환`이 발생해 계좌번호가 아예 인덱스 액세스 조건으로 사용되지 못한다.
- 계좌번호가 형변환되면 `[계좌번호 + 거래일자]` 순으로 구성된 인덱스를 `Range Scan`할 수 없다.
- `[거래일자 + 계좌번호]`순으로 구성된 인덱스는 `Range Scan`을 할 수는 있지만 인덱스 효율이 매우 안좋아진다.
  - 거래일자 범위에 속한 거래 데이터를 모두 읽으면서 계좌번호를 필터링하기 때문

### 자동 형변환 주의
자동 형변환이 작동하면 편리하다고 생각할 수 있지만, 성능과 애플리케이션 품질에 종종 문제가 생긴다.

성능 측면은 앞서 설명했고, 품질 측면을 살펴보자.

```sql
-- n_col(숫자형 컬럼)과 v_col(문자형 컬럼) 비교 시, 숫자형 컬럼으로 변활할 수 없는 문자열이라면?
where n_col = v_col

2행에 오류:
ORA-01722: 수치가 부적합합니다
```

실행 에러가 아니라 결과 오류가 생기는 사례도 존재한다.

예시: EMP 테이블에서 직원들 급여 조회
```sql
SELECT ROUND(avg(sal)) avg_sal
     , MIN(sal) min_sal
     , MAX(sal) max_sal
     , MAX(decode(job, 'PRESIDENT', NULL, sal)) max_sal2
  FROM EMP;
```

```
AVG_SAL  MIN_SAL  MAX_SAL  MAX_SAL2
-------  -------  -------  --------
   2073      800     5000       950   
```

```sql
SELECT empno, ename, job, sal from emp
WHERE job <> 'PRESIDENT'
ORDER BY sal DESC;


EMPNO ENAME JOB      SAL
----- ----- ------- ----
 7902  FORD ANALYST 3000 -- 950이 아니라 3000이다.
 7788 SCOTT ANALYST 3000
 7588 JONES MANAGER 2900
```

- 오라클이 `decode` 함수를 처리할 때 내부에서 사용하는 `자동 현변환 규칙 때문에 발생`

### decode(a, b, c, d)
- `'a = b'`이면 `c`를 반환하고, 아니면 `d` 반환
- 이때 `반환값의 데이터 타입`은 `c`에 의해 결정
  - 즉, `c`가 문자형, `d`가 숫자형이면 `d`가 `문자형으로 자동형변환`된다.
- `c`가 `NULL`이면 `varchar2`로 취급한다.

```sql
, MAX(decode(job, 'PRESIDENT', NULL, sal)) max_sal2
```
- 세번째(`c`)가 `NULL`이다.
  - 따라서, 네번째 인자(sal)을 `문자열로 자동형변환`
  - 문자열 기준으로 가장 큰 값인 950을 출력한 것

```sql
-- 해결책: 데이터 타입을 명시적으로 일치시켜주기
, MAX(decode(job, 'PRESIDENT', TO_NUMBER(NULL), sal)) max_sal2

-- 0을 써도 된다.
, MAX(decode(job, 'PRESIDENT', 0, sal)) max_sal2
```

> 결론: 자동형변환에 의존하지말고 인덱스 컬럼 기준으로 반대편 컬럼 또는 값을 정확히 형변환해주어야한다.
>
> SQL 성능 원리를 잘 모르는 개발자는 `TO_CHAR, TO_DATE, TO_NUMBER`같은 형변환 함수를 의도적으로 생략하곤 한다.
> 
> 함수를 생략하면 연산 횟수가 줄어 성능이 더 좋지 않을까라고 생각하기 때문이다.
> 
> 하지만 SQL 성능은 그런 데서 결정되는 것이 아니라 `블록 I/O`를 줄일 수 있느냐 없느냐에서 결정된다.
> 
> 형변환 함수를 생략한다고 연산 횟수가 줄어드는 것도 아니다. 계속 확인했듯, 개발자가 함수를 생략해도 옵티마이저가 자동으로 생성한다.

