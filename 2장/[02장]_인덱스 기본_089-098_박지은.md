# 인덱스 기본
## 2.2.2 인덱스를 range scan 할 수 없는 이유
이어서..

### IN 절
수직적 탐색을 통해 전화번호가 "01012345678"이거나 "01098765432"인 어느 한 지점을 바로 찾을 수 있을까?

```sql
where 전화번호 in ( :tel_no1, :tel_no2 )
```

IN 조건은 OR 조건을 표현하는 다른 방식일 뿐이기 때문에 불가능하다.

> SQL을 아래와 같이 UNION ALL 방식으로 작성하면, 각 브랜치별로 인덱스 스캔 시작점을 찾을 있어 Range Scan 가능
> 
> ```sql
> select
> from 고객
> where 전화번호 = :tel_no1
> union all
> select
> from 고객
> where 전화번호 = :tel_no2
> ```

때문에 IN 조건절에 대해서는 SQL 옵티마이저가 IN-List Iterator 방식을 사용한다.

- IN-List 개수만큼 Index Range Scan을 반복 
  - SQL을 UNION ALL 방식으로 변환한 것과 같은 효과를 얻을 수 있음 
  - 실행계획
  > - Execution Plan
  > 
  >   ```sql
  >   SELECT STATEMENT Optimizer=ALL_ROWS (Cost=2 Card=1 Bytes=39)
  >   INLIST ITERATOR
  >   TABLE ACCESS (BY INDEX ROWID) OF '고객' (TABLE) (Cost=2 Card=1)
  >   INDEX (RANGE SCAN) OF '고객_전화번호_IDX' (INDEX) (Cost=1 Card=1)
  >   ```
  >   Predicate Information (identified by operation id):
  > - 3 - access("전화번호" = :TEL_NO1 OR "전화번호" = :TEL_NO2)


### 정리
'인덱스를 정상적으로 사용한다'는 표현: 리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미

- 아래와 같은 조건절에는 인덱스를 정상적으로 사용할 수 없다. 
  ```sql
  where substr(생년월일, 5, 2) = '05'
  where nvl(주문수량, 0) < 100
  where 업체명 like '%대한%'
  where (전화번호 = :tel_no or 고객명 = :cust_nm)
  where 전화번호 in ( :tel_no1, :tel_no2 )
  ```
- 기본적으로 Index Range Scan이 불가능하나, OR 또는 IN 조건절은 옵티마이저의 쿼리 변환 기능을 통해 Index Range Scan 처리되기도 함.



## 2.2.3 더 중요한 인덱스 사용 조건

### 인덱스를 정상적으로 사용하는 데 있어 더 중요한 선행조건

인덱스를 **소속팀 + 사원명 + 연령** 순으로 구성했다고 하자.

아래 조건절에 대해 인덱스를 정상적으로 Range Scan 할 수 있을까?

```sql
select 사원번호, 소속팀, 연령, 입사일자, 전화번호
from 사원
where 사원명 = '홍길동'
```

- 인덱스 [소속팀 + 사원명 + 연령] 구성 의미 
  - 데이터를 소속팀 순으로 정렬하고, 
  - 소속팀이 같으면 사원명 순으로 정렬하고,
  - 사원명까지 같으면 연령 순으로 정렬한다”

- 즉, 이름이 같은 사원이더라도 소속팀이 다르면 서로 멀리 떨어지게 된다.
  - 예를 들어, `사원명 = '홍길동'` 조건을 만족하는 데이터는 리프 블록 전 구간에 흩어진다.


이 조건으로 검색하면, 인덱스 스캔 시작점은 찾을 수 없고, 어디서 멈춰야 할지도 알 수 없다.
- 인덱스 리프 블록을 처음부터 끝까지 모두 스캔해야 한다.

> 인덱스를 Range Scan 하기 위한 가장 첫 번째 조건은 가공하지 않은 상태로 **인덱스 선두 컬럼이 조건절에 있어야 한다는 사실**이다.

아래와 같은 질문을 받은 적이 있다.

“아래 SQL은 인덱스 컬럼을 가공했는데, 어떻게 인덱스를 Range Scan 할 수 있는가?”

```
TXA1234_IX02 인덱스 : 기준연도 + 과세구분코드 + 보고회차 + 실명확인번호
```

```sql
select *
from TXA1234
where 기준연도 = :stdr_year
  and substr(과세구분코드, 1, 4) = :txtn_dcd
  and 보고회차 = :rpt_tmrd
  and 실명확인번호 = :nm_cnfm_no
```

Execution Plan

```
0 SELECT STATEMENT Optimizer=ALL_ROWS
1 0 TABLE ACCESS (BY INDEX ROWID) OF 'TXA1234' (TABLE)
2 1 INDEX (RANGE SCAN) OF 'TXA1234_IX02' (INDEX)
```

- 인덱스를 Range Scan 하려면 **인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있어야 한다.**
- 반대로 말해, 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 인덱스 Range Scan은 무조건 가능하다.
- 위 질문은 인덱스 선두 컬럼인 `기준연도`를 조건절에서 가공하지 않았으므로 인덱스 Range Scan이 가능하다.



다만, 인덱스를 Range Scan 한다고 해서 **항상 성능이 좋은 건 아니**다.

---

### 인덱스 잘 타니까 튜닝 끝?

SQL을 개발하면서 실행계획을 확인하지 않는 개발자가 대다수다. 확인하더라도 인덱스를 타는지 안 타는지 확인하는 수준에 그친다.
인덱스를 잘 타면 성능도 문제없다고 생각한다.

아래 SQL은 인덱스를 잘 타고 있다.

> “인덱스를 탄다”는 표현은 “인덱스를 Range Scan 한다”와 같은 의미인 셈이다.

Execution Plan

```
0 SELECT STATEMENT Optimizer=ALL_ROWS
1 0 TABLE ACCESS (BY INDEX ROWID) OF '주문상품' (TABLE)
2 1 INDEX (RANGE SCAN) OF '주문상품_N1' (INDEX)
```

위 실행계획은 인덱스를 잘 타니까 성능에 문제가 없을까?

> 가정
> - `주문상품_N1` 인덱스는 [주문일자 + 상품번호] 순으로 구성
> - 테이블에 쌓이는 데이터량은 하루 평균 100만 건

아래 조건절을 살펴보자. 

```sql
SELECT *
FROM 주문상품
WHERE 주문일자 = :ord_dt
  AND 상품번호 LIKE '%PING';

SELECT *
FROM 주문상품
WHERE 주문일자 = :ord_dt
  AND SUBSTR(상품번호, 1, 4) = 'PING';
```

- `주문일자`(인덱스 선두 컬럼)
- 가공하지 않은 상태이므로 인덱스를 Range Scan 하는 데 문제가 없음.
- 스캔 시작점을 찾아 스캔하다가 중간에 멈출 수 있기에 인덱스를 잘 탄다고 할 수 있다.

#### 인덱스를 정말 잘 타는지는 **인덱스 리프 블록에서 스캔하는 양**을 따져봐야 알 수 있다.

위 SQL에서 `상품번호`는 스캔 범위를 줄이는 데 전혀 역할을 하지 못한다.

- 첫 번째 SQL은 **중간 값 검색**이기 때문이고, 
- 두 번째 SQL은 **컬럼을 가공했기 때문**이다.

따라서 위 조건절을 처리할 때 인덱스에서 스캔하는 데이터량은 `주문일자` 조건을 만족하는 **100만 건**이다.
이를 두고 인덱스를 잘 탄다고 말할 수 있을까?

> 이 문제는 3장 8절(3.3) “인덱스 스캔 효율화”에서 자세히 살펴본다.

# 2.2.4 인덱스를 이용한 소트 연산 생략

테이블과 달리 인덱스는 정렬돼 있다. 

인덱스가 정렬돼 있기 때문에 Range Scan이 가능하고, 

소트 연산 생략의 효과도 부수적으로 얻게 된다.(부분범위 처리와 결합하면 극적인 성능 개선도 가능)

PK를 **장비번호 + 변경일자 + 변경순번** 순으로 구성한 상태변경이력 테이블이 있다고 하자.

```
장비번호 | 변경일자   | 변경순번
B       | 20180505   | 031583
...
C       | 20180316   | 000001
C       | 20180316   | 000002
C       | 20180316   | 131576
C       | 20180316   | 131577
...
C       | 20180428   | 000001
C       | 20180428   | 000002
```

보듯 PK 인덱스에서 장비번호, 변경일자가 같은 레코드는 변경순번 순으로 정렬돼 있다.

아래와 같이 장비번호와 변경일자를 모두 '=' 조건으로 검색할 때 PK 인덱스를 사용하면 

결과집합은 변경순번 순으로 출력된다.

```sql
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
  AND 변경일자 = '20180316';
```

Execution Plan
```
0  SELECT STATEMENT Optimizer=ALL_ROWS (Cost=85 Card=81 Bytes=5K)
1  TABLE ACCESS (BY INDEX ROWID) OF '상태변경이력' (TABLE) (Cost=85)
2  INDEX (RANGE SCAN) OF '상태변경이력_PK' (INDEX (UNIQUE)) (Cost=3)
```

옵티마이저는 이런 속성을 활용해 SQL에 `ORDER BY`가 있어도 정렬 연산을 따로 수행하지 않는다.

PK 인덱스를 스캔하면서 출력한 결과집합은 어차피 변경순번 순으로 정렬되기 때문이다.

```sql
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
  AND 변경일자 = '20180316'
ORDER BY 변경순번;
```

Execution Plan

```
0  SELECT STATEMENT Optimizer=ALL_ROWS (Cost=85 Card=81 Bytes=5K)
1  TABLE ACCESS (BY INDEX ROWID) OF '상태변경이력' (TABLE) (Cost=85)
2  INDEX (RANGE SCAN) OF '상태변경이력_PK' (INDEX (UNIQUE)) (Cost=3)
```

실행계획에 `SORT (ORDER BY)` 연산이 없음을 확인할 수 있다.

즉, 위의 두 SQL은 동일한 방식(실행계획)으로 실행된다.

> 만약 정렬 연산을 대신할 수 있게 인덱스가 구성돼 있지 않다면, 아래와 같이 `SORT (ORDER BY)` 연산 단계가 추가된다.
> 
> Execution Plan
> 
> ```
> 0  SELECT STATEMENT Optimizer=ALL_ROWS (Cost=86 Card=81 Bytes=5K)
> 1  SORT (ORDER BY) (Cost=86 Card=81 Bytes=5K)
> 2  TABLE ACCESS (BY INDEX ROWID) OF '상태변경이력' (TABLE) (Cost=85)
> 3  INDEX (RANGE SCAN) OF '상태변경이력_PK' (INDEX (UNIQUE)) (Cost=3)
> ```
---
#### 인덱스 리프 블록은 양방향 연결 리스트 구조다.

오름차순(ASC) 정렬일 때: 조건을 만족하는 가장 작은 값을 찾아 좌측으로 수직적 탐색한 후 우측으로 수평적 탐색을 한다.

내림차순(DESC) 정렬일 때: 조건을 만족하는 가장 큰 값을 찾아 우측으로 수직적 탐색한 후 좌측으로 수평적 탐색을 한다.

아래 SQL은 `ORDER BY`절에서 내림차순 정렬을 요구하고 있다. 

```sql
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
  AND 변경일자 = '20180316'
ORDER BY 변경순번 DESC;
```

Execution Plan

```
0  SELECT STATEMENT Optimizer=ALL_ROWS (Cost=85 Card=81 Bytes=5K)
1  TABLE ACCESS (BY INDEX ROWID) OF '상태변경이력' (TABLE) (Cost=85)
2  INDEX (RANGE SCAN DESCENDING) OF '상태변경이력_PK' (INDEX (UNIQUE)) (Cost=3)
```

실행계획에서의 포인트는 아래와 같다.
- `SORT (ORDER BY)` 연산이 없다는 사실과
- `INDEX (RANGE SCAN)` 단계에 `DESCENDING`이라고 표시된 부분

> 인덱스로 소트 연산을 생략함으로써 성능을 높이는 구체적인 튜닝 기법은 5장 3절(6.3)에서 자세히 다룬다.

---

# 2.2.5 ORDER BY 절에서 컬럼 가공

"인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다"

위 문장에서 말하는 인덱스 컬럼은 대개 **조건절**에 사용한 컬럼을 말한다.

그런데 조건절이 아닌 `ORDER BY` 또는 `SELECT` 리스트에서 컬럼을 가공함으로 인해 인덱스를 정상적으로 사용할 수 없는 경우도 종종 있다.

```
장비번호 | 변경일자   | 변경순번
B       | 20180505   | 031583
...
C       | 20180316   | 000001
C       | 20180316   | 000002
C       | 20180316   | 131576
C       | 20180316   | 131577
...
C       | 20180428   | 000001
C       | 20180428   | 000002
```

상태변경이력 PK 인덱스를 **장비번호 + 변경일자 + 변경순번** 순으로 구성했다면, 아래 SQL도 정렬 연산을 생략할 수 있다.

```sql
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
ORDER BY 변경일자, 변경순번;
```

수직적 탐색을 통해 장비번호가 `'C'`인 첫 번째 레코드를 찾고,

인덱스 리프 블록을 스캔하면 자동으로 변경일자 + 변경순번 순으로 정렬되기 때문이다.


반면 SQL을 아래와 같이 작성했다면, 정렬 연산을 생략할 수 있을까? 

```sql
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
ORDER BY 변경일자 || 변경순번;  -- (여기서 변경일자 또는 변경순번을 가공하면 인덱스 정렬을 못 쓰게 됨)
```

생략할 수 없다.

인덱스에는 가공하지 않은 상태로 값을 저장했는데, 

가공한 값 기준으로 정렬해 달라고 요청했기 때문이다.

실제 개발 현장을 보면 이런 형태의 SQL을 의외로 자주 볼 수 있다.

### 재미있는 튜닝 사례

주문 PK 인덱스는 **주문일자 + 주문번호** 순으로 구성돼 있다. 

아래 SQL에 주문 PK 인덱스를 사용하면 선두 컬럼인 주문일자에 `'='` 조건이 있으므로 데이터가 주문번호 순으로 출력된다. 
```sql
SELECT *
  FROM (
        SELECT TO_CHAR( A.주문번호, 'FM00000') AS 주문번호, A. 업체번호, A.주문금액
          FROM 주문 A
         WHERE A.주문일자 =: dt
           AND A.주문번호 > NVL(:next_ord_no, 0)
      ORDER BY 주문번호
        )
 WHERE ROWNUM <=30
```

`ORDER BY` 절이 있어도 정렬 연산을 생략할 수 있는 상태다. 

그런데도 아래 실행계획에 `SORT (ORDER BY)` 연산이 나타난 이유는 무엇일까? 


답은 진영최가 설명해 줄 것이다.
