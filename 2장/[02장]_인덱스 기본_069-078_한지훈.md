# 인덱스 기본

---

 - 이 절에서 강조하고 싶은 부분은 인덱스 탐색 과정이 수직적, 수평적 탐색 두 단계로 이루어진 단 것이다.

### 2.1.1 미리 보는 인덱스 튜닝
 - 데이터를 찾는 2가지 방법
   - 어떤 초등학교를 방문해 '홍길동' 이라는 사람을 찾는 방법은 두가지다.
     - 첫째 - 모든 학년과 반을 돌며 홍길동을 찾는 것
     - 둘째 - 교무실에서 학생 명부를 조회해 홍길동 학생이 있는 교실만 찾아 가는 것이다.
     - 홀깅동이 많다면 전자가 빠르고 적다면 후자가 빠를 것이다.

![표_3-1.png](image%2F%ED%91%9C_3-1.png)

 - 위 표처럼 명부를 이름순으로 정렬하면 편한데 이것이 인덱스이다.
 - 학년-반-번호가 인덱스 ROWID에 해당한다.

 - 데이터베이스 테이블에서 데이터를 찾는 방법도 2가지이다.
   - 테이블 전체 스캔
   - 인덱스 사용

 - 앞서 설명한 모든 교실을 확인하는 것이 테이블 전체 스캔이고 명부를 확인하는 것이 인덱스이다.
 - 테이블 전체 스캔 관련해서는 튜닝 요소가 많지는 않지만 인덱스와 관련해서는 튜닝 요소가 많고 다양하다.

 - 인덱스 튜닝의 2가지 핵심요소
   - 인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용한다. 온라인 트랜잭션 처리 시스템에서는 소량 데이터를 주로 검색하므로 인덱스 튜닝이 중요하다.
   - 세부적인 인덱스 튜닝 방법은 여러가지지만 핵심 요소는 크게 2가지이다.
     - 첫번쨰는 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것이다. 즉, 인덱스 스캔 효율화 튜닝이다.
     - 시력이 1.0 ~ 1.5인 최진영 학생을 찾는 경우를 예로 들 때 학생 명부를 이름과 시력순으로 정렬했다면 아래와 같이 소량만 스캔하면 된다.

![표_3_2.png](image%2F%ED%91%9C_3_2.png)

 - 하지만이름과 시력 순으로 하지 않는다면 데이터는 테이블을 전체 스캔해서 찾아야 할 것이다.
 - 인덱스 튜닝의 두번째 핵심요소는 테이블 액세스 획수를 줄이는 것이다. 인덱스 스캔 후 테이블 레코드를 엑세스할 때 랜덤 I/O 방식을 사용하므로 이를 랜덤 액세스 최소화 튜닝이라 한다.
   - 학생명부에서 시력이 1.0 ~ 1.5인 최진영 학생을 찾는 경우를 다시 생각해보면 기력이 1.0 ~ 1.5인 학생이 50명이고 이름이 최진영인 사람이 5명일때 최진영이란 이름을 가지고 시력이 1.0 ~ 1.5인 사람은 2명이라 하자.
   - 이름과 시력순으로 정렬한 학생 명부가 있다면 좋겠지만 만약 이름으로만 정렬, 시력으로만 정렬 이렇게 2가지가 있다면 어떤게 더 효율적인 탐색일까?
   - 당연히 이름순이 된다. 찾을 범위가 확실히 적기 때문이다.

![표_3_3.png](image%2F%ED%91%9C_3_3.png)


 - 인덱스 효율화 튜닝과 랜덤 액세스 최소화 튜닝 둘 다 중요하지만 더 중요한 하나를 고르자면 랜덤 액세스 최소화 튜닝이다. 성능에 미치는 영향이 크기 때문이다.
 - 랜덤 액세스는 테이블의 데이터 블록에 랜덤 I/O가 발생하고 디스크 상에서 흩어져 있기 때문에 성능 비용이 크기 때문에 이 범위를 줄여야 하는 것이 성능상 중요하다.

### SQL 튜닝은 랜덤 I/O와의 전쟁
 - 데이터베이스 성능이 느린 이유는 디스크 I/O 때문이다. 읽어야 할 데이터량이 많고 그 과정 디스크 I/O가 많이 발생할 때 느리다.
 - 성능을 위해 DBMS가 제공하는 많은 기능이 느린 랜덤 I/O를 극복하기 위해 개발됐다.
 - IOT, 클러스터, 파티션에서부터 테이블 Prefetch, Batch I/O처럼 겉으로 잘 드러나지 않는 숨은 기능까지 모두 그렇다. 이 기능들의 본질은 랜덤 I/O를 줄이는데 있다.
 - 조인 메서드 중 가장 일반적으로 사용하는 NL 조인이 대량 데이터 조인할 때 느린 이유도 랜덤 I/O 때문이다. 그래서 소트머지 조인과 해시 조인이 개발 됐으므로 이들 조인 메서드도 결국 랜덤 I/O를 극복하기 위해 개발된 기능이다.

### 2.1.2 인덱스 구조
 - 인덱스는 대용량 테이블에서 필요한 데이터만 빠르게 효율적으로 액세스 하기 위해 사용하는 오브젝트이다.
 - 대표적으로 책에 있는 목차나 색인을 많이 예시로 든다.
 - 색인이 없게 되면 원하는 주제를 읽기 위해 모든 페이지를 찾아야 할 것이다.
 - 데이터베이스에서도 인덱스 없이 데이터를 검색하려면 테이블을 처음부터 끝까지 모두 읽어야 한다. 반면 인덱스를 이용하면 일부만 읽고 멈출 수 있다. 즉 범위 스캔이 가능하다. 범위 스캔이 가능한 이유는 인덱스가 정렬이 되어 있기 때문이다.
 - DBMS는 일반적으로 B Tree 인덱스를 사용한다.
 

![이미지_2_3.png](image%2F%EC%9D%B4%EB%AF%B8%EC%A7%80_2_3.png)

- B tree 인덱스 구조는 위와 같고 나무를 거꾸로 뒤집은 모양이라 뿌리(루트)가 위고 가지(브랜치)를 거쳐 앞사귀(리프)가 있다.
- 루트와 브랜치 블록에 있는 각 레코드는 하위 블록에 대한 주소값을 갖는다. 키값은 하위 블록에 저장된 키값의 범위를 나타낸다.
- 루트 불록에서 서 레코드가 가리키는 하위 블록에는 서보다 크거나 같은 레코드가 저장되어 있다는 끗이다. 오른쪽에 한지훈이 가리키는 하위 블록에는 한지훈보다 작거나 같은 레코드가 저장되어 있다.
- 루트와 브랜치 블록에는 키값을 갖지 않는 특별한 레코드가 하나 있다. LMC라 표기되어 있는데 이는 Leftmost Child의 줄임말이다. LMC는 자식 노드중 가장 왼쪽 끝에 위치한 블록을 가리킨다.
- LMC가 가리키는 주소로 찾아간 블록에는 키값을 가진 첫 번쨰 레코드보다 작거나 같은 레코드가 저장되어 있다.
  - 위 그림에서는 왼쪽 브랜치에 강헤주, 오른쪽 브랜치에는 최진영
- 리프 블록에 저장된 각 레코드는 키값 순으로 정렬돼 있을 뿐만 아니라 테이블 레코드를 가지키는 주소값인 ROWID를 갖는다. 인덱스 키 값이 같으면 ROWID 순으로 정렬된다.
- 인덱스 스캔을 하는 이유는 검색 조건을 만족하는 소량의 데이터를 빨리 찾고 거기서 ROWID를 얻기 위함이다.
- ROWID는 데이터 블록 주소인 DBA와 로우번호로 구성되므로 이 값을 알면 해당 레코드를 찾아갈 수 있다.
  - ROWID : 데이터 블록 주소 + 로우 번호
  - 데이터 블록 주소 : 데이터 파일 번호 + 블록 번호
  - 블록 번호 : 데이터파일 내에서 부여한 상대적 순번
  - 로우 번호 : 블록 내 순번
- 인덱스 탐색 과정은 앞에서 수직, 수평적 탐색으로 나눌 수 있다 했다.
  - 수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정
  - 수평적 탐색 : 데이터를 찾는 과정

### 2.1.3 인덱스 수직적 탐색
 - 정렬된 인덱스 레코드 중 조건을 만족하는 첫 번째 레코드를 찾는 과정이다. 즉, 인덱스 스캔 시작지점을 찾는 과정이다.
 - 인덱스 수직적 탐색은 루트 블록에서부터 시작한다. 루트를 포함해 브랜치 블록에 저장된 각 인덱스 레코드는 하위 블록에 대한 주소값을 갖는다. 루트에서 시작해 리프 블록까지 수직적 탐색이 가능한 이유이다.
 - 수직적 탐색 과정에 찾고자 하는 값보다 크거나 같은 값을 만나면 바로 직전 레코드가 가리키는 하위 블록으로 이동한다. 예시로 아까 그림에서 최진영을 찾을 때 루트 블록에는 찾는 값보다 크거나 작은 값이 없다. 하위블록으로 이동하게 되고 브랜치 블록에서는 최진영보다 큰 한지훈 블록을 찾았다. 이런식으로 비교해 찾아가 리프노드에 도달해 해당 값을 찾은 것이다.
 - 남정길라는 이름을 찾을 때는 루트 블록에 남정길보다 큰 값이 있으므로 바로 직전 레코드인 LMC가 가리키는 하위 블록으로 이동한다. 그렇다고 그 레코드가 가리키는 하위 블록으로 이동하면 안 된다. 바로 직전 레코드인 LMC가 가리키는 하위 블록으로 이동해야 첫번쨰 리프 블록 맨 마지막에 저장된 남정길 레코드를 빠뜨리지 않는다.
 - 수직적 탐색은 조건을 만족하는 레코드를 찾는 과정이 아닌 조건을 만족하는 첫번째 레코드를 찾는 것이다.

 - 인덱스르 수직적으로 탐색할 때 루트를 포함한 브랜치 블록은 분기의 이정표 역할을 한다. 해당 조건을 만족하는 레코드가 있는 곳을 이정표 따라 찾아가는 것이다.

### 2.1.4 인덱스 수평적 탐색
 - 수직적 탐색을 통해 스캔 시작점을 찾았다면 찾고자 하는 데이터가 더 안 나타날 때까지 인덱스 리프 블록을 수평적으로 스캔한다. 
 - 인덱스에서 본격적으로 데이터를 찾는 과정이다.
 - 인덱스리프 블록끼리는 서로 앞뒤 블록에 대한 주소값을 갖는다. 즉, 양방향 연결 리스트 구조이다. 좌에서 우로, 또는 우에서 좌로 수평적 탐색이 가능한 이유다.
 - 인덱스를 수평적으로 탐색하는 이유로는
   - 조건절을 만족하는 데이터를 모두 찾기 위해서
   - ROWID를 얻기 위해서
 - 필요한 컬럼을 인덱스가 모두 갖고 있어 인덱스만 스캔하고 끝나는 경우도 있지만, 일반적으로 인덱스를 스캔하고서 테이블도 액세스 한다. 이때 ROWID가 필요하다.


