# 5.4.3 Top N 쿼리가 아닐 때 발생하는 소트 부하

## `ORDER BY` 아래 `ROWNUM` 조건절 제거

```sql
SELECT *
FROM (
  SELECT ROWNUM no, a.*
  FROM (
    SELECT 거래일시, 체결건수, 체결수량, 거래대금
    FROM 종목거래
    WHERE 종목코드 = 'KR123456'
      AND 거래일시 >= '20180304'
    ORDER BY 거래일시
  ) a
)
WHERE no BETWEEN (:page - 1) * 10 + 1 AND (:page * 10);
```

### 트레이스 결과

> Sort Area는 앞에서와 똑같이 설정하고 테스트함.

| Call      | Count | CPU Time | Elapsed Time | Disk | Query | Current | Rows |
| --------- | ----- | -------- | ------------ | ---- | ----- | ------- | ---- |
| Parse     | 1     | 0.000    | 0.000        | 0    | 0     | 0       | 0    |
| Execute   | 1     | 0.000    | 0.000        | 0    | 0     | 0       | 0    |
| Fetch     | 2     | 0.281    | 0.858        | 698  | 690   | 14      | 10   |
| **Total** | 4     | 0.281    | 0.858        | 698  | 690   | 14      | 10   |

****

```sql
Rows   Row Source Operation
----   --------------------
0      STATEMENT
10       VIEW (cr=690 pr=698 pw=698 time=357962 us)
49857      COUNT (cr=690 pr=698 pw=698 time=1604327 us)
49857        VIEW (cr=690 pr=698 pw=698 time=1205452 us)
49857          SORT ORDER BY (cr=690 pr=698 pw=698 time=756723 us)
49857            TABLE ACCESS FULL 종목거래 (cr=690 pr=0 pw=0 time=249345 us)
```

- Stopkey가 사라짐 (=‘Top N 소트’ 알고리즘이 작동하지 않았다는 뜻)
  - 그 결과로 Physical Read(pr=698)와 Physical Write(pw=698)가 발생
    - 같은 양(690블록)의 데이터를 읽고 정렬을 수행했지만, ‘Top N 소트’ 알고리즘이 작동해 메모리 내에서 정렬을 했을 때와 달리, 이번은 디스크를 이용해야만 한다.

### AutoTrace 결과

**Statistics**

```
6 recursive calls
14 db block gets
690 consistent gets
698 physical reads
...

sorts (memory)
1 sorts (disk)
```
- ‘sorts (disk)’ 항목이 1이므로 정렬 과정에 Temp 테이블스페이스를 이용했다는 사실을 알 수 있다.

# 5.4.4 분석 함수에서의 Top N 소트

- 윈도 함수 중 `RANK`나 `ROW_NUMBER` 함수는 ‘Top N 소트’ 알고리즘이 작동하기 때문에 `MAX` 함수보다 소트 부하가 적다.

## 예시: 모든 장비에 대한 마지막 이력 레코드를 찾는 쿼리
### `MAX` 이용

```sql
SELECT 장비번호, 변경일자, 변경순번, 상태코드, 메모
FROM (
  SELECT 장비번호, 변경일자, 변경순번, 상태코드, 메모,
         MAX(변경순번) OVER (PARTITION BY 장비번호) 최종변경순번
  FROM 상태변경이력
  WHERE 변경일자 = :upd_dt
)
WHERE 변경순번 = 최종변경순번;
```

| Call      | Count | CPU Time | Elapsed Time | Disk   | Query  | Current  | Rows |
|-----------|-------|----------|--------------|--------|--------|----------|------|
| Parse     | 1     | 0.000    | 0.000        | 0      | 0      | 0        | 0    |
| Execute   | 1     | 0.000    | 0.000        | 0      | 0      | 0        | 0    |
| Fetch     | 2     | 2.750    | 9.175        | 13456  | 4536   | 9        | 10   |
| **Total** | 4     | 2.750    | 9.175        | 13456  | 4536   | 9        | 10   |

```
Rows   Row Source Operation
----   --------------------
0      STATEMENT
10       VIEW (cr=4536 pr=13456 pw=8960 time=4437847 us)
498570     WINDOW SORT (cr=4536 pr=13456 pw=8960 time=9120662 us)
498570       TABLE ACCESS FULL 상태변경이력 (cr=4536 pr=0 pw=0 time=1994341 us)
```

 
- `WINDOW SORT` 단계에서 13,456개의 Physical Read(pr)와 8,960개의 Physical Write(pw)가 발생(Sort Area 가 작은 테스트 환경이다.)

### `MAX` 대신 `RANK` 이용

```sql
SELECT 장비번호, 변경일자, 변경순번, 상태코드, 메모
FROM (
  SELECT 장비번호, 변경일자, 변경순번, 상태코드, 메모,
         RANK() OVER (PARTITION BY 장비번호 ORDER BY 변경순번 DESC) rnum
  FROM 상태변경이력
  WHERE 변경일자 = :upd_dt
)
WHERE rnum = 1;
```

| Call        | Count  | CPU Time | Elapsed Time | Disk  | Query  | Current | Rows  |
|-------------|--------|----------|--------------|-------|--------|---------|-------|
| Parse       | 1      | 0.000    | 0.000        | 0     | 0      | 0       | 0     |
| Execute     | 1      | 0.000    | 0.000        | 0     | 0      | 0       | 0     |
| Fetch       | 2      | 0.969    | 1.062        | 40    | 4536   | 42      | 10    |
| **Total**   | 4      | 0.969    | 1.062        | 40    | 4536   | 42      | 10    |

```
Rows   Row Source Operation
----   --------------------
0      STATEMENT
10       VIEW (cr=4536 pr=40 pw=40 time=1061996 us)
111        WINDOW SORT PUSHED RANK (cr=4536 pr=40 pw=40 time=1061971 us)
498570       TABLE ACCESS FULL 상태변경이력 (cr=4536 pr=0 pw=0 time=1495760 us)
```

- Physical Read와 Physical Write가 `MAX` 함수에 비해 많이 줌
- 시간 8초가량 덜 소요