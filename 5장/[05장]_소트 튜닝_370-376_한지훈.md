# 쇼트 튜닝

---

### INDEX_DESC 힌트 활용

- 단순하게 쿼리하면서도 성능을 높이기 위해 SQL 튜닝 전문가들이 전통적으로 사용해 온 방식은 인덱스를 역순으로 읽도록 index_desc 힌트를 사용했고, 첫번째 레코드에서 바로 멈추도록 rownum <= 1 조건을 사용했다.

```oracle-sql
select 장비번호, 장비명
      , substr(최종이력, 1, 8) 최종변경일자
      , to_number(substr(최종이력, 9, 4)) 최종변경순번
      , substr(최종이력, 13) 최종상태코드
from (
    select 장비번호, 장비명
           ,(select /*+ INDEX_DESC(X 상태변경이력_PK) */
                    변경일자 || lpad(변경순번, 4) || 상태코드
             from 상태변경이력 X
             where 장비번호 = p.장비번호
             and rownum <=1) 최종이력
    from 장비 p
    where 장비구분코드 = 'A001'
)
```

 - 이 방식은 확실히 성능은 좋다. 문제는 인덱스 구성이 완벽해야만 쿼리가 잘 동작한다. 인덱스를 잘 구성해 청므엔 잘 동작하다가도 인덱스 구성이 바뀌면 언제든 결과 집합에 문제가 생길 수 있다. PK 구성을 변경하는 일은 거의 없으므로 대개 문제가 되지 않는다고 볼 수 있지만 다른 대안이 있다면 그 방법을 사용하는게 바람직하다.


### 11g / 12c 신기능 활용
 - 방금 본 쿼리는 사실
```oracle-sql
select 장비번호, 장비명
      , substr(최종이력, 1, 8) 최종변경일자
      , to_number(substr(최종이력, 9, 4)) 최종변경순번
      , substr(최종이력, 13) 최종상태코드
from (
    select 장비번호, 장비명
           ,(select 변경일자 || lpad(변경순번, 4) || 상태코드
             from 상태변경이력
             where 장비번호 = p.장비번호 -- ORA-00904(부적합한 식별자) 오류 
             and rownum <=1) 최종이력
    from 장비 p
    where 장비구분코드 = 'A001'
)
```
 - 이 쿼리가 동작하지 않기 때문에 궁여지책으로 사용해 온 측면이 있다. 11g 이하 버전에서 실행해보면 ORA-00904 오류가 발생한다. 메인쿼리 컬럼을 서브쿼리 내 인라인 뷰에서 참조했기 때문에 발생하는 파싱 오류이다.
 - 스칼라 서브쿼리는 맞지만 오라클이 내부적으로 파싱할 때 p 별칭을 아직 정의되지 않은 상태로 간주하기 때문이다.
 - 이 오류를 회피하기 위해서는 11g부터 쿼리를 다음과 같이 작성할 수 있다.

```oracle-sql
select 장비번호, 장비명
      , substr(최종이력, 1, 8) 최종변경일자
      , to_number(substr(최종이력, 9, 4)) 최종변경순번
      , substr(최종이력, 13) 최종상태코드
from (
    select 장비번호, 장비명
           ,(select 변경일자 || lpad(변경순번, 4) || 상태코드
             from (select 장비번호, 변경일자, 변경순번, 상태코드
                    from 상태변경이력
                    order by 변경일자 DESC, 변경순번 DESC)
             where 장비번호 = p.장비번호 
             and rownum <=1) 최종이력
    from 장비 p
    where 장비구분코드 = 'A001'
)
```
- SQL 형태만 놓고 보면 인라인 뷰로 정의한 집합을 우선 만들고 나서 장비번호화 ROWNUM 조건을 필터링할 것처럼 보인다.
- 하지만 실제 수행해보면 [장비번호 = p.장비번호] 조건절이 인라인 뷰 안쪽으로 파고 들어간다.
- Predicate Pushing 이라 불리는 쿼리 변환이 작동한 결과다. 이 방식을 사용하면 혹시 인덱스 구성이 변경됐을 때 Top N stopkey 알고리즘이 작동하지 않아 성능이 느려질 순 있지만 쿼리 결과집합은 보장된다.

```oracle-sql
select 장비번호, 장비명
      , substr(최종이력, 1, 8) 최종변경일자
      , to_number(substr(최종이력, 9, 4)) 최종변경순번
      , substr(최종이력, 13) 최종상태코드
from (
    select 장비번호, 장비명
           ,(select 변경일자 || lpad(변경순번, 4) || 상태코드
             from (select 변경일자, 변경순번, 상태코드
                    from 상태변경이력
                    where 장비번호 = p.장비번호
                    order by 변경일자 DESC, 변경순번 DESC) 
             and rownum <=1) 최종이력
    from 장비 p
    where 장비구분코드 = 'A001'
```

 - 12c부턴 위와 같은 패턴도 SQL 파싱 오류 없이 TOP N stopkey 알고리즘이 잘 동작한다. 11g까진 오류가 발생했던 패턴이다.


>윈도우 함수와 Row Limiting 절
> 
> 윈도우 함수 기능이 점점 좋아지고 12c 부터는 Row Limiting 절도 지원한다. 지금까지 설명한 Top N 쿼리와 성능을 비교해 볼 필요가 있는데, 결론은 인덱스 활용이 중요한 온라인성 쿼리에선 위도우 함수 또는 Row Limiting 절을 사용하는 것은 시기상조로 Top N 쿼리를 사용하는 것을 추천한다.

> (1) 이력조회 
> 
> 이력조회하는 서브쿼리에 윈도우 함수를 사용할 수 있지만 , Top N Stopkey 알고리즘은 동작하지 않는다 따라서 인덱스로 소트를 생략할 수 있을 때 사용해선 안된다.
```oracle-sql
select 장비번호, 장비명
      , substr(최종이력, 1, 8) 최종변경일자
      , to_number(substr(최종이력, 9, 4)) 최종변경순번
      , substr(최종이력, 13) 최종상태코드
from (
    select 장비번호, 장비명
           ,(select 변경일자 || lpad(변경순번, 4) || 상태코드
             from (select 변경일자, 변경순번, 상태코드
                            , row_number() over (order by 변경일자 DESC, 변경순번 DESC) no
                    from 상태변경이력
                    where 장비번호 = p.장비번호) 
             where no =1) 최종이력
    from 장비 p
    where 장비구분코드 = 'A001'
```
> 12c부터 Row Limiting 절을 이용해 구현할 수 있지만 마찬가지로 Top N stopkey 알고리즘이 작동하지 않는다. 참고로 Row Limiting 절을 사용하면 윈도우 함수를 사용하는 형태(위 쿼리)로 옵티마이저가 쿼리를 변환한다. 따라서 실행계획도 똑같다.
```oracle-sql
select 장비번호, 장비명
      , substr(최종이력, 1, 8) 최종변경일자
      , to_number(substr(최종이력, 9, 4)) 최종변경순번
      , substr(최종이력, 13) 최종상태코드
from (
    select 장비번호, 장비명
           ,(select 변경일자 || lpad(변경순번, 4) || 상태코드
             from (select 변경일자, 변경순번, 상태코드
                    from 상태변경이력
                    where 장비번호 = p.장비번호
                    order by 변경일자 DESC, 변경순번 DESC) 
             fetch first 1 rows only ) 최종이력
    from 장비 p
    where 장비구분코드 = 'A001'
```
> 위 쿼리는 12c부터 Row Limiting 절을 이용해 구현한 예시이다.

> (2) 페이징 처리
> 
> 아래 쿼리와 같이 윈도우 함수를 페이징 처리에 활용할 때는 Top N stopkey 알고리즘이 작동할 수 있다. 하지만 카디널리티와 비용 계산이 불완전함으로 인해 소트를 생략할 수 있는데도 인덱스를 사용하지 않는 경우가 자주 발생한다. 따라서 페이징 처리에 이 방식을 사용하면 index/index_desc 힌트를 써야 할 일이 자주 생긴다.
```oracle-sql
select 변경일자, 변경순번, 상태코드
from (
        select 변경일자, 변경순번, 상태코드
                , row_number() over (order by 변경일자 DESC, 변경순번 DESC) no
        from 상태변경이력
        where 장비번호 = :eqp_no)
where no between 1 and 10;
```

> 소트 생략 가능한 인덱스가 없어서 Top N 소트 알고리즘이 작동할 때 기존 Top n 쿼리보다 윈도우 함수가 소트 공간을 더 많이 사용하는 단점도 있다.
> 12c 이후로 페이징 처리에 아래와 같이 Row Limiting 절을 사용할 수 있지만, 윈도우 함수를 사용할 때와 똑같은 성능 특성을 보인다.
```oracle-sql
select 변경일자, 변경순번, 상태코드
from (
        select rownum no, 변경일자, 변경순번, 상태코드
        from (
             select 변경일자, 변경순번, 상태코드
             from 상태변경이력
             where 장비번호 = :eqp_no
             order by 변경일자, 변경순번
             fetch first 10 rows only )
             )
where no >= 1;
```
 - FETCH FIRST 10 ROWS ONLY = Oracle 12c 이상에서의 LIMIT 구문이다.
 - 책에서는 같은 성능 특성을 보인다 해서 찾아보니
 - 윈도우 함수는 ROWNUM 기반 방식과 동일한 논리적 동작을 수행하지만 인라인 뷰를 제거하고 옵티마이저가 단일 쿼리로 최적화할 수 있게 하므로 일반적으로 더 효율적이며 실행 계획도 단순해진다.


