### Top N 쿼리 이용해 최소/최대값 구하기
`ROWNUM <= 1` 조건을 이용해 Top 1 레코드를 찾는다.

#### 쿼리
```sql
CREATE INDEX EMP_X1 ON EMP(DEPTNO, SAL);

-- 인덱스에 MGR은 포함되지 않음

SELECT *
FROM (SELECT SAL
      FROM EMP
      WHERE DEPTNO = 30
        AND MGR = 7698 -- 반면 WHERE 절에 MGR가 포함되어 있음
      ORDER BY SAL DESC
)
WHERE ROWNUM <= 1;
```

#### 실행계획
```sql
Execution Plan
--------------------------------------------------------
0     SELECT STATEMENT Optimizer=ALL_ROWS (Cost=2 Card=1 Bytes=13)
1  0    COUNT (STOPKEY)
2  1      VIEW (Cost=2 Card=1 Bytes=13)
3  2        TABLE ACCESS (BY INDEX ROWID) OF 'EMP' (TABLE) (Cost=1 Card=1 ... )
4  3          INDEX (RANGE SCAN DESCENDING) OF 'EMP_X1' (INDEX) (Cost=1 Card=5)
```

#### Top N Stopkey 알고리즘은 모든 컬럼이 인덱스에 포함돼 있지 않아도 잘 동작한다.
위 SQL에서 `인덱스에 MGR이 없지만,` 가장 큰 SAL 값을 찾기 위해 `DEPTNO=30`을 만족하는 `전체 레코드를 읽지 않는다.`

![그림_5-15.png](image%2F%EA%B7%B8%EB%A6%BC_5-15.png)
- `DEPTNO=30`을 만족하는 가장 오른쪽에서부터 역순으로 스캔하면서 테이블 액세스
- 테이블에서 `MGR=7698`을 만족하는 레코드 하나를 찾으면 멈춘다.

#### 특징
- 인라인 뷰를 사용하므로 쿼리가 약간 더 복잡하다
- 성능 측면에서는 `MIN/MAX` 쿼리보다 낫다

# 5.3.4 이력 조회
일반 테이블은 각 컬럼의 현재(최종) 값만 저장하므로 변경되기 이전 값을 알 수 없다.

값이 어떻게 변경돼 왔는지 과거 이력을 조회할 필요가 있다면, `이력 테이블을 따로 관리`해야 한다.

![그림_5-16.png](image%2F%EA%B7%B8%EB%A6%BC_5-16.png)

과거 변경이력을 관리하기 위해 `이력 테이블`을 두지만, 일반적으로 `이력 테이블`에는 `현재(최종) 데이터`도 저장한다.

**그렇게해야 변경 이력을 완벽히 재생할 수 있다.(`어떤 값으로 언제 바뀌었는지 알기 위함`)**

## 가장 단순한 이력 조회
이력 데이터를 조회할 때 `First Row Stopkey` 또는 `Top N Stopkey` 알고리즘이 작동할 수 있게 인덱스 설계 및 SQL을 구현할 수 있어야한다.

장비구분코드가 A001인 장비 목록을 조회하고, 최종변경일자도 같이 조회해보자.

```sql
SELECT 장비번호, 장비명, 상태코드
       ,(SELECT MAX(변경일자)
         FROM   상태변경이력
         WHERE  장비번호 = P.장비번호) 최종변경일자
FROM   장비 P
WHERE  장비구분코드 = 'A001'

--------------------------------------------------------------------------------------
| Id  | Operation                        | Name        | Starts |  
--------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                 |             |     1 |   
|   1 |   SORT AGGREGATE                 |             |    10 |     
|   2 |     FIRST ROW                    |             |    10 |      
|   3 |       INDEX RANGE SCAN (MIN/MAX) | 상태변경이력_PK|    10 |      
|   4 |   TABLE ACCESS BY INDEX ROWID    | 장비         |     1 |     
|   5 |     INDEX RANGE SCAN             | 장비_N1      |     1 |
--------------------------------------------------------------------------------------
```
- 위 SQL 문에서 이력 조회하는 스칼라 서브쿼리 부분에 `First Row Stopkey` 알고리즘이 작동하고 있다.
- `상태변경이력_PK` 인덱스가 `[장비번호 + 변경일자 + 변경순번]` 순으로 구성돼있기 때문에 가능한 일이다.

## 점점 복잡해지는 이력 조회
만약 최종 변경 순번까지 이력 테이블에서 읽어야 한다면 어떻게 쿼리해야 할까?

```sql
SELECT 장비번호, 장비명, 상태코드
     , SUBSTR(최종이력, 1, 8) 최종변경일자
     , TO_NUMBER(SUBSTR(최종이력, 9, 4)) 최종변경순번
FROM (
    SELECT 장비번호, 장비명, 상태코드
        , (SELECT MAX(H.변경일자 || LPAD(H.변경순번, 4)) 
            FROM 상태변경이력 H 
            WHERE H.장비번호 = P.장비번호) 최종이력
    FROM 장비 P
    WHERE 장비구분코드 = 'A001'
)
--------------------------------------------------------------------------
 Id  | Operation                        | Name         | Starts |
--------------------------------------------------------------------------
   0 | SELECT STATEMENT                 |              |     1 |  
   1 |   SORT AGGREGATE                 |              |    10 |    
   2 |     INDEX RANGE SCAN             | 상태변경이력_PK |    10 | 
   3 |   TABLE ACCESS BY INDEX ROWID    | 장비          |     1 |   
   4 |     INDEX RANGE SCAN             | 장비_N1       |     1 |   
--------------------------------------------------------------------------
```
- 이 SQL은 `인덱스 컬럼을 가공`했으므로 `First Row Stopkey` 알고리즘이 작동하지 않는다.
- 장비별 상태변경이력이 많을 때는 문제가 될 수 있다.

#### 따라서 장비별 상태변경이력이 많을 때는 아래와 같이 쿼리하는 게 낫다.
```sql
SELECT 장비번호, 장비명, 상태코드
     , (SELECT MAX(H.변경일자) -- 한 번
        FROM   상태변경이력 H
        WHERE  장비번호 = P.장비번호) 최종변경일자
     , (SELECT MAX(H.변경순번) -- 두 번
        FROM   상태변경이력 H
        WHERE  장비번호 = P.장비번호
        AND    변경일자 = (SELECT MAX(H.변경일자) -- 세 번
                         FROM   상태변경이력 H
                         WHERE  장비번호 = P.장비번호)) 최종변경순번
FROM 장비 P
WHERE 장비구분코드 = 'A001'

--------------------------------------------------------------------------
Id   | Operation                           | Name         | Starts |
--------------------------------------------------------------------------
   0 | SELECT STATEMENT                    |              |     1 |  
   1 |   SORT AGGREGATE                    |              |    10 |    
   2 |     FIRST ROW                       |              |    10 |
   3 |       INDEX RANGE SCAN (MIN/MAX)    | 상태변경이력_PK |    10 |
   4 |   SORT AGGREGATE                    |              |    10 |
   5 |     INDEX RANGE SCAN                | 상태변경이력_PK |    10 |
   6 |       SORT AGGREGATE                |              |    10 |
   7 |         FIRST ROW                   |              |    10 |
   8 |           INDEX RANGE SCAN (MIN/MAX)| 상태변경이력_PK |    10 |    
   9 |   TABLE ACCESS BY INDEX ROWID       | 장비          |     1 |   
  10 |     INDEX RANGE SCAN                | 장비_N1       |     1 |
--------------------------------------------------------------------------
```
- 쿼리가 복잡하고 상태변경이력을 세 번 조회하는 비효율이 있지만, `First Tow Stopkey` 알고리즘이 잘 작동하므로 성능은 비교적 좋다.
- 그러나, `상태변경이력` 테이블에서 읽어야 할 컬럼이 많아지면 SQL문이 훨씬 더 복잡해진다는 문제가 생긴다.

#### 예시) 만약 상태코드까지 조회해야한다면?
```sql
-- 매우 복잡해진다!

SELECT 장비번호, 장비명, 상태코드
     , (SELECT MAX(H.변경일자) -- 한 번
        FROM   상태변경이력 H
        WHERE  장비번호 = P.장비번호) 최종변경일자
     , (SELECT MAX(H.변경순번) -- 두 번
        FROM   상태변경이력 H1
        WHERE  장비번호 = P.장비번호
        AND    변경일자 = (SELECT MAX(H.변경일자) -- 세 번
                         FROM   상태변경이력 H2
                         WHERE  장비번호 = P.장비번호)) 최종변경순번
     , (SELECT H1.상태코드
        FROM   상태변경이력 H1 -- 네 번
        WHERE  장비번호 = P.장비번호
        AND    변경일자 = (SELECT MAX(H2.변경일자) -- 다섯 번
                         FROM   상태변경이력 H2
                         WHERE  장비번호 = P.장비번호)
        AND    변경순번 = (SELECT MAX(H3.변경순번) -- 여섯 번
                         FROM   상태변경이력 H3
                         WHERE  장비번호 = P.장비번호
                         AND    변경일자 = 
                                    (SELECT MAX(H4.변경일자) -- 일곱 번
                                     FROM   상태변경이력 H4
                                     WHERE  장비번호 = P.장비번호))) 최종상태코드
FROM 장비 P
WHERE 장비구분코드 = 'A001'
```