# 5.4 Sort Area를 적게 사용하도록 SQL 작성

소트연산이 불가피하다면 메모리 내에서 처리를 완료할 수 있도록 노력해야 한다.
Sort Area 크기를 늘리는 방법도 있지만, Sort Area를 적게 사용할 방법부터 찾는 것이 우선이다.

## 5.4.1 소트 데이터 줄이기

특정 기간에 발생한 주문 상품 목록을 파일로 내리고자 한다. 어떤것이 Sort Area를 적게 사용할까 ?

- 1번
```sql
SELECT LPAD(상품번호, 30)
       || LPAD(상품명, 30)
       || LPAD(고객ID, 10)
       || LPAD(고객명, 20)
       || TO_CHAR(주문일시, 'yyyymmdd hh24:mi:ss') /*숫자+공백+시,분,초 = 17자*/
FROM 주문상품
WHERE 주문일시 BETWEEN :start AND :end
ORDER BY 상품번호;
```
- 2번
```sql
SELECT LPAD(상품번호, 30)
       || LPAD(상품명, 30)
       || LPAD(고객ID, 10)
       || LPAD(고객명, 20)
       || TO_CHAR(주문일시, 'yyyymmdd hh24:mi:ss')
FROM (
    SELECT 상품번호, 상품명, 고객ID, 고객명, 주문일시
    FROM 주문상품
    WHERE 주문일시 BETWEEN :start AND :end
    ORDER BY 상품번호
);
```

1번의 경우 레코드당 17가공한 결과집합을 Sort Area에 담는다.
반면 2번 SQL은 가공하지 않은 상태로 정렬을 완료하고 나서 최종 출력할 때 가공한다.
따라서 2번 SQL이 Sort Area를 훨씬 더 적게 사용한다.

또 다른 예시
- 1번
```sql
SELECT *
FROM 예수금원장
ORDER BY 총예수금 DESC;

-- Execution Plan
---------------------------------------------
 0  SELECT STATEMENT Optimizer=ALL_ROWS (Cost=184K  Card=2M  Bytes=716M)
 1 0  SORT (ORDER BY) (Cost=184K  Card=2M  Bytes=716M)
 2 1   TABLE ACCESS (FULL) OF '예수금원장' (TABLE) (Cost=25K  Card=2M  Bytes=716M)
---------------------------------------------
```
- 2번
```sql
SELECT 계좌번호, 총예수금
FROM 예수금원장
ORDER BY 총예수금 DESC;

-- Execution Plan
---------------------------------------------
0  SELECT STATEMENT Optimizer=ALL_ROWS(Cost=31K  Card=2M  Bytes=17M)
1 0  SORT (ORDER BY) (Cost=31K  Card=2M  Bytes=17M)
2 1   TABLE ACCESS (FULL) OF '예수금원장' (TABLE) (Cost=24K  Card=2M  Bytes=17M)
---------------------------------------------
```

2번 SQL이 적게 사용한다. 1번 SQL은 모든 컬럼을 Sort Area에 저장하는 반면, 2번 SQL은 계좌번호화 총 예수금만 저장하기 때문이다.
실행계획에서 맨 우측열을 보면 1번 SQL은 716MB, 2번 SQL은 17MB를 처리했다.
두 SQL 모두 테이블을 Full Scan 했으므로 읽은 데이터량은 똑같지만, 소트한 데이터량이 다르므로 성능도 다르다.
229개 컬럼을 가진 테이블로 테스트 한 결과 1번 SQL은 14.41초, 2번 SQL은 1.2초가 소요되었다.

## 5.4.2 Top N 쿼리의 소트 부하 경감 원리

인덱스로 소트연산을 생략할 수 없을 때, Top N 쿼리가 어떻게 작동하는지 살펴보자.

전교생 1000명 중 가장 큰 학생 열명을 선발하려고 한다.
만약 전교생을 키 순서대로 정렬한 학생명부가 있다면 가장 위쪽에 있는 열명을 선발하면 된다. `Top N Stopkey` 알고리즘이다. 그런 학생명부를 미리 준비해두지 않았다면 (인덱싱 되어있지 않다면) 아래와 같은 방법이 가장 효과적이다.

>1. 전교생을 운동장에 집합시킨다
>2. 맨 앞줄, 맨 왼쪽에 있는 학생 열명을 단상앞으로 불러 키 순서대로 세운다.
>3. 나머지 990명을 한명씩 교실로 들여보내면서 현재 Top 10위치에 있는 항생과 키를 비교한다. 더 큰 학생이 나타나면 현재 Top 10 위치에 있는 학생을 교실로 들여보낸다.
>4. Top 10에 새로 진입한 학생 키에 맞춰 자리를 재배치한다.
>5. 전교생이 다 교실로 들어갈 때 까지 3번과 4번을 반복한다

5번까지 수행하고 나면 최종적으로 그 학교에서 가장 키 큰 학생 열 명만 운동장에 남는다.
지금 설명한 알고리즘을 `Top N 소트 알고리즘`이라고 부르자.

#### 3절 2항에 나온 페이징 쿼리

```sql
SELECT *
FROM (
    SELECT ROWNUM no, a.*
    FROM (
        SELECT 거래일시, 체결건수, 체결수량, 거래대금
        FROM 종목거래
        WHERE 종목코드 = 'KR123456'
          AND 거래일시 >= '20180304'
        ORDER BY 거래일시
    ) a
    WHERE ROWNUM <= (:page * 10)
)
WHERE no >= (:page - 1) * 10 + 1;
```

아래는 인덱스로 소트연산을 생략할 수 없어 Table Full Scan 방식으로 처리할 때의 SQL 트레이스다.

```sql
Call      Count  CPU Time  Elapsed Time  Disk  Query  Current  Rows
-------------------------------------------------------------------
Parse         1     0.000        0.000     0      0        0      0
Execute       1     0.000        0.000     0      0        0      0
Fetch         2     0.078        0.083     0    690        0     10
-------------------------------------------------------------------
Total         4     0.078        0.084     0    690        0     10


Rows     Row Source Operation
-------------------------------------------------------------------
    0 STATEMENT
   10  COUNT STOPKEY (cr=690 pr=0 pw=0 time=83318 us)
   10   VIEW  (cr=690 pr=0 pw=0 time=83290 us)
49857    SORT ORDER BY STOPKEY (cr=690 pr=0 pw=0 time=83264 us)
49857     TABLE ACCESS FULL 종목거래 (cr=690 pr=0 pw=0 time=299191 us)
```

실행계획에 Sort Order By 오퍼레이션이 나타났다. Table Full Scan 대신 종목코드가 선두인 인덱스를 사용할 수도 있지만, 바로 뒤 컬럼이 거래일시가 아니면 소트연산을 생략할 수 없으므로 지금처럼 Sort Order By 오퍼레이션이 나타난다.

여기서 Sort Order By 옆에 `Stopkey` 라고 표시된 부분을 주목하면, 소트 연산을 피할 수 없어 Sort Order By 오퍼레이션을 수행하지만 `Top N 소트` 알고리즘이 작동한다는 사실을 실행계획에 표시하고 있다.

이 알고리즘이 작동하면, 소트 연산(=값 비교) 횟수와 SortArea 사용량을 최소화 해 준다.<br> 예를 들어, page 변수에 1을 입력하면 열 개 원소를 담을 배열 공간만 있으면 된다.

열 개짜리 배여로 최상위  열 개 레코드를 찾는 방법은 농구팀 선발 과정과 같다.
1. 처음 읽은 열 개 레코드를 거래일시 오름차순으로 정렬해서 배열에 담는다.
2. 이후 읽는 레코드에 대해서는 배열 맨 끝(큰쪽 끝)에 있는 값과 비교해서 그보다 작은 값이 나타날 때만 배열 내에서 다시 정렬한다.
3. 기존에 맨 끝에 있던 값은 버린다.

이 방식으로 처리하면 대상 집합이 아무리 커도 많은 메모리 공간이 필요하지 않다. 전체 레코드를 다 정렬하지 않고도 오름차순으로 최소값을 갖는 열 개 레코드를 정확히 찾아낼 수 있다. <br>이것이 Top N 소트 알고리즘이 소트연산 횟수와 Sort Area 사용량을 줄여주는 원리다.

```sql
Statistics
-----------------------------
0  recursive calls
0  db block gets
690  consistent gets
0  physical reads /*요부분이랑*/
...
1  sorts (memory)
0  sorts (disk)/*요부분*/
```

아래는 AutoTrace 결과다. 위에서 본 SQL 트레이스에서 Physical Read(=pr) 와 Physical Write(=pw)가 전혀 발생하지 않았다. (pr=0, sort(disk)=0)
참고로 많은 메모리 공간이 필요 없다는 사실을 증명하기 위해 Sort Area를 작게 설정하고 테스트 했다.

> - pw ? pr ?
    > Physical Reads : 디스크에서 실제 블록을 읽은 횟수 (I/O 발생) <br> Physical Writes : 디스크에 데이터를 쓴 횟수 (정렬 결과나 임시테이블스페이스에 기록 시 발생)