# 쇼트 튜닝

---

### (4) Sort Unique
 - 옵티마이저가 서브쿼리를 풀어 일반 조인문으로 변환하는 것을 서브쿼리 Unnesting이라 하고 이것인 이전에 학습한 내용이다.
 - Unnesting된 서브쿼리가 M쪽 집합이면(1쪽 집합이더라도 조인 컬럼에 유니크 인덱스가 없으면), 메인 쿼리와 조인하기 전에 중복 레코드부터 제거해야 한다.
 - 이때 Sort Unique 오퍼레이션이 나타나고 만약 PK/Unique 제약 또는 Unique 인덱스를 통해 Unnesting된 서브쿼리의 유일성이 보장된다면 Sort Unique 오퍼레이션은 생략된다.

>실행 계획을 넣기 귀찮음으로...
> 
> Sort Unique 오퍼레이션은 실행계획 상에서 중복 제거를 위한 정렬(unique sort) 과정을 의미하고 옵티마이저가 Unnesting된 서브쿼리의 결과가 중복될 가능성이 있다고 판단할 때 중복을 없애기 위해 내부적으로 정렬 후 중복 제거를 수행하는 단계이다.

 - 부가 설명을 하자면

```oracle-sql
SELECT d.deptno,
       (SELECT e.ename
          FROM emp e
         WHERE e.deptno = d.deptno)
FROM dept d;
```
 - 위 쿼리에서 부서당 하나의 이름만 반환한다고 가정하고 스칼라 서브쿼리를 구성 했을떄 실제 데이터에서는 emp 테이블에 같은 deptno가 여러 명 있을 수 있다.
 - 이렇게 M쪽 관계가 생기면 스칼라 서브쿼리가 여러 행을 반환할 수도 있게 된다.
 - Oracle 옵티마이저는 이 스칼라 서브쿼리를 조인(Unnesting) 해서 실행할 때 조인 전에 서브쿼리 결과를 중복 제거하는 연산을 추가하고 이때 실행 계획에 Sort Unique가 나오고 내부적으로

```oracle-sql
SELECT d.deptno, e.ename
FROM dept d
LEFT JOIN (SELECT DISTINCT deptno, ename
           FROM emp) e
ON e.deptno = d.deptno;
```
- DISTINCT하기 위해 내부적으로 정렬 후 중복 제거 과정을 수행하게 되는 것이다.
- 하지만 만약 emp.deptno가 유일한 컬럼이라는 것을 즉, PK나 Unique Index 라면?
  굳이 정렬해서 중복 제거할 필요가 없다 판단해 SORT UNIQUE 오퍼레이션을 생략한다.


- Union, Minus, Intersect 같은 집합 연산자를 사용할 때도, 위 설명에서 Distinct 연산도 Sort Unique 오퍼레이션이 나타나게 된다.
- 오라클 10gR2부터는 Distinct 연산에도 Hash Unique 방식을 사용하고 Group By와 마찬가지로 Order By를 생략할 때 그렇다.
  - Distinct 연산에도 Hash Unique 으로 해결 되고 ORDER BY가 있으면 결과를 정렬해야 하므로 Sort Unique, ORDER BY가 없으면 순서 상관없으니 Hash Unique 가능인것을 말한다.

###  (5) Sort Join

 - Sort Join 오퍼레이션은 소트머지 조인을 수행할때 나타난다.

###  (6) Window Sort

- Window Sort는 윈도우 함수(=분석 함수)를 수행할 때 나타난다.
 - 윈도우 함수가 요구하는 정렬 순서대로 데이터를 정렬하는 작업

## 5.2 소트가 발생하지 않도록 SQL 작성
 - SQL 작성할 때 불필요한 소트가 발생하지 않도록 주의해야 한다.
 - Union, Minus, Distinct 연산자는 중복 레코드를 제거하기 위한 소트 연산을 발생시키므로 꼭 필요한 경우에만 사용하고 성능이 느리다면 소트 연산을 피할 방법이 있는지 찾아봐야 한다. 조인 방식도 잘 선택해야 한다.

### 5.2.1 Union VS Union All
- SQL에 Union을 사용하면 옵티마이저는 상단과 하단 두 집합 간 중복을 제거하려고 소트 작업을 수행한다.
- 반면, Union All은 중복을 확인하지 않고 두 집합을 단순히 결합하므로 소트 작업을 수행하지 않는다. 따라서 될 수 있다면 Union All을 사용해야 한다.
- 그런데, Union을 Union All로 변경하려다 자칫 결과 집합이 달라질 수 있으므로 조심해야 한다.
- Union 대신 Union All을 사용해도 되는지 정확히 판단하려면 데이터 모델에 대한 이해와 집합적 사고가 필요하다.
- 그런 능력이 부족하면 알 수 없는 데이터 중복, 혹시 모를 데이터 중복을 우려해 중복 제거용 연산자를 불필요하게 자주 사용하게 된다.
 
![그림_5-6.png](image%2F%EA%B7%B8%EB%A6%BC_5-6.png)

- 위 데이터 모델을 예시로 
```oracle-sql
select 결제번호, 주문번호, 결제금액, 주문일자 ...
from 결제
where 결제수단코드 = 'M' and 결제일자 = '20180316'
union 
select 결제번호, 주문번호, 결제금액, 주문일자 ...
from 결제
where 결제수단코드 = 'C' and 결제일자 = '20180316'
```

- 위 SQL은 Union 상단과 하단 집합 사이 인스턴스 중복 가능성이 없다. 결제수단코드 조건절에 다른 값을 입력했기 때문인데 그런데도 Union을 사용함으로 인해 소트 연산을 발생시키게 된다.
![그림_5-7.png](image%2F%EA%B7%B8%EB%A6%BC_5-7.png)
- SQL에 위아래 두 집합이 상호배타적(위 이미지)이므로 Union 대신 Union All을 사용해도 된다.

```oracle-sql
select 결제번호, 결제수단코드, 주문번호, 결제금액, 결제일자, 주문일자 ...
from 결제
where 결제일자 = '20180316'
union 
select 결제번호, 결제수단코드, 주문번호, 결제금액, 결제일자, 주문일자 ...
from 결제
where 결제일자 = '20180316'
```

 - 결제일자와 주문일자 조건은 상호배타적 조건이 아니기 때문에 위 SQL에서 Union 상단과 하단 집합 사이에 인스턴스 중복 가능성이 있다.
 - 만약 Union을 Union All로 변경하면 결제일자와 주문일자가 같은 결제 데이터가 중복 돼 출력된다.

![그림_5-8.png](image%2F%EA%B7%B8%EB%A6%BC_5-8.png)

 - 소트 연산이 일어나지 않도록 Union All을 사용하면서도 데이터 중복을 피하려면 아래와 같이 하면 된다.

```oracle-sql
select 결제번호, 결제수단코드, 주문번호, 결제금액, 결제일자, 주문일자 ...
from 결제
where 결제일자 = '20180316'
union 
select 결제번호, 결제수단코드, 주문번호, 결제금액, 결제일자, 주문일자 ...
from 결제
where 결제일자 = '20180316'
and 결제일자 <> '20180316'
```
 - 참고로 결제일자가 Null 허용 컬럼이면 맨 아래 조건절을
```oracle-sql
and (결제일자 <> '20180316' or 결제일자 is null) 
```
 - 이렇게 변경해야 하고 
```oracle-sql
and LNNVL(결제일자 = '20180316') 
```
 - 위와 같이 LNNVL 함수를 이용해도 된다.





