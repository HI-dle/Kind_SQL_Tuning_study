# 5.3 인덱스를 이용한 소트 연산 생략
## 5.3.2 TOP N 쿼리
### 페이징 처리

> 3-Tier 환경 (클라이언트-서버-DB) 환경에서 부분범위 처리를 활용하는 방법.<br> 3-Tier 환경에서는 대량의 결과집합을 조회할 때 페이징 처리 기법을 활용한다.


일반적으로 사용하는 표준 패턴
```sql
	  select *
		from (
		    select rownum no, a.*
		    from (
		        /* SQL Body */
		    ) a
		    where rownum <= (:page * 10)
		)
	  where no >= (:page - 1) * 10 + 1
```
- TOP N 쿼리이므로 ROWNUM으로 지정한 건수만큼 결과 레코드를 얻으면 거기서 바로 멈춘다.
- 뒤쪽 페이지로 이동할수록 읽는데이터량도 많아지는 단점이 있지만,보통 앞쪽 데이터만 확인하므로 크게 문제가 되지 않는다.
    - 예를들어 인터넷 카페 게시글 목록을 조회하거나 은행 사이트에서 입출금 내역을 조회할 때 일반적으로 1~2페이지만 확인한다.
- 3-Tier 환경에서 부분범위 처리를 활용하기 위해 할 일
    1. `부분범위 처리가 가능하도록 SQL을 작성한다.` 부분범위 처리가 잘 작동하는지 (토드, 오렌지와 같은) 쿼리 툴에서 테스트한다.
    2. 작성한 SQL 문을 페이징 처리용 표준 패턴 SQL Body 부분에 붙여 넣는다.

> `부분범위 처리가 가능하도록 SQL을 작성한다.`
- 인덱스 사용 가능하도록 조건절을 구사하고, 조인은 NL 조인 위주로 처리(룩업을 위한 작은 테이블은 해시조인 Build Input으로 처리해도 됨)하고, Order By 절이 있어도 소트연산을 생략할 수 있도록 인덱스를 구성해주는 것을 말한다.

완성된 페이징 처리 SQL
```sql
select *
from (
    select rownum no, a.*
    from (
        select 거래일시, 체결건수, 체결수량, 거래대금
        from 종목거래
        where 종목코드 = 'KR123456'
          and 거래일시 >= '20180304'
        order by 거래일시
    ) a
    where rownum <= (:page * 10)
)
where no >= (:page - 1) * 10 + 1


Execution Plan
-------------------------------------------------
 0   SELECT STATEMENT Optimizer=ALL_ROWS (Cost=16 Card=756 Bytes=126K)
 1 0   VIEW (Cost=16 Card=756 Bytes=126K)
 2 1    COUNT (STOPKEY) /* -> NO SORT + STOPKEY */
 3 2     VIEW (Cost=16 Card=756 Bytes=117K)
 4 3      TABLE ACCESS (BY INDEX ROWID) OF '종목거래' (TABLE) (Cost=16 ...)
 5 4       INDEX (RANGE SCAN) OF '종목거래_PK' (INDEX) (Cost=4 Card=303)
-------------------------------------------------
```

### 페이징 처리 ANTI 패턴
- 위 SQL문의 order by 아래쪽  ROWNUM 조건절이 불필요해 보여 조건을 제거하고 아래와 같이 표현하면 더 간결하게 작성할 수 있다
```sql
select *
from (
    select rownum no, a.*
    from (
        select 거래일시, 체결건수, 체결수량, 거래대금
        from 종목거래
        where 종목코드 = 'KR123456'
          and 거래일시 >= '20180304'
        order by 거래일시
    ) a
)
where no between (:page - 1) * 10 + 1 and (:page * 10)
```

개발자는 프로그램 소스를 간결하게 표현하고 싶어 하며, 페이징 처리에 위와 같은 패턴을 사용하는 개발팀도 많다.
뿐만 아니라 페이징 처리 부분을 자동으로 삽입해주는 개발 프레임워크 중에서도 해당 패턴을 사용하는 것을 목격했다 (고한다)

**위의 Order by 아래쪽 ROWNUM은 단순한 조건절이 아니다.**
- 이는 `Top N Stopkey 알고리즘` (그리고 TOP N 소트 알고리즘)을 작동하게하는 열쇠다.
- 불필요해 보인다고 ROWNUM 조건절을 제거하면 실행계획이 아래와 같이 바뀐다.

```sql
Execution Plan
-------------------------------------------------
 0   SELECT STATEMENT Optimizer=ALL_ROWS (Cost=16 Card=756 Bytes=126K)
 1 0   FILTER
 2 1    VIEW (Cost=16 Card=756 Bytes=126K)
 3 2     COUNT  /* -> NO SORT + NO STOP */
 4 3      VIEW (Cost=16 Card=756 Bytes=117K)
 5 4       TABLE ACCESS (BY INDEX ROWID) OF '종목거래' (TABLE)(Cost=16..)
 6 5        INDEX (RANGE SCAN) OF '종목거래_PK' (INDEX) (Cost=4 Card=303)
-------------------------------------------------
```

Sort Order By 오퍼레이션은 나타나지 않지만 Count 옆에 StopKey 가 없음을 확인할 수 있다.

소트 생략 가능하므로 인덱스를 구성했으므로 소트 연산은 생략되었지만, Stopkey가 작동하지 않아 전체 범위를 처리한다.

![[5-10.png]]
>SQL 트레이스를 분석해 보면 이 방식의 문제점을 바로 확인할 수 있지만, SQL 트레이스에 익숙하지 않은 초보자를 위해 더 쉽게 확인할 수 있는 방법을 소개한다.  
우선, 노트북에 오라클을 설치하자. 방금 설명한 패턴으로 SQL을 작성하고, 조회 조건에 해당하는 데이터를 아주 많이 입력하자. 그 상태에서 SQL을 수행해 보면, 화면에 첫 번째 페이지가 금방 출력된다.  
그 순간 노트북에 귀를 가까이 가져가 보면 하드디스크 돌아가는 소리가 계속 날 것이다. 맨 아래 between 조건에 해당하는 데이터는 이미 다 출력했음에도 불구하고, 그것을 만족하는 데이터가 더 존재하는지 확인하면서 내는 소리다.  
DB 서버가 원격에 있다면 직접 소리를 들을 수 없지만, 잘못된 페이징 처리 패턴이 DB 서버에 어떤 영향을 주는지 여기서 분명히 이해하기 바란다.

- 인라인 뷰 내에서 전체 범위 처리 - 이후 no로 필터링하는 방식

#### 부분범위 처리 가능하도록 SQL 작성하기
`부분범위 처리 가능하도록 SQL을 작성한다`는 의미를 설명하기 위한 튜닝 사례

- 거래 테이블 인덱스 구성
```sql
거래_PK  : 거래일자 + 계좌번호 + 거래순번  
거래_X01 : 계좌번호 + 거래순번 + 결제구분코드
```

아래 Top N 쿼리는 인덱스로 소트 연산을 생략할 수 없기 때문에 실행계획에 Sort Order By 오퍼레이션(ID=3)이 나타났다.  
화면에 50개 레코드만 출력하고 싶은데도, 거래일자 조건에 해당하는 데이터를 모두 읽어 정렬을 마칠 때까지 기다려야 하는 상황이다.

```sql
select *
from (
    select 계좌번호, 거래금액, 주문금액, 주문수량, 결제구분코드, 주문매체구분코드
    from 거래
    where 거래일자 = :ord_dt
    order by 계좌번호, 거래순번, 결제구분코드
)
where rownum <= 50
```

```sql
-------------------------------------------------
 0   SELECT STATEMENT Optimizer=ALL_ROWS (Cost=433K Card=10 Bytes=1K)
 1 0   COUNT (STOPKEY)
 2 1    VIEW (Cost=433K Card=421K Bytes=57M)
 3 2     SORT (ORDER BY STOPKEY) (Cost=433K Card=421K Bytes=40M)
 4 3      TABLE ACCESS (BY INDEX ROWID) OF '거래' (TABLE) (Cost=423K ...)
 5 4       INDEX (RANGE SCAN) OF '거래_PK' (INDEX) (Cost=2K Card=421K)
-------------------------------------------------
```

PK 인덱스에 결제구분코드를 추가하면 소트 생략이 가능하지만,  PK에 컬럼을 함부로 추가할 수는 없다.  
`거래일자 + 계좌번호 + 거래순번 + 결제구분코드` 순으로 구성된 인덱스를 하나 더 만들어도 되지만,  
트랜잭션이 많은 행에 테이블에는 인덱스는 최소한으로 유지해야 하기 때문에 이 역시 탐탁치 않다.

불필요한 소트가 발생하지 않도록 SQL을 작성하려면 데이터 모델에 대한 이해와 집합적 사고가 필요하다고 앞서 강조했는데,  여기서도 그런 능력이 필요하다.

PK가 `거래일자 + 계좌번호 + 거래순번`이고,  `거래일자 = :조건`이다.  
같은 거래일자 데이터들 계좌번호 + 거래순번 순으로 정렬해 놓고 보면  중복 레코드가 전혀 없다.  
때문에  결제구분코드를 `Order By` 절에서 제거하면  `Sort Order By` 오퍼레이션이 사라지고, 부분범위 처리가 잘 작동한다.